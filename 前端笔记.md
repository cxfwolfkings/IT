# 目录

1. 第一部分 javascript + jQuery
2. 第二部分 node + npm + es6 + typescript
3. 第三部分 vue + angular + react
4. 第四部分 微信小程序 + Flutter
5. 第五部分 项目总结 + 附录
6. 第六部分 UI设计

## 第一部分 javascript + jQuery

### 1.1 [javascript核心](./1.1_javascript核心.md)

- 概述
- 词法结构
- 类型、值和变量
- 表达式、运算符和语句
- 对象、数组和函数
- 类、模块、子集和扩展

### 1.2 [客户端javascript](./1.2_客户端javascript.md)

1. web中的js简介
2. dom操作
3. 样式设置
4. 事件处理
5. 示例
6. 客户端存储
7. 多媒体和图形

### 1.3 [html5](./1.3_html5.md)

### 1.4 [jQuery类库](./1.4_jQuery类库.md)

1. jQuery简介
2. 选择器
3. Dom操作
4. 样式设置
5. 事件处理
6. 动画效果
7. 示例
   - 输入框输入限制
8. jQuery常用插件库

### 第12天：[require](./1.5_require.md)

### 第13天：[Bootstrap](./1.6_Bootstrap.md)

## 第二部分 node + npm + es6 + typescript

### 第1天：[服务器端javascript](./2.1_服务器端javascript.md)

### 第2-10天：[node](./2.2_node.md)

### 第10-12天：[npm](./2.3_npm.md)

### 第12-15天：[webpack](./2.4_webpack.md)

### 第15-20天：[es6](./2.5_es6.md)

### 第20-24天：[typescript](./2.6_typescript.md)

## 第三部分 vue + angular + react

### 第1-8天：[vue](./3.1_vue.md)

- 安装 / 目录结构 / 单文件应用
- 模板语法 / 常用指令 / 过滤器
- 计算属性 / 监听 / 响应接口
- 条件语句 / 循环语句
- 样式绑定
- 事件处理 / 周期事件
- 表单 / 组件
- 自定义指令
- vue-resource / axios
- vue-router
- i18n / wappalyzer
- Vuex
- ElementUI / mint-ui / iview
- 动画 / 混入
- 项目总结与参考

### 第9-15天：[Angular](./3.2_Angular.md)

- 禅道理念 / 运行条件 / Angular架构 / 核心概念模型 / 浏览器兼容性
- 模块 & 组件 & 模板 & 元数据 & 数据绑定 & 指令 & 服务 & 依赖注入
- 项目实战 & 总结 & 附录 & 参考

### 第15-24天：[React](./3.3_React.md)

- 安装 & 元素渲染
- JSX 简介
- 组件 & Props
- State & 生命周期

### 第25-30天：[Knockout](./3.4_Knockout.md)

## 第四部分 微信小程序 + Flutter

### 第1-6天：[小程序](./4.1_小程序.md)

- 什么是小程序 / 注册小程序 / 开发环境
- 布局：margin、padding、border、flex
- 前端组件：view、image、text、Swiper、
- 数据绑定 / Wafer2 / CodeIgniter / URI / 通过JSON文件读取数据 / 通过Controller返回数据
- 项目配置（Pages、Windows、TabBar、Debug） / 生命周期 / UI（布局、样式、视图容器、表单）
- 发起请求 / 上传图片（预览、回显） / 下载图片（回显、保存）/ 地图
- 音频 / 视频 / 绘图 / 动画
- 常用功能：拨电话
- 项目实战：需求分析、技术选择、基本架构与关注点解决方案、代码编写

### 第7-15天：[跨平台框架](./4.2_跨平台框架.md)

- 安装 / 配置编辑器 / HelloWorld / 开发工具
- Widget框架 / 布局 / 交互
- Web / Android / iOS / React Native
- 手势 / 动画 / 字体 / 盒约束 / 资源和图片
- 文本输入 / 路由和导航 / 国际化
- packages / 平台特定代码 / 文件读写 / 网络 / JSON和序列化
- 测试 / 调试 / 构建发布
- 总结：架构图、分层设计、渲染管道、构建漂亮的用户界面、滑动的魔法...

## 第五部分 项目总结 + 附录

### 第1天：[前端总结](./5.1_前端总结.md)

### 第2天：[附录](./5.2_附录.md)

### 第3天：[RxJS](./5.3_RxJS.md)

网上有一个站点；禅意花园 -> csdn 网页论坛

开源之祖 sourceforeg .net  

Php 开源 php-open.com  模仿->()创新

[Spine](http://maccman.github.com/spine)实现了类

## 第六部分 UI设计

### 6.1 [CSS](./6.1_css.md)

1. 布局
2. 内容
   - 文字效果（超出一行、两行隐藏）
   - 图形效果（圆形、三角形、五角星、六芒星...）

### 6.2 [jQMobile](./6.2_jQMobile.md)

### 6.3 [PhoneGap](./6.3_PhoneGap.md)

### 6.4 [fabric.js](https://github.com/fabricjs/fabric.js/)

### 6.6 WebGL

### 6.7 Bootstrap

github最值得收藏的Bootstrap3后台管理框架：

- [AdminLTE](https://github.com/almasaeed2010/AdminLTE)：查看[演示](https://adminlte.io/themes/AdminLTE/index2.html)
- [Gentelella Admin](https://github.com/puikinsh/gentelella)：查看[演示](https://colorlib.com/polygon/gentelella/index.html)
- [Vali Admin](https://github.com/pratikborsadiya/vali-admin)：查看[演示](http://pratikborsadiya.in/vali-admin/)
- [ModularAdmin](https://github.com/modularcode/modular-admin-html)：查看[演示](https://gurayyarar.github.io/AdminBSBMaterialDesign/index.html)
- [Metis](https://github.com/puikinsh/Bootstrap-Admin-Template)：查看[演示](https://colorlib.com/polygon/metis/)
- [Ace](https://github.com/bopoda/ace)：查看[演示](http://ace.jeka.by/)
- [Light Bootstrap Dashboard](https://github.com/creativetimofficial/light-bootstrap-dashboard)：查看[演示](http://demos.creative-tim.com/light-bootstrap-dashboard)
- [Material Dashboard](https://github.com/creativetimofficial/material-dashboard)：查看[演示](http://demos.creative-tim.com/material-dashboard/examples/dashboard.html)
- [Clearmin](https://github.com/paomedia/clearmin)：查看[演示](http://cm.paomedia.com/)

### 6.8 前端UI框架小汇总

[点此查看](https://www.cnblogs.com/aaron-pan/p/8018473.html)

## 总结

### VSCode插件

#### Prettier - Code formatter

**.prettierrc文件常见配置**

```json
{
  // tab缩进大小,默认为2
  "tabWidth": 4,
  // 使用tab缩进，默认false
  "useTabs": false,
  // 使用分号, 默认true
  "semi": false,
  // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)
  "singleQuote": false,
  // 行尾逗号,默认none,可选 none|es5|all
  // es5 包括es5中的数组、对象
  // all 包括函数对象等所有可选
  "TrailingCooma": "all",
  // 对象中的空格 默认true
  // true: { foo: bar }
  // false: {foo: bar}
  "bracketSpacing": true,
  // JSX标签闭合位置 默认false
  // false: <div
  //          className=""
  //          style={{}}
  //       >
  // true: <div
  //          className=""
  //          style={{}} >
  "jsxBracketSameLine": false,
  // 箭头函数参数括号 默认avoid 可选 avoid| always
  // avoid 能省略括号的时候就省略 例如x => x
  // always 总是有括号
  "arrowParens": "avoid"
}
```



***\*附录\****

 

***\*转义字符表\****

| ***\*转义字符\**** | ***\*含义\****                      |
| ------------------ | ----------------------------------- |
| \o                 | NUL字符(\u0000)                     |
| \b                 | 退格符(\u0008)                      |
| \t                 | 水平制表符(\u0009)                  |
| \n                 | 换行符(\u000A)                      |
| \v                 | 垂直制表符(\u000B)                  |
| \f                 | 换页符(\u000C)                      |
| \r                 | 回车符(\u000D)                      |
| \"                 | 双引号(\u0022)                      |
| \'                 | 撇号或单引号(\u0027)                |
| \\                 | 反斜线(\u005C)                      |
| \xXX               | 由两位16进制数XX指定的Latin-1字符   |
| \uXXXX             | 由四位16进制数XXXX指定的Unicode字符 |

 

***\*类型转换\****

| ***\*值\****                                                 | ***\*转换为字符串\****              | ***\*数字\**** | ***\*布尔值\****            | ***\*对象\****                                               |
| ------------------------------------------------------------ | ----------------------------------- | -------------- | --------------------------- | ------------------------------------------------------------ |
| undefinednull                                                | "undefined""null"                   | NaN0           | falsefalse                  | throws TypeErrorthrows TypeError                             |
| truefalse                                                    | "true""false"                       | 10             |                             | new Boolean(true)new Boolean(false)                          |
| ""（空字符串）"1.2"（非空，数字）"one"（非空，非数字）       |                                     | 01.2NaN        | falsetruetrue               | new String("")new String("1.2")new String("one")             |
| 0-0NaNInfinity-Infinity1（无穷大，非零）                     | "0""0""NaN""Infinity""-Infinity""1" |                | falsefalsefalsetruetruetrue | new Number(0)new Number(-0)new Number(NaN)new Number(Infinity)new Number(-Infinity)new Number(1) |
| {}（任意对象）[]（任意数组）[9]（1个数字元素）['a']（其它数组）function(){}（任意函数） | """9"使用join()方法                 |                | truetruetruetruetrue        |                                                              |

转换为数字的情形比较微妙。那些以数字表示的字符串可以直接转换为数字，也***\*允许在开始和结尾处带有空格\****。但在开始和结尾处的任意非空格字符都不会被当成数字直接量的一部分，进而造成字符串转换为数字的结果为NaN。有一些数字转换看起来让人奇怪：true转换为1，false、空字符串("")转换为0。

尽管JavaScript可以自动做许多类型转换，但有时仍需要做显式转换，或者***\*为了使代码变得清晰易读而做显式转换\****。

做显式类型转换最简单的方法就是使用Boolean()、Number()、String()或Object()函数。***\*当不通过new运算符调用这些函数时，它们会作为类型转换函数\****。

需要注意的是，除了null或undefined之外的任何值都具有toString()方法，这个方法的执行结果通常和String() 方法的返回结果一致。同样需要注意的是，如果试图将null或undefined转换为对象，则会抛出一个类型错误(TypeError)。Object()函数在这种情况下不会抛出异常：它仅简单地返回一个新创建的空对象。

JavaScript中的某些运算符会做隐式的类型转换。如果"+"运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元"+"运算符将其操作数转换为数字。同样，一元"!"运算符将其操作数转换为布尔值并取反。

Number类定义的toString()方法可以接收表示转换基数(radix)的可选参数，如果不指定此参数，转换规则将是基于十进制。同样，亦可以将数字转换为其他进制数（范围在2-36之间）。

var n = 17; 

binary_string = n.toString(2);     //转换为"10001"

octal_string = "0" + n.toString(8);   //转换为"021"

hex_string = "0x" + n.toString(16);   //转换为"0x11"

当处理财务或科学数据的时候，在做数字到字符串的转换过程中，你期望自己控制输出中小数点位置和有效数字位数，或者决定是否需要指数记数法。Number类为这种数字到字符串的类型转换场景定义了三个方法。toFixed()根据小数点后的指定位数将数字转换为字符串，它从不使用指数记数法。toExponential()使用指数记数法将数字转换为指数形式的字符串，其中小数点前只有一位，小数点后的位数则由参数指定（也就是说有效数字位数比指定的位数要多一位）， toPrecision()根据指定的有效数字位数将数字转换成字符串。如果有效数字的位数少于数字整数部分的位数，则转换成指数形式。我们注意到，所有三个方法都会适当地进行四舍五入或填充0 。看一下下面几个例子：

***\*var\**** n = 123456.789;

n.toFixed(0);     //"1234567"

n.toFixed(2);     //"123456.79"

n.toFixed(5);     //"123456.78900"

n.toExponential(1);  //"1.2e+5"

n.toExponential(3);  //"1.235e+5"

n.toPrecision(4);   //"1.235e+5"

n.toPrecision(7);   //"123456.8"

n.toPrecision(10);  //"123456.7890"

如果通过Number()转换函数传入一个字符串，它会试图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现非法的尾随字符。parseInt()函数和parseFloat()函数（它们是全局函数，不从属于任何类的方法）更加灵活。parseInt()只解析整数，而parseFloat()则可以解析整数和浮点数。如果字符串前缀是"0x"或者"0X"，parseInt()将其解释为十六进制数，parseInt()和parseFloat()都会***\*跳过任意数量的前导空格\****，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回NaN。

parseInt("3 blind mice")   // => 3

parseFloat(" 3.14 meters")  // => 3.14

parseInt("-12.34")      // => -12

parseInt("0xFF")       // => 255

parseInt("0xff")       // => 255

parseInt("-0XFF")      // => -255

parseFloat(".1")       // => 0.1

parseInt("0.1")       // => 0

parseInt(".1")        // => NaN: 整数不能以"."开始

parseFloat("$72.47");    // => NaN: 数字不能以"$"开始

parseInt()可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2-36。

parseInt("11", 2);   // => 3 (1*2 + 1)

parseInt ("ff", 16);  // => 255 (15*16 + 15)

parseInt("zz", 36);  // => 1295 (35*36 + 35)

parseInt("077", 8);  // => 63 (7*8 + 7)

parseInt("077", 10);  // => 77 (7*10 + 7)

对象到布尔值的转换非常简单：所有的对象（包括数组和函数）都转换为true。对于包装对象亦是如此：***\*new Boolean(false)\**** 是一个对象而不是原始值，它将转换为true。

对象到字符串(object-to-string)和对象到数字(object-to-number)的转换是通过调用待转换对象的一个方法来完成的。一个麻烦的事实是，JavaScript对象有两个不同的方法来执行转换，并且接下来要讨论的一些特殊场景更加复杂。值得注意的是，这里提到的字符串和数字的转换规则只适用于本地对象(native object)。宿主对象（例如，由Web浏览器定义的对象）根据各自的算法可以转换成字符串和数字。

所有的对象继承了两个转换方法。第一个是toString()，它的作用是返回一个反映这个对象的字符串。默认的toString()方法并不会返回一个有趣的值。

({X:1, y:2}).toString()       // =>"[object Object]"

[1,2,3].toString()         // =>"1, 2, 3"

(***\*function\****(x) { f(x); }).toString() // =>"function(x) {\n f(x);\n}"

/\d+/g.toString()          // =>"/\\d+/g"

new Date(2010,0,1).toString()    // =>"Fri Jan 01 2010 00:00:00 GMT-0800 (PST)"

另一个转换对象的函数是valueOf()。这个方法的任务并未详细定义：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valueOf()方法只是简单返回对象本身。***\*日期类定义的valueOf()方法会返回它的一个内部表示：1970年1 月1 日以来的毫秒数\****。

***\*var\**** d = new Date(2010, 0, 1); // 2010年1 月1 日（太平洋时间）

d.valueOf()          // => 1262332800000

通过使用我们刚刚讲解过的toString()和valueOf()方法，就可以做到对象到字符串和对象到数字的转换了。但需要注意的是，在某些特殊的场景中，JavaScript执行了完全不同的对象到原始值的转换。

JavaScript中***\*对象到字符串的转换\****经过了如下这些步骤：

l 如果对象具有toString()方法，则调用这个方法。如果它返回一个原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。

l 如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么JavaScript会调用valueOf()方法。如果存在这个方法，则JavaScript调用它。如果返回值是原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。

l 否则，JavaScript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常。

在***\*对象到数字的转换\****过程中，JavaScript做了同样的事情，只是它会首先尝试使用valueOf()方法：

l 如果对象具有valueOf()方法，后者返回一个原始值，则JavaScript将这个原始值转换为数字（如果需要的话）并返回这个数字。

l 否则，如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回

l 否则，JavaScript抛出一个类型错误异常。

对象转换为数字的细节解释了为什么空数组会被转换为数字，以及为什么具有单个元素的数组同样会转换成一个数字。数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString()方法。空数组转换成为空字符串，空字符串转换成为数字0。含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样。如果数组只包含一个数字元素，这个数字转换为字符串，再转换回数字。

***\*var\**** now = new Date();  // 创建一个日期对象

typeof (now + 1)    // => "string": "+"将日期转换为字符串

typeof (now - 1)    // => "number": "-"使用对象到数字的转换

now == now.toString()  // => true: 隐式的和显式的字符串转换

now > (now -1)     // => true: ">"将日期转换为数字

示例：

null、0、NaN和空字符串转化成false，其他所有的值都会转化成true。

===精确相等（值和类型），!==不精确相等

'5' * 5 = 25

null + 's' = 'nulls'

's' * 5 = NaN

 

 

***\*总结\****

\1. 在ECMAScript3中，字符串直接量必须写在一行中，而在ECMAScript5中，字符串直接量可以拆分成数行，每行以 ***\*\*\*** 结束，反斜线和行结束符都不算是字符串直接量的内容。如果希望在字符串直接量中另起一行，可以使用转义字符\n。

\2. 在JavaScript中，字符串是固定不变的，可以看成是只读数组。通过调用API返回的字符串一般都是一个新字符串。

\3. 任意JavaScript的值都可以转换为布尔值：undefined、null、0、-0、NaN、"" 会被转换为false，所有其他值，包括所有对象（数组）都会转换成true。

\4. null和undefined

null是JavaScript语言的关键字，它表示一个特殊值，常用来描述“***\*空值\****”。对null执行typeof预算，结果返回字符串"object" ，也就是说，可以将null认为是一个特殊的对象值，含义是“***\*非对象\****”。但实际上，通常认为null是它自有类型的唯一一个成员，它可以表示数字、字符串和对象是“无值”的。

JavaScript还有第二个值来表示值的空缺。用未定义的值表示更深层次的“空值”。它是变量的一种取值，表明变量***\*没有初始化\****，如果要查询对象属性或数组元素的值时返回undefined则说明这个属性或元素不存在。如果函数没有返回任何值，则返回undefined。引用没有提供实参的函数形参的值也只会得到undefined。undefined是预定义的全局变量（它和null不一样，它不是关键字），它的值就是“***\*未定义\****”。

尽管null和undefined是不同的，但它们都表示“***\*值的空缺\****”，两者往往可以互换。判断相等运算符"=="认为两者是相等的（要使用严格相等运算符"==="来区分它们）。在希望值是布尔类型的地方它们的值都是***\*假\****值，和false 类似。null和undefined都不包含任何属性和方法。实际上，使用"."和"[]"来存取这两个值的成员或方法都会产生一个类型错误。

\5. 全局对象

global object在JavaScript中有着重要的用途：全局对象的属性是全局定义的符号，JavaScript程序可以***\*直接使用\****。当JavaScript解释器启动时（或者任何Web浏览器加载新页面的时候），它将创建一个新的全局对象，并给它一组定义的初始属性：

l 全局属性，比如undefined、Infinity和NaN

l 全局函数，比如isNaN()、parseInt()、eval()

l 构造函数，比如Date()、RegExp()、String()、Object()、Array()

l 全局对象，比如Math和JSON

全局对象的初始属性并不是保留字，但它们应该当做保留字来对待。

在代码的最顶级一一不在任何函数内的JavaScript代码一一可以使用JavaScript关键字this来引用全局对象：

var global = this; // 定义一个引用全局对象的全局变量

在客户端JavaScript中，在其表示的浏览器窗口中的所有JavaScript代码中，Window对象充当了全局对象。这个全局Window对象有一个属性window引用其自身，它可以代替this来引用全局对象。Window对象定义了核心全局属性，但它也针对Web浏览器和客户端JavaScript定义了一少部分其他全局属性。

当初次创建的时候，全局对象定义了JavaScript中所有的预定义全局值。这个特殊对象同样包含了为程序定义的全局值。如果代码声明了一个全局变量，这个全局变量就是全局对象的一个属性。JavaScript全局变量是全局对象的属性，这是在ECMAScript规范中强制规定的。

当使用var声明一个变量时，创建的这个属性是***\*不可配置\****的，也就是说这个变量无法通过delete运算符删除。可能你已经注意到了，如果你没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们。

**6.** ***\*★\**** 包装对象

字符串既然不是对象，为什么它会有属性呢？只要引用了字符串的属性，JavaScript就会将字符串值通过调用new 5tring(s)的方式转换成对象，这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁(其实在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样)。

同字符串一样，数字和布尔值也具有各自的方提:通过Number()和Boolean()构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。null和undefined没有包装对象：访问它们的属性会造成一个类型错误。

var s = "test"; //创建一个字符串

s.len = 4;    //给它设置一个属性

var t = s.len;  //查询这个属性

当运行这段代码时，t的值是undefined。第二行代码创建一个临时字符串对象，并给其len属性赋值为4 ，随即销毁这个对象。第三行通过原始的（没有被修改过）字符串值创建一个新字符串对象，尝试读取其len属性，这个属性自然不存在，表达式求值结果为undefined。这段代码说明了在读取字符串、数字和布尔值的属性值（或方法）的时候，表现的像对象一样。但如果你试图给其属性赋值，则会***\*忽略\****这个操作：修改只是发生在临时对象身上，而这个临时对象并未继续保留下来。

存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。通常，包装对象只是被看做是一种实现细节，而不用特别关注。由于字符串、数字和布尔值的属性都是只读的，并且不能给它们定义新属性，因此你需要明白它们是有别于对象的。

需要注意的是，可通过String()，Number()或Boolean()构造函数来显式创建包装对象。

"=="等于运算符将原始值和其包装对象视为相等，但"==="全等运算符将它们视为不等。通过typeof运算符可以看到原始值和其包装对象的不同。

\7. 原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）

原始值不可更改：数字和布尔值显然如此，字符串就不那么明显了。

因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来修改字符串中的字符。实际上，JavaScript禁止这样做。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串。

原始值的比较是值的比较。对象和原始值不同，首先，它们是可变的一一它们的值是可修改的。对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，它们也可能是不相等的。

我们通常将对象称为***\*引用类型\****(reference type)，以此来和JavaScript的基本类型区分。依照术语的叫法，对象值都是引用(reference)，对象的比较均是引用的比较：当且仅当它们引用同一个对象时，它们才相等。

将对象（或数组）赋值给一个变量，仅仅是赋值的引用值：对象本身并没有复制一次。如果你想得到一个对象或数组的副本，则必须显式复制对象的每个属性或数组的每个元素。同样的，如果我们想比较两个单独的对象或者数组，则必须比较它们的属性或元素。

**8.** ***\*★\**** 变量作用域

***\*在函数体内，局部变量的优先级高于同名的全局变量\****。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。

在全局作用域编写代码时可以不写var语句，但声明局部变量时则必须使用var语句。

scope ***\*=\**** "global"***\*;\**** //声明一个全局变量，甚至不用var来声明***\*function\**** checkscope2***\*()\**** ***\*{\**** scope ***\*=\**** "local"***\*;\**** //糟糕！我们刚修改了全局变量	myscope ***\*=\**** "local"***\*;\**** //这里显式地声明了一个新的全局变量	***\*return\**** ***\*[\****scope***\*,\**** myscope***\*];\****//返回两个值***\*}\****	checkscope2***\*()\**** // => ["local" , "local"]: 产生了副作用scope // => "local": 全局变量修改了myscope // => "local": 全局命名空间搞乱了

***\*声明提前\****

JavaScript中没有块级作用域，取而代之地使用了函数作用域(function scope)：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

***\*function\**** test***\*(\****o***\*)\**** ***\*{\**** ***\*var\**** i ***\*=\**** 0***\*;\**** // i 在整个函数体内均是有定义的	***\*if\**** ***\*(\*******\*typeof\**** o ***\*==\**** "object"***\*)\**** ***\*{\**** 	***\*var\**** j ***\*=\**** 0***\*;\**** // j在函数体内是有定义的，不仅仅是在这个代码段内		***\*for\*******\*(\*******\*var\**** k***\*=\****0***\*;\**** k***\*<\****10***\*;\**** k***\*++)\**** ***\*{\**** // k在函数体内是有定义的，不仅仅是在循环内			console***\*.\****log***\*(\****k***\*);\**** //输出数字0-9		***\*}\**** 	console***\*.\****log***\*(\****k***\*);\**** // k已经定义了，输出10	***\*}\**** console***\*.\****log***\*(\****j***\*);\**** // j已经定义了，但可能没有初始化***\*}\****

JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。JavaScript的这个特性被非正式地称为***\*声明提前\****(hoisting)，即***\*JavaScript函数里声明的所有变量\*******\*（\*******\*但不涉及赋值\*******\*）\*******\*都被\*******\*“\*******\*提前\*******\*”\*******\*至函数体的顶部\****。

“声明提前”这步操作是在JavaScript引擎的“预编译”时进行的，在代码开始运行之前。

***\*var\**** scope ***\*=\**** "global"***\*;\*******\*function\**** f***\*()\**** ***\*{\**** console***\*.\****log***\*(\****scope***\*);\**** //输出"undefined"，而不是"global"	***\*var\**** scope ***\*=\**** "local"***\*;\**** //变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的	console***\*.\****log***\*(\****scope***\*);\**** //输出"local"***\*}\****

当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性。当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过delete运算符删除。可能你已经注意到了，如果你没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们:

***\*var\**** truevar = 1;    // 声明一个不可删除的全局变量

fakevar = 2;      // 创建全局对象的一个可删除的属性

***\*this\****.fakevar2 = 3;   // 同上

***\*delete\**** truevar     // => false: 变量并没有被删除

***\*delete\**** fakevar     // => true: 变量被删除

***\*delete\**** ***\*this\****.fakevar2  // => true: 变量被删除

***\*作用域链\****

每一段JavaScript代码（全局代码或函数）都有一个与之关联的***\*作用域链\****(scope chain)。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值的时候（这个过程称做“变量解析”(variable resolution)），它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性X，那么就认为这段代码的作用域链上不存在X，并最终抛出一个引用错误(ReferenceError)异常。

在JavaScript的最顶层代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解作用域链的创建规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，事情更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别（在每次调用外部函数时，内部函数的代码都是相同的），而关联这段代码的作用域链也不相同。

作用域链的概念对于理解with语句是非常有帮助的，同样对理解闭包的概念也至关重要。

\9. 表达式和运算符

表达式(expression)是JavaScript中的一个短语，JavaScript解释器会将其计算(evaluate)出一个结果。将简单表达式组合成复杂表达式最常用的方法就是使用运算符(operator)。

***\*原始表达式\****

原始表达式是表达式的最小单位一一它们不再包含其他表达式。

l 直接量：1.23  "hello"  /pattern/

l 保留字：true  false  null  this

l 变量：i  sum  undefined

***\*对象和数组的初始化表达式\****

对象和数组初始化表达式实际上是一个新创建的对象和数组。这些初始化表达式有时称做“对象直接量”和“数组直接量”。

l [] //一个空数组：[]内留空即表示该数组没有任何元素

l [1+2,3+4] //拥有两个元素的数组，第一个是3，第二个是7

l var matrix = [[1,2,3],[4,5,6],[7,8,9]]; // 数组初始化表达式中的元素初始化表达式也可以是数组初始化表达式。也就是说，这些表达式是可以嵌套的

l var sparseArray = [1,,,,5]; //数组直接量中的列表逗号之间的元素可以省略，这时省略的空位会填充值undefined。数组直接量的元素列表结尾处可以留下单个逗号，这时并不会创建一个新的值为undefined的元素。

l var p = { x:2.3, y:-1.2 }; //一个拥有两个属性成员的对象

l var q = {}; //一个空对象

l q.x = 2.3; q.y = -1.2; //q的属性成员和p的一样

l var rectangle = { upperLeft: { x: 2, y: 2 }, lowerRight: { x: 4, y: 5 } }; //对象直接量也可以嵌套

l var side = 1; 

var square = { "upperLeft": { x: p.x, y: p.y }, 'lowerRight': { x: p.x + side, y: p.y + side}};

对象直接量中的属性名称可以是字符串而不是标识符（这在那些只能使用保留字或一些非捷标识符作为属性名的地方非常有用）。

### ***\*函数定义表达式\****

函数定义表达式定义一个JavaScript函数。表达式的值是这个新定义的函数。从某种意义上讲，函数定义表达式可称为“函数直接量”，毕竟对象初始化表达式也称为“对象直接量”。一个典型的函数定义表达式包含关键字function，跟随其后的是一对圆括号，括号内是一个以逗号分割的列表，列表含有0个或多个标识符(参数名)，然后再跟随一个由花括号包裹的JavaScript代码段(函数体)，例如：

//这个函数返回传入参数值的平方

***\*var\**** square = ***\*function\****(x) { ***\*return\**** x * x; }

函数定义表达式同样可以包含函数的名字。函数也可以通过函数语句来定义，而不是函数表达式。

### ***\*属性访问表达式\****

属性访问表达式运算得到一个对象属性或一个数组元素的值。JavaScript为属性访问定义了两种语法：

expression.identifier

expression[expression]

第二种写法更灵活，可以针对属性名称是关键字或者不确定属性名称的情况。

### ***\*调用表达式\****

JavaScript 中的调用表达式(invocation expression)是一种调用(或者执行)函数或方法的语法表示。

l f(o) //f是一个函数表达式，o是一个参数表达式

l Math.max(x,y,z) // Math.max 是一个函数; x, y 和z 是参数

l a.sort() // a.sort是一个函数，它没有参数

任何一个调用表达式都包含一对圆括号和左圆括号之前的表达式。如果这个表达式是一个属性访问表达式，那么这个调用称做"方法调用" (method invocation) 。在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this 的指向。这种特性使得在面向对象编程范例中，函数(其OO名称为"方法" )可以调用其宿主对象。

并不是方法调用的调用表达式通常使用全局对象作为this 关键字的值。然而在ECMAScript 5中，那些通过严格模式定义的函数在调用时将使用undefined作为this 的值， this不会指向全局对象。

### ***\*对象创建表达式\****

对象创建表达式(object creation expression) 创建一个对象并调用一个函数(这个函数称做构造函数)初始化新对象的属性。对象创建表达式和函数调用表达式非常类似，只是对象创建表达式之前多了一个关键字new。

l new Object()

l new Point(2 ,3)

l new Object //如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么空圆括号是可以省略掉的。

l new Date 

当计算一个对象创建表达式的值时，和对象初始化表达式通过{}创建对象的做法一样，JavaScript首先创建一个新的空对象，然后，JavaScript通过传入指定的参数并将这个新对象当做this 的值来调用一个指定的函数。这个函数可以使用this来初始化这个新创建对象的属性。那些被当成构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果一个构造函数确实返回了一个***\*对象\****值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了。

### ***\*运算符概述\****

下表是按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级。被水平分割线分隔开来的运算符具有不同的优先级。标题为A的列表示运算符的结合性，L(从左至右)或R( 从右至左)，标题为N的列表示操作数的个数。标题为"类型"的列表示期望的操作数类型，以及运算符的结果类型(在"->"符号之后)。lval是left-value的简写，意思是"左值"。

| ***\*运算符\****                                 | ***\*操作\****                                               | ***\*A\**** | ***\*N\**** | ***\*类型\****                                               |
| ------------------------------------------------ | ------------------------------------------------------------ | ----------- | ----------- | ------------------------------------------------------------ |
| ++---+~!deletetypeofvoid                         | 前/后增量前/后减量求反转换为数字按位求反逻辑非检测操作数类型返回undefined值 | RRRRRRRRR   | 111111111   | lval-> numlval -> numnum -> numnum -> numint -> intbool -> boollval -> boolany -> strany -> undef |
| *、/、%                                          | 乘、除、求余                                                 | L           | 2           | num, num -> num                                              |
| +、-+                                            | 加、减字符串连接                                             | LL          | 22          | num, num -> numstr, str -> str                               |
| <<>>>>>                                          | 左移位有符号右移无符号右移                                   | LLL         | 222         | int, int -> intint, int -> intint, int -> int                |
| <、<=、>、>=<、<=、>、>=instanceofin             | 比较数字顺序比较在字母表中的顺序测试对象类测试属性是否存在   | LLLL        | 2222        | num, num -> boolstr, str -> boolobj, func -> boolstr, obj -> bool |
| ==!====!==                                       | 判断相等判断不等判断恒等判断非恒等                           | LLLL        | 2222        | any, any -> boolany, any -> boolany, any -> boolany, any -> bool |
| &                                                | 按位与                                                       | L           | 2           | int, int -> int                                              |
| ^                                                | 按位异或                                                     | L           | 2           | int, int -> int                                              |
| \|                                               | 按位或                                                       | L           | 2           | int, int -> int                                              |
| &&                                               | 逻辑与                                                       | L           | 2           | any, any -> any                                              |
| \|\|                                             | 逻辑或                                                       | L           | 2           | any, any -> any                                              |
| ?:                                               | 条件运算符                                                   | R           | 3           | bool, any, any -> any                                        |
| =*=、/=、%=、+=、-=、&=、^=、\|=、<<=、>>=、>>>= | 变量赋值或对象属性赋值运算且赋值                             | RR          | 22          | lval, any -> anylval, any -> any                             |
| ,                                                | 忽略第一个操作数，返回第二个操作数                           | L           | 2           | any, any -> any                                              |

左值(lvalue)是一个古老的术语，它是指"表达式只能出现在赋值运算符的左侧"。在JavaScript中，变量、对象属性和数组元素均是左值。ECMAScript规范允许内置函数返回一个左值，但自定义的函数则不能返回左值。

计算一个简单的表达式(比如2*3)不会对程序的运行状态造成任何影响，程序后续执行的计算也不会受到该计算的影响。而有一些表达式则具有很多副作用，前后的表达式运算会相互影响。赋值运算符是最明显的一个例子:如果给一个变量或属性赋值，那么那些使用这个变量或属性的表达式的值都会发生改变。"++"和"--"递增和递减运算符与此类似，因为它们包含隐式的赋值。delete运算符同样有副作用:删除一个属性就像(但不完全一样)给这个属性赋值undefined。

其他的JavaScript运算符都没有副作用，但函数调用表达式和对象创建表达式有些特别，在函数体或者构造函数内部运用了这些运算符并产生了副作用的时候，我们说函数调用表达式和对象创建表达式是有副作用的。

运算符的优先级可以通过显式使用圆括号来重写。需要注意的是，属性访问表达式和调用表达式的优先级要比表中列出的所有运算符都要高。实际上，如果你真的不确定你所使用的运算符的优先级，最简单的方法就是使用圆括号来强行指定运算次序。

***\*var\**** a = 1;      // 1

***\*var\**** b = (a++) + a;  // 3

### ***\*算术表达式\****

***\*+运算符\****

偏爱字符串

Ø 1 + 2 // 3 加法

Ø "hello" + " " + "angel" // "hello angel" 字符串连接

Ø "1" + "2" // "12" 

Ø "1" + 2 // "12" 数字转换为字符串后进行字符串连接

Ø 1 + {} // "1[object Object]" 对象转换为字符串后进行字符串连接

Ø true + true // 2 布尔值转换为数字后做加法

Ø 2 + null // 2  null转换为0后做加法

Ø 2 + undefined // NaN  undefined转换为NaN后做加法

Ø 1 + 2 + " blind mice"; // => "3 blind mice" 运算顺序的影响

Ø 1 + (2 + " blind mice"); // => "12 blind mice"

***\*一元算术运算符\****

一元运算符作用于一个单独的操作数，并产生一个新值。在JavaScript中，一元运算符具有很高的优先级，而且都是右结合(right-associative)。

l +：一元加法运算符把操作数转换为数字(或者NaN)，并返回这个转换后的数字

l -：当"-"用做一元运算符时，它会根据需要把操作数转换为数字，然后改变运算结果的符号。

l ++：var i = 1, j = ++i // i和j的值都是2

var i = 1, j = i++ // i是2，j是1

l --：如上，有前置和后置之分

***\*位运算符\****

位运算符可以对由数字表示的二进制数据进行更低层级的按位运算。位运算符要求它的操作数是整数，这些整数表示为32位整型而不是64位浮点型。必要时，位运算符首先将操作数转换为数字，并将数字强制表示为32位整型，这会忽略原格式中的小数部分和任何超过32位的二进制位。

移位运算符要求右操作数在0-31之间。在将其操作数转换为无符号32位整数后，它们将舍弃第5位之后的二进制位，以便生成一个位数正确的数字。需要注意的是，位运算符会将NaN、Infinity和-Infinity都转换为0。

l &：对它的整型操作数逐位执行布尔与(AND)操作

l |：对它的整型操作数逐位执行布尔或(OR)操作

l ^：对它的整型操作数逐位执行布尔异或(XOR)操作

l ~：一元运算符，位于一个整型参数之前，它将操作数的所有位取反。根据JavaScript中带符号的整数的表示方法，对一个值使用"~"运算符相当于改变它的符号并减1

l <<：将第一个操作数的所有二进制位进行左移操作，移动的位数由第二个操作数指定，移动的位数是0-31之间的一个整数，将一个值左移1位相当于它乘以2，左移两位相当于乘以4，以此类推。

l >>：将第一个操作数的所有位进行右移操作，移动的位数由第二个操作数指定，移动的位数是0-31之间的一个整数。右边溢出的位将忽略。填补在左边的位由原操作数的符号决定，以便保持结果的符号与原操作数一致。如果第一个操作数是正数，移位后用0填补最高位，如果第一个操作数是负的，移位后就用1填补高位。将一个值右移1 位，相当于用它除以2，右移两位，相当于它除以4，以此类推

l >>>：和运算符">>"一样，只是左边的高位总是填补0，与原来的操作数符号无关

### ***\*关系表达式\****

***\*相等和不等运算符\****

l =：赋值

l ==：相等，自动类型转换，JS对象比较的是引用（栈），不是具体对象（堆）

u 如果一个值是null，另一个是undefined，则它们相等。

u 如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较。

u 如果其中一个值是true，则将其转换为1再进行比较。如果其中一个值是false ，则将其转换为0再进行比较。

u 如果一个值是对象，另一个值是数字或字符串，则使用转换规则将对象转换为原始值，然后再进行比较。对象通过toString()方法或者valueOf()方法转换为原始值。JavaScript语言核心的内置类首先尝试使用valueOf()，再尝试使用toString()，除了日期类，日期类只使用toString()转换。那些不是JavaScript语言核心中的对象则通过各自的实现中定义的方法转换为原始值。

u 其他不同类型之间的比较均不相等。

l !=

l ===：严格相等，不转换类型

u 如果两个值类型不相同，则它们不相等。

u 如果两个值都是null或者都是undefined，则它们不相等。

u 如果其中一个值是NaN，或者两个值都是NaN，则它们不相等。NaN和其他任何值都是不相等的，包括它本身!通过x!==x来判断x是否为NaN，只有在x为NaN的时候，这个表达式的值才为true。

u 两个字符串可能含义完全一样且所显示出的字符也一样，但具有不同编码的16位值。JavaScript并不对Unicode进行标准化的转换，因此像这样的字符串通过"=="和"==="运算符的比较结果也不相等。

l !==

***\*比较运算符\****

<, >, <=, >=

偏爱数字

比较操作符的操作数可能是任意类型。然而，只有数字和字符串才能真正执行比较操作，因此那些不是数字和字符串的操作数都将进行类型转换，类型转换规则：

l 如果是object，转换成原始值：1)valueOf() 2)toString()

l 如果能转成字符串，两个字符串按照16位Unicode字符的索引顺序进行比较

l 如果不能转成字符串，就转成数字，Infitity最大，-Infinity最小，其中一个是NaN，总返回false

String.localCompare()更健壮，参照本地语言字母表字符顺序。

***\*in\*******\*运算符\****

in运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回true

***\*instanceof\*******\*运算符\****

instanceof运算符希望左操作数是一个对象，右操作数标识对象的类。

如果左侧的对象是右侧类的实例，则表达式返回true，否则返回false 。

如果instanceof的左操作数不是对象的话， instanceof返回false 。

JS中对象的类是通过初始化它们的构造函数来定义，因此右操作数应该是一个函数。如果右操作数不是函数，则抛出一个类型错误异常。

***\*逻辑\*******\*表达式\****

&&、||、!

&&示例：a&&b，a为“假值”，返回a，否则返回b。短路特性，a为真，b执行；否则b不执行

||示例：a||b，a为“真值”，返回a，否则返回b。短路特性，a为假，b执行；否则b不执行

！运算符总是返回true、false；!!a返回a的等价bool值

 

***\*赋值\*******\*表达式\****

示例：(a = b) == 0

"="具有非常低的优先级，用括号改变优先级。

赋值操作符的结合性是从右至左，也就是说，如果一个表达式中出现了多个赋值运算符，运算顺序是从右到左。

运算符"+="执行的是加法运算和赋值操作。

在大多数情况下，表达式为: a op= b

这里op代表一个运算符，这个表达式和下面的表达式等价：a=a op b

a op= b，表达式a计算了一次，a=a op b，表达式a计算了两次。只有在a包含具有***\*副作用\****的表达式(比如函数调用和赋值操作)的时候，两者才不等价。比如，下面两个表达式就不等价：

data[i++] *= 2;

data[i++] = data[i++] * 2;

***\*表达式\*******\*计算\****

***\*eval()\****

eval()只有一个参数。

如果传入的参数不是字符串，它直接返回这个参数。

如果参数是字符串，它会把字符串当成JavaScript代码进行编译。

如果编译失败则抛出一个语法错误（SyntaxError）异常。

如果编译成功，则开始执行这段代码，并返回字符串中的最后一个表达式或语句的值。

如果最后一个表达式或语句没有值，则最终返回undefined。

如果字符串抛出一个异常，这个异常将把该调用传递给eval()。

eval()使用了调用它的变量作用域环境。

***\*var\**** geval = eval;         //使用别名调用eval将是全局eval

***\*var\**** x = "global", y = "global";  //两个全局变量

***\*function\**** f() {           //函数内执行的是局部eval

  ***\*var\**** x = "local";        //定义局部变量

  eval("x += ' changed';");    //直接eval更改了局部变量的值

  ***\*return\**** x;           //返回更改后的局部变量

}

***\*function\**** g() {           //这个函数内执行了全局eval

  ***\*var\**** y = "local";        //定义局部变量

  geval("y += ' changed';");   //间接调用改变了全局变量的值

  ***\*return\**** y;           //返回未更改的局部变量

}

console.log(f() , x);       //更改了局部变量:输出"local changed global"

console.log(g() , y);       //更改了全局变量:输出"local global changed"

delete是一元操作符，它用来删除对象属性或者数组元素。就像赋值、递增、递减运算符一样，delete也是具有副作用的，它是用来做删除操作的，不是用来返回一个值的。

***\*var\**** o = { x:1, y:2 }; // 定义一个对象

***\*delete\**** o.x;      // 删除一个属性

"x" ***\*in\**** o        // =>false：这个属性在对象中不再存在

 

***\*var\**** a = [1,2,3];    // 定义一个数组

***\*delete\**** a[2];      // 删除最后一个数组元素

a ***\*in\**** a;        // =>false：元素2在数组中已经不存在

a.length        // =>3：注意，数组长度并没有改变，尽管上一行代码删除了这个元素，

​            // 但删除操作留下了一个“洞”，实际上并没有修改数组的长度

***\*其他运算符\****

***\*?:\****

三元运算符，从右向左执行

***\*typeof\****

typeof是一元运算符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。

l undefined        "undefined"

l null           "object"

l true或false      "boolean"

l 任意数字或NaN      "number"

l 任意字符串        "string"

l 任意函数         "function"

l 任意内置对象(非函数)   "object"

l 任意宿主对象由编译器各自实现的字符串，但不是"undefined"，"boolean" 、"number" 或"string"

 

***\*delete\****

delete希望他的操作数是一个左值

如果它不是左值，那么delete将不进行任何操作同时返回true。

否则，delete将试图删除这个指定的左值。

如果删除成功，delete将返回true。

然而并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，用户通过var语句声明的变量不能删除。同样，通过function语句定义的函数和函数参数也不能删除。

***\*var\**** o = {x:1, y:2}; //定义一个变量，初始化为对象

***\*delete\**** o.x;     //删除一个对象属性，返回true

typeof o.x;     //属性不存在，返回"undefined"

***\*delete\**** o.x;     //删除不存在的属性，返回true

***\*delete\**** o;      //不能删除通过var声明的变量，返回false

​           //在严格模式下，将抛出一个异常

***\*delete\**** 1;      //参数不是一个左值，返回true

***\*this\****.x = 1;     //给全局对象定义一个属性，这里没有使用var

***\*delete\**** x;      //试图删除它，在非严格模式下返回true

​           //在严格模式下会抛出异常，这时使用"delete this.x" 来代替

x;          //运行时错误，没有定义x

***\*void\****

一元运算符，它出现在操作数之前，操作数可以是任意类型。

操作数会照常计算，但忽略计算结果并返回undefined。

这个运算符最常用在客户端的javascript: URL 中，在URL中可以写带有副作用的表达式，而void则让浏览器不必显示这个表达式的计算结果。

<a href="javascript:void window.open()">打开一个新窗口</a>

***\*,\****

逗号运算符是二元运算符，它的操作数可以是任意类型。

它首先计算左操作数，然后计算右操作数，最后返回右操作数的值。

***\*语句\****

 

### ***\*表达式\*******\*语句\****

具有副作用的表达式是JavaScript 中最简单的语句。

### ***\*复合语句\****

示例：（注意没有块级作用域）

***\*{\****

 x***\*=\****Math***\*.\****PI***\*;\****

 cx***\*=\****Math***\*.\****cos***\*(\****x***\*);\****

***\*}\**** ***\*//不需要分号结尾\****

### ***\*空语句\****

;

### ***\*声明语句\****

var用来声明变量，function用来声明函数

delete无法删除

var：声明提前，赋值不提前

function：函数声明和函数体（包括内部嵌套函数）都提前

### ***\*条件\*******\*语句\****

if (condition1) {

​	…

} else if (condition2) {

​		…

} else {

​	…

}

 

switch(expression) {

​	case value1: 

​		…

​		break;//switch确定了起点，没有确定终点，没有break，程序会逐条执行下去

​	case value2:

​		…

​		break

​	default:

​		…

}

### ***\*循环\*******\*语句\****

while

do … while 必定执行一次

for

for/in 遍历（对象可枚举属性，数组索引）

### ***\*跳转\****

不能越过函数边界

identifier: statement

continue (identifier)

break (identifier)

return (expression)

throw (expression)

try/catch/finally：

​	先执行try

​	 有异常

​	  catch，执行catch

​    没有catch

   没异常

​	然后执行finally

   有异常

​    向上抛出，try被覆盖

​	 没异常

​		有返回

​     返回finally，try被覆盖（即使异常也会被覆盖）

​		没返回

​		 返回try

### ***\*其它\*******\*语句\****

***\*with\****

with语句用于临时扩展作用域链，它具有如下的语法：

with (object)

statement

这条语句将object添加到作用域链的头部，然后执行statement，最后把作用域链恢复到原始状态。

***\*with\****(document.forms[o]) {

  // 直接访问表单元素，例如:

  name.value = "";

  address.value = "";

  email. value = "";

}

在严格模式中禁止使用with语句，尽可能避免使用with语句。

只有在查找标识符的时候才会用到作用域链，创建新的变量的时候不使用它，看一下下面这行代码：

with(o) x = 1;

如果对象o有一个属性x，那么这行代码给这个属性赋值为1。但如果o中没有定义属性x，这段代码和不使用with语句的代码x=1是一模一样的。它给一个局部变量或者全局变量x赋值，或者创建全局对象的一个新属性。with语句提供了一种读取o的属性的快捷方式，但它并不能创建o的属性。

***\*debugger\****

debugger语句通常什么也不做。然而，当调试程序可用并运行的时候，JavaScript解释器将会(非必需)以调式模式运行。实际上，这条语句用来产生一个断点(breakpoint),JavaScript代码的执行会停止在断点的位置，这时可以使用调试器输出变量的值、检查调用栈等。

***\*use strict\****

"use strict" 是ECMAScript 5 引人的一条指令。指令不是语句(但非常接近于语句)。"use strict" 指令和普通的语句之间有两个重要的区别：

l 它不包含任何语言的关键字，指令仅仅是一个包含一个特殊字符串直接量的表达式(可以是使用单引号也可以使用双引号)，对于那些没有实现ECMAScript 5的JavaScript解释器来说，它只是一条没有副作用的表达式语句，它什么也没做。将来的ECMAScript标准希望将use用做关键字，这样就可以省略引号了。

l 它只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。但它不必一定出现在脚本的首行或函数体内的首行，因为"use strict"指令之后或之前都可能有其他字符串直接量表达式语句，并且JavaScript的具体实现可能将它们解析为解释器自有的指令。在脚本或者函数体内第一条常规语句之后字符串直接量表达式语句只当做普通的表达式语句对待；它们不会当做指令解析，它们也没有任何副作用。

使用"use strict"指令的目的是说明(脚本或函数中)后续的代码将会解析为严格代码(strict code)。

严格代码以严格模式执行。ECMAScript 5中的严格模式是该语言的一个受限制的子集，它修正了语言的重要缺陷，并提供健壮的查错功能和增强的安全机制。严格模式和非严格模式之间的区别如下：

l with禁用

l 使用变量前必须声明

l 调用的函数中的this值是undefined（非严格模式下，是全局对象）。利用这个特性判断是否支持严格模式

***\*var\**** hasStrictMode ***\*=\**** ***\*(\*******\*function\*******\*(){\****

​	"use strict"***\*;\****

​	***\*return\**** ***\*this\*******\*===\****undefined***\*;\****

***\*}());\****

l 给只读属性赋值和给不可扩展的对象创建新成员会报错

l 传入eval()的代码不能在程序所在上下文声明变量或定义函数；因为变量和函数的定义在eval()创建的新作用域中，这个作用域在eval返回时弃用

l arguments对象拥有传入函数值的静态副本（非严格下，arguments里的数组元素和函数参数都是指向同一个值的引用）

l delete跟随非法标识符，会抛异常

l 试图删除不可配置属性会抛异常（非严格下，操作失败，返回false）

l 在对象直接量中，定义多个同名属性将产生语法错误

l 不允许使用8进制整数直接量

l eval、arguments是关键字，不能更改，不能赋值，不能声明为变量，不能用作函数名，不能用做函数参数，不能做catch块的标识符

l 限制了对调用栈的检测能力，arguments.caller和arguments.callee会抛类型错误





## 参考

- [MDN](https://developer.mozilla.org/zh-CN/)
- [CocoaUI](http://www.cocoaui.com/) - 一个强大的 iOS UI 框架
- [梦想天空](https://www.cnblogs.com/lhb25/)