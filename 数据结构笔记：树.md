# 目录

1. 树的实现
2. 树的遍历
3. [二叉树](#二叉树)
4. 查找树
5. AVL树
6. 伸展树
7. B树

树(Tree)是n(n>=0) 个结点的有限集。n=0 时称为空树。在任意一棵非空树中：

1. 有且仅有一个特定的称为根(Root)的结点；
2. 当 n > 1 时，其余结点可分为 m (m>0) 个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。

树由N 个结点和 N-1 条边组成（why？）

- **度**：结点拥有的子树数称为结点的度(Degree)。度为0 的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。
- **双亲/孩子/兄弟**：同一个双亲的孩子之间互称兄弟(Sibling)。结点的 **祖先** 是从根到该结点所经分支上的所有结点。以某结点为根的子树中的任一结点都称为该结点的 **子孙（后裔）**。
- **层次**：从根开始定义起，根为第一层，根的孩子为第二层，依次类推！双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的 **深度(Depth)** 或 **高度**。
- **有序/无序**：如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。
- **森林**：m(m>=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林

## 树的实现

3种方法：

1. 双亲表示法
2. 孩子表示法
3. 孩子兄弟表示法

### 双亲表示法

### 孩子兄弟表示法

```C
typedef struct TreeNode *PtrToNode;
struct TreeNode
{
  ElementType Element;
  PtrToNode FirstChild;
  PtrToNode NextSibling;
}
```

```java
class TreeNode {
  Object Element;
  TreeNode FirstChild;
  TreeNode NextSibling;
}
```

## 树的遍历

4种方式：

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层序遍历

## 二叉树

二叉树最多有两个节点。

二叉树一个节点左子节点的值小于这个节点，右子节点的值大于或等于这个节点。

参考：[https://blog.csdn.net/cai2016/article/details/52589952](#https://blog.csdn.net/cai2016/article/details/52589952)

### 完全二叉树

叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。

### 平衡二叉树(AVL)

左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。

>这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

参考：[https://www.cnblogs.com/polly333/p/4798944.html](#https://www.cnblogs.com/polly333/p/4798944.html)

## 查找树

## 伸展树

## B树
