# 架构师画像

## 目录

1. [关于架构优化和设计，架构师必须知道的事情](#关于架构优化和设计，架构师必须知道的事情)
   - [如何实践](#如何实践)
   - [一些工具的介绍](#一些关于以上工具的介绍)
2. [如何才能真正的提高自己，成为一名出色的架构师？](#如何才能真正的提高自己，成为一名出色的架构师)
3. [架构师的必备素质和成长途径](#架构师的必备素质和成长途径)
4. [软件架构设计思想与模式](#软件架构设计思想与模式)
5. [经典软件开发生命周期与过程](#经典软件开发生命周期与过程)
6. [现代软件开发管理原理](#现代软件开发管理原理)
7. [需求抽取与业务建模](#需求抽取与业务建模)

架构师，这个title就和总监之类的title一样，已经彻底被用烂了，但在一个软件产品的生命周期中，架构师是实实在在的一个极度重要的角色，这篇文章就来讲讲我觉得的架构师的画像，到底具备什么素质的同学是贴合架构师形象的，同时欢迎大家回复下在你心目中NB的架构师的画像是怎么样的呢。

**业务理解和抽象能力：**

架构师的第一职责是理解业务，并转换为可被研发理解的实现方案，因此业务理解能力是架构师的必备技能，通常来说一个资深的业务架构师，对业务会有非常深的认识和积累，一个极好的业务架构师应该能大概预判业务未来的发展趋势，以便在系统的可扩展性上留好一定的空间，所以也会很自然的出现有些业务架构师做着做着就干脆转为PD类型的角色。

抽象能力是通过对业务的理解转换为系统实现的模型，这显然也是重要的能力，抽象很多时候也承担了分解清楚多个团队的职责，分工清晰化。

**NB的代码能力：**

之所以现在很多的架构师都会被认为是大忽悠，就是有一堆顶着架构师头衔，又不干活的人（甚至会出现对技术几乎不太懂的人），光说不干，再加上说的不靠谱的话自然很容易被认为是大忽悠，就我自己而言，我一直认为架构师有个非常重要的职责是编写整个系统中核心部分的代码，这个部分并一定是技术挑战最高的，但对整个系统的质量/成败与否是具备非常关键的控制作用的，所以架构师必须是从写核心代码的人中诞生出来的。

在一个跨多领域的大型系统中，架构师不太可能什么都擅长，不可能写各个部分的核心代码，这种时候架构师一定要知道怎么判断非自己知识领域的部分实现是否OK，以确保各部分组合在一起的时候是符合架构设计预期的，通常这种确保各部分组织在一起work的机制部分的代码应该由架构师自己操刀。

**全面：**

全面是一个架构师展现出来的最关键素质，全面会体现在三点上：

1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案，这点其实挺重要的，否则可能就会出现明明有一个简单成熟的方案，但由于不知道而做了其他复杂不成熟的方案，所以广阔的技术视野是架构师的必备，另外架构师不可能全部擅长，在自己不擅长的点上，需要知道找哪个专业的人是靠谱的，这点也非常重要；

2. 在做系统设计时是否考虑到了足够多的方方面面：

   例如很多系统设计容易遗漏上线环节的细节，导致在上线时发现漏掉了什么考虑，临时解决或只能重来，记得有一年我做的一个设计没有考虑到上线阶段的一个细节，导致上线的时候发现由于网段的问题完全不work，并且没有临时解决方案，只好重来，系统设计不仅仅指导研发同学怎么写代码，也包括指导其他所有相关技术同学的工作；

   又例如我2008年在做服务框架设计的时候，集群和集群之间通过硬件负载均衡设备来访问的，连接的方式是单个长连接，这个设计导致了运行过程中如果要发布被调用的服务方，很容易出现压力都集中在前面重启的机器上，这也是典型的整个链路没有考虑清楚造成的设计问题；

   再例如2013年我在做一个比较大范围的系统改造的设计时，由于对其中一部分的软件了解的不够，判断错误，导致后来这个改造在进行过程中才发现有些需要改造的关键软件的设计做的太粗糙，最后上线进度差不多推迟了一个多月，而且那些后来补的设计都是紧急做的，风险非常高；

   回顾自己设计过的软件，发现在这个点上犯的错可以讲好几天，看来我应该整理另外一篇文档《我在系统设计上犯过的xxx个错误》，里面有些其实靠一份好的系统设计模板也许就能避免掉，一份好的系统设计模板是可以帮助架构师思考全面些的。

3. 在做系统设计时是否考虑到了未来的一些发展，尽可能不要出现未来的一点变化就导致现在白干或要花大量力气来改造的现象，想当年做服务框架的时候，后来就发现由于当年做设计的时候没有考虑到将来服务调用trace的问题，导致了后来为了弥补这点花了巨大的力气（不是技术上，而是实施上）。

全面需要架构师有足够广的技术领域知识和足够多的经验积累，从全面这点就可以看到架构师的工作绝不是画几个框，连几根线那么简单。

对架构师全面这点的挑战，会随着系统的范围越大（一个系统的设计，和100个系统组成的大系统的设计挑战是完全不同的）而变得越难，无论是知识的广度、考虑的点的覆盖度、还是未来趋势，更复杂的情况甚至会出现架构的调整对应着组织结构的调整，这种也要考虑到，例如服务化这种大的架构改造，就意味着专职的专业领域服务团队的成立。

**全局：**

全局观通常是指在系统设计时是否考虑到了对上下游的系统的影响，毕竟通常所设计的系统不是一个孤立的系统，如果没有足够好的全局观，有可能会导致自己的系统做完上线，其他上下游系统（尤其有些连上下游是谁，怎么用的都不知道的情况下）出现问题，这种案例同样不少。

**权衡：**

权衡同样也是架构师极度重要的能力，或者也可以认为是决策能力，技术方案的拍板是一个架构师最重要的职责。

上面说的全面是架构师在思考时开的过程，而权衡就是收的过程，收的过程结束基本就意味着技术方案的确定，同时也确定了节奏，权衡在两点上会体现的特别突出：

1. 技术方案决策原则

   通常一个问题都会有多种可解决的技术方案，怎么来决策就至关重要了，而决策通常又和全面相关，大的来说通常决策的原则就是性价比和可持续发展。

   性价比简单来说是方案的实现成本，这个成本要包括非常多的方面，例如有些场景可能会是用硬件解决看起来是花钱，但最终折算成本是最划算的，很多系统设计在决策性价比时都过于随意，例如一个另外常见的场景就是建设一套新系统替代旧系统，这个时候可能完全没考虑旧系统的迁移代价甚至超过了改造旧系统的代价；

   可持续发展简单来说就是所选择的技术方案在公司是否可持续，例如简单的案例是公司主体的研发人员都是php，却搞一个其他语言，且只有极少人懂的（当然，这还是要看性价比，如果搞一个其他语言带来的效益超过了语言/人才体系的更换成本），又例如引入一个开源产品，有无专业团队维护这都是要考虑的关键因素。

2. 优先级和节奏控制

   经常我会问做系统设计的同学一个问题：对于这个业务场景而言，在系统设计上最需要把握的一个点是什么；这是一个关键问题，全面意味着考虑到了很多地方的问题，但通常业务需求实现都是有很强的时间要求的，因此在这个时候必须考虑清楚不同点的优先级，同时也包括技术方案在决策时也要做出取舍，有可能选了一个不是那么好的技术方案，但通过留下一些可改造的空间，为以后的重构做好铺垫，那就是很不错的，尤其技术同学有些时候比较容易陷入解决技术问题的场景去，但那个问题其实有可能不是现阶段最重要的。

   其实<b style="color:red">优先级</b>和<b style="color:red">节奏控制</b>是我认为一个最NB的架构师的最佳体现，优先级意味着把握住了重点，可以确保在所设计的架构指导下业务实现不会出现大问题，节奏控制则意味着全面，为将来做好了铺垫。

## 关于架构优化和设计，架构师必须知道的事情

**概述：**

你可以叫它SOA的新玩法、微服务、或者任意其它酷炫的名字。近几年来随着互联网的飞速发展，新的架构实践方式不断涌现，但是有一件事情是永恒不变的，那就是——“架构之道”；关于如何设计出灵活、高可用性以及能够快速适应变化的系统架构，我们依旧还有很大的发挥空间。

本文会介绍关于如何构建前沿的、易维护的、安全的架构的几个要点，同时你也可以把它当作系统设计的准则或者用它来验证现有的架构是否合理。

就像我们经常所说的：没有最好的架构，只有最合适的架构。一个好的架构师，可以根据具体的需求、所拥有的资源等因素综合考虑而设计出最优的架构方案。特别是现在，业务的飞速变化、数据无处不在等这些因素的影响下，技术和框架也需要在变化的过程中不断地打磨和提升以适应新的业务需要。可能当时是最好的架构，但是后来我们还是要跟着业务的变化去做改进。这并不是一件坏事情，我们只要做好应对变化的准备即可。

**与代码无关：**

架构师这个词的意义非常广泛，有些架构师是指在公司负责编写软件的某些模块的人。当然多数公司并没有这样的职位，他们会有一些技术leader来负责具体的功能。我们这里所要讲的架构师不会太过于关注代码的细节，而是更关注系统各个模块之间如何协同、交互等一些更全局的一些事情。他们主要关注一些可能经常会被人遗忘但是又会为系统带来恶劣影响的部分，职责是确保所有的功能都能够以较好的质量及时被交付。这种人对于软件产品的成功有着举足轻重的地位，当然他们往往在一个公司里面可能同时负责好几个项目。

想象一下，两个不同的架构师来建造一艘太空飞船。第一个选择用纸来糊一个样子比较好看的，然后把这艘飞船放到一个漂亮、大小合适的玻璃橱窗里面保护起来。飞般看起来可能像下面的这个样子：

![x](./Resource/32.png)

第二个架构师决定用乐高模型来拼一个太空飞船，它们可以随意组合并且比较坚固，所以并不需要额外的特殊保护。

![x](./Resource/33.png)

两艘飞船看起来都是挺不错的，但是第一个用了较长的时间来完成并且后来当他们需要对这艘飞船做改进的时候，问题就暴露出来了。

第一位架构师几乎炸了，因为每一次的改动时候，他们必须要移除那个保护罩，并且需要重新再造一艘完整的飞船。虽然他们已经有了所有的模型，再加上造飞船对他来说已经很熟悉，但是他们还是花了很长的时间去完成每一次改造，另外还需要再做一个新的保护罩才能装的下那艘新的飞船。

但是对于第二位架构师来说，这一切都是不需要的。他只需要对产生影响的一些组件进行改造，制作新的组件，当一切准备就绪再添加到原来的飞船即可。

再后来，第二位架构师希望能更进一步的优化他们的制作过程，因为他们现在投入了很多的时间在上面。在经过一段时间的研究之后，他们决定尝试用一种新的材料和方法来制作这艘飞船。也就是3D打印，他们申请了一台3D打印机，制作了所有的模型，这样他们就可以将一些常规的任务通过3D打印机自动完成了。

当然，这只是一个很简单的例子。但是我们能从中学到什么呢？虽然两位架构师在最开始的时候都能成功的完成最初始的功能，但是他们都面临着变化所带来的系统的调整。在集成阶段，复杂性开始显现出来，和最开始的目标无关，最终整个设计是否足够灵活、可调整、以及模块化起着至关重要的作用。

软件的架构至关重要，仅仅有较好的代码来完成功能不足以成为一个优秀的解决方案。因为它不仅仅涉及到代码，还有我们所写的各个模块之间如何交互和集成、数据如何存储、我们怎么样来进行开发和测试、以及在引进变动的时候的难易程度等等。

这些事情都是和编写代码无关，但是需要我们来花时间考虑，并且是整个系统最后是否成功的决定性因素。

**要去考虑的细节：**

还有一些原则比如：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。

DDD给我们提供了在不同的特定领域上下文以及业务功能的基础上拆分组件的指导方法。

把服务独立出来提供特定的功能，同时方便在应对变化的时候能够不影响其它的服务。

在大多数情况下，如果需要同步更新很多个服务则说明系统的耦合还不够低。当然，再完美的原则也会有例外的时候。比如当你想把系统部署在一些IoT设备上的时候，你可能要一次性部署所有的组件。这是允许的，但是，请尽量考虑服务之间的耦合及灵活性以应对将系统部署在不同平台上的需求。

即便如此，我们也不可能完全避免耦合，它总是会出现在某些场景下。这就需要我们提取一些抽象层将服务之间的交互定在契约上来避免复杂，提升灵活性。

这就需要我们有一种辨别能力，能够找到那些必须放在一起来做处理而不能拆解的功能。如果这些功能是值得放在一起的，那我们就可以将它独立成一个微服务，遵循高聚合的设计原因。

我们要记住的是，系统的设计要做到比较容易地增加或者修改原来的组件。无状态的架构是系统高扩展性的基石。

特别需要注意服务和组件之间如何交互，了解不同的协议的优缺点，包括速度以及可用性，来帮助我们来决定哪一种是最适合我们的。

**基础设施、配置、测试、开发、运维：**

为配置管理定义策略，因为同时发生的配置变化对系统所有造成的影响也是很重要的，所以需要由全局层面的的自动化更新方案来完成。

在如今，对于一个数据敏感的大型解决方案来说如果没有自动化的一些基础设施和稳固的开发、测试和部署流程，那就和自杀无异。我们需要花费一定时间来计划和准备开发、测试、生产环境，可能还需要一些额外的环境以备不时之需。

测试流程和策略也是非常重要的。一些最佳实践使用Blue-Green开发、金丝雀部署、A/B测试等。尽量保持测试环境与生产环境是一致的，至少硬件结构上来说应该是一样的。一定要做压力和负载测试，并且尽可能快的在生产上进行这样的测试，这样能够更快速、精确的帮我们找到线上的问题。

可调整的架构同时也意味着服务要可以被灵活独立的部署以及简单的基础运维操作。

**利用不可变基础设施的优势：**

不可变基础架构，就是说系统一旦部署，就不再更变升级。当服务/应用需要升级时，只要部署一个新版系统，摧毁旧版就好了。在这个过程中，系统对外服务是几乎是持续的。（译者注）

保证打包/持续集成进程是基于统一的途径，并且不会对正在运行的服务进行任何更改（比如 禁用ssh），所有的更新都应该通过定义好的自动化配置和打包操作将它们应用到所有的对应的系统上，来避免配置遗漏。比如手工某个环境上修改配置，可能会漏掉其它环境的配置。

开发团队不应该过度关注基础设施，因为有一天可能基础设施也会发生改变，所以与业务相关的开发不要和基础设施有过重的绑定。
代码之间的东西(in-between the code)

"in-between the code" 可以统一的概括为一些基础设施所提供的功能，比如：服务发现、请求路由、网络通迅层、代理、负载均衡等等。很多生产上的错误并不是因为代码的业务逻辑错误或者每个独立组件本身的问题，而是由于这些把各个组件协调起来的一些通用基础设施。

随着系统的变化越来越快，更要注意我们所更改的一些组件，考虑可用性和扩展性。制定最小风险的计划来应对出现的问题。

**无处不在的坑：**

做一个偏执狂。为失败而设计架构 - 列举所有可能失败的地方。和团队头脑风暴对所有可能失败的地方进行质疑然后提出保护方案。

- 如果连接建立失败怎么办？
- 如果花费的时间超出预计怎么办？
- 如果请求返回不清楚的数据或者不正确的答案怎么办？
- 如果请求返回的数据不是约定好的怎么办？
- 如果出现很高的并发能应对吗？
- 如果服务挂、机组、整个数据中心挂掉了怎么办？
- 如果数据库损坏了怎么办？
- 如果部署的时候失败了怎么办？
- 如果在部署成功之后生产环境上某些功能失败了怎么办？
- 集成性这方面的错误可以有千万种可能，那么我们应该如何来避免？

使用一些技术比如：熔断(circuit breaker)、超时设定(timeouts)、握手信号(handshaking)、舱壁(bulkheads)来帮助我们保护这些系统集成之前的问题。

熔断模式(circuit breaker)可以参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。

舱壁模式(bulkheads)该模式像舱壁一样对资源或失败单元进行隔离，如果一个船舱破了进水，只损失一个船舱。比如采用微服务是首选，比如docker。Docker是进程隔离的，单个 docker失效不会影响其他docker容器。或者把大的并行处理工作，由多个线程池来负荷分担。（译者注）

当然，如果当它开始工作的时候，说明我们的系统出现了比较大的问题，需要我们去调查分析。

注意那些不能看到代码的组件、依懒项以及共享的资源。除了有正确的开发和测试流程以外，还应该尽量使用和真实生产环境一样的数据、以及硬件网络配置来进行测试。

跟踪系统的响应来防止一些比较常见的问题比如服务不可用的情况，留意系统的平均响应时间，当它有异常的时候需要寻找原因以及采取相应的行动。

搭建日志、监控、以及系统操作的自动化操作平台。由于微服务相对来说较独立，可以更方便检测失败 所以监控起来会更容易一些。一些比较不错的方式是在收集和分析日志的时候使用关联ID、通用日志数据格式等。注意日志数据可能会非常庞大，所以要考虑日志的时间周期，定义对日志进行归档。另外还有一些不错的工具可以将数据可视化在页面中，可以更直观的看到一些重要的进程。

为了保证服务的更新不会影响客户端的使用，对于服务的版本控制也是非常重要的。有些情况下同时运行不同版本的服务也是很常见的情形，我们要做好长期向后兼容的准备。

**务必要记住的事情：**

大多数情况下我们并不是从零开始去构建，而是在现有的系统上继续添砖加瓦，而原有的系统在开发、运维、以及架构灵活性上都存在一些问题。想必很多优秀的开发人员在经历这样的情况的时候，都会想去拆解、重构整个系统，但是我们需要谨慎地来完成这个事情。当系统以错误的方式成拆分成组件或者服务单元之后也是一件很危险的事情 。

大多数系统在一开始的时候都是一个单体应用，后来不断地被拆解成为微服务。下面有一些基本的理念可以在我们做拆解地时候当作参考：

- 在开始拆分前了解具体的业务需求和业务领域
- 注意一些和其它业务共享的功能和数据，它们需要被正确地模块化
- 这种迁移和升级适合一步一步、一点一点地来完成，仅仅做当前最合适的事情
- 在开始之前很好地理解业务领域的范围及边界，因为对边界的调整将是非常昂贵的
- 对于改造有清晰的结构此次会涉及到哪些团队的调整

**人、团队、和组织的影响：**

这个话题太大，大到我们需要专门写一篇文章来细述。在这里简单地概括一下，在本文中我们所提到的架构的灵活性以及稳健的开发、测试、运维等流程都会影响企业的组织结构。合适的组织结构能够给团队更大的灵活性并且更有机会持续地创新，在这种组织结构下，团队可以根据自己的节奏来工作。

组织不应该按技术来拆分团队，比如前端团队、移动端团队、后端团队或者根据不同的技术语言拆分团队等，而是应该按照微服务来拆分团队（也可以理解为按独立的业务单元来拆分）。这样在一个团队里面就会包含各种不同的技术，可以用不同的语言来实现服务，这也给团队更多的自由和自主权。

### 如何实践

容器化和集群工具：

- Docker
- Docker Swarm
- Kubernetes
- Mesos
- Serf
- Nomad

基础设施自动化/部署：

- Jenkins
- Terraform
- Vagrant
- Packer
- Otto
- Chef， Puppet， Ansible

配置：

- Edda
- Archaius
- Decider
- ZooKeeper

服务发现：

- Eureka
- Prana
- Finagle
- ZooKeeper
- Consul

路由和负载均衡：

- Denominator
- Zuul
- Netty
- Ribbon
- HAProxy
- NGINX

监控、跟踪、日志：

- Hystrix
- Consul health checks
- Zipkin
- Pytheus
- SALP
- Elasticsearch logstash

数据协议：

- Protocol Buffers
- Thrift
- JSON/XML/Other text
- ...

### 一些关于以上工具的介绍

由于本文涉及到大量的开源组件，下面简单列举一些以供参考（部分内容来自于互联网）。

**Docker Swarm：**

Swarm发布于2014年12月的DockerCon，用以管理Docker集群，并将其抽象为一个虚拟整体暴露给用户。其架构以及命令比较简单，同时也为希望管理Docker集群的Docker爱好者降低了学习和使用门槛。

**Kubernetes：**

Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用。

**Apache Mesos：**

Apache Mesos是由加州大学伯克利分校的AMPLab首先开发的一款开源群集管理软件，支持Hadoop、ElasticSearch、Spark、Storm 和Kafka等应用架构。

**Mesos Aurora：**

Aurora 也是Apache的开源项目之一，是长期运行服务和计划作业的 Mesos 框架。Aurora 通过一个共享机器池运行应用和服务，并且负责保持它们的运行，知直到永远。当机器失效的时候，Aurora 会智能的重新规划这些作业到健康的机器上。

**Vagrant：**

Vagrant是一个基于Ruby的工具，用于创建和部署虚拟化开发环境。它使用Oracle的开源VirtualBox虚拟化系统，使用Chef创建自动化虚拟环境。

**Packer：**

Packer是一个开源工具，用于从单一配置来源为多平台创建相同的机器映像。目前支持的平台包括Amazon EC2、DigitalOcean、OpenStack、VirtualBox和VMware。

**Terraform：**

Terraform 是一个安全和高效的用来构建、更改和合并基础架构的工具。采用 Go 语言开发。Terraform 可管理已有的流行的服务，并提供自定义解决方案。

**Consul：**

Consul是HashiCorp公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更"一站式"，内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（比如ZooKeeper等）。使用起来也较为简单。Consul用Golang实现，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker等轻量级容器可无缝配合。

**Eureka：**

Eureka 是一个基于 REST 的服务，它主要是用于定位服务，以实现 AWS 云端的负载均衡和中间层服务器的故障转移。

**Ribbon：**

Ribbon 是 Netflix 发布的云中间层服务开源项目，其主要功能是提供客户侧软件负载均衡算法。

**Zuul：**

Zuul 是提供动态路由，监控，弹性，安全等的边缘服务。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。Zuul 可以适当的对多个 Amazon Auto Scaling Groups 进行路由请求。

**Finagle：**

Finagle是Twitter基于Netty开发的支持容错的、协议无关的RPC框架，该框架支撑了Twitter的核心服务。

**Zipkin：**

Zipkin 是 Twitter 的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口。该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。

**Hystrix：**

Hystrix旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包（request collapsing，即自动批处理，译者注），以及监控和配置等功能。Hystrix源于Netflix API团队在2011年启动的弹性工程工作，而目前它在Netflix每天处理着数百亿的隔离线程以及数千亿的隔离信号调用。Hystrix是基于Apache License 2.0协议的开源的程序库，目前托管在GitHub上。

**ZooKeeper：**

ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。

**etcd：**

etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 ZooKeeper 和 Doozer，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。Raft是一个来自Stanford的新的一致性算法，适用于分布式系统的日志复制，Raft通过选举的方式来实现一致性，在Raft中，任何一个节点都可能成为Leader。Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。

**Protocol Buffers：**

Protocol Buffers是Google公司开发的一种数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。它不依赖于语言和平台并且可扩展性极强。现阶段官方支持C++、JAVA、Python等三种编程语言，但可以找到大量的几乎涵盖所有语言的第三方拓展包。

通过它，你可以定义你的数据的结构，并生成基于各种语言的代码。这些你定义的数据流可以轻松地在传递并不破坏你已有的程序。并且你也可以更新这些数据而现有的程序也不会受到任何的影响。

**Thrift：**

Thrift是一种可伸缩的跨语言服务的发展软件框架。它结合了功能强大的软件堆栈的代码生成引擎，以建设服务，工作效率和无缝地与C + +，C#，Java，Python和PHP和Ruby结合。thrift是facebook开发的，我们现在把它作为开源软件使用。thrift允许你定义一个简单的定义文件中的数据类型和服务接口。以作为输入文件，编译器生成代码用来方便地生成RPC客户端和服务器通信的无缝跨编程语言。

## 如何才能真正的提高自己，成为一名出色的架构师

架构应该包括了功能性架构和非功能性架构两个方面的内容。我们常说的J2EE，DotNet标准架构框架更多的是非功能性架构的范畴；而谈的子系统，组件划分，接口设计，复用等内容涉及到功能性架构的内容。J2EE架构的标准模板很容易找到和借用，但是并不代表你是一个合格的架构师，架构师必须深入到功能性架构中，真正的做好需求和实现中间的桥梁。正如现在好的PPT模板一大堆，但是并不代表你能够做出好的PPT来，PPT的模板仅仅是术，而PPT内容和思维才是王道，而这里又是我们经常讲到的模式的问题，即根据我们的目标如何选择相应的图表和模板来最合理，最简单的展现我们的内容。

从静态分析的角度来考虑，架构的核心即是分解和集成。我们面对的现实业务和需求可能太庞大了，如果不去分解我们的构建根本都无法下手，我们就无法真正理解业务细节。因此子系统和组件划分是分解重要内容，分解重要原则又是高内聚，松耦合。由于分解产生了组件间的交互，因此需要根据关注接口的分析和设计，架构师的一个关键职能就是要屏蔽系统本身复杂性，将复杂性作为一个黑盒控制在自己手里，对外只需要暴露尽可能简单的接口。而在分解的时候又必须要考虑集成，架构师在自己脑海里面已经有了目标系统的样子，他们会很有信心分解的组件能够通过当初定义的接口很好的集成在一起。正如汽车制造一样，所有的零备件都出来了却发现它们根本无法组装成一台汽车。这对架构师是最大的悲哀，系统都还没有出来，而架构师就能够游刃有余的做这些事情，靠的不仅仅是多年的设计和开发实践，更多的则是在实践过程中的抽象思维和模式总结。

从动态分析的角度来考虑，现实世界中的原始需求进入，最终出来的则是满足需求的功能实现。在这个过程中涉及到一系列的内部程序流转流程，前台界面，业务逻辑，数据访问，数据实体，公用组件等。这些层次之间应该怎样去交互是在架构设计中必须要考虑清楚的问题，在这方面我喜欢用架构机制这个词语，机制往往并不是静态词汇，因为要深究机制就必须要搞清楚事件触发，功能调用，访问顺序等一系列问题。

简单的讲，架构机制要回答一个重要的问题，即你设计出的分布式框架如何能够满足输入的需求变成最终输出的功能，中间究竟经历了哪些步骤？安全性如何保证？性能如何保证？可扩展性又如何保证？要回答这些问题你都必须给出这些问题的解决方案的运行机制，而只有大家认可了运行机制，或者新出来的模块已经在新架构上运行验证了，才能够讲从架构框架上基本上已经成熟了。

架构本身不是目标，而简单实用并且支持灵活扩展的系统才是我们追求的目标。架构师思维意识里面更加重要的是实用性和经济性而非理想化，由于业务域和问题域的不同没有完全可以照搬的架构，在架构设计上追求一定的可扩展性。要杜绝过度架构和架构理想化的问题，就如何建造一个建筑，如果我们最终得不到一个实用的的建筑物，你再怎么向客户吹嘘你的设计图纸和建造框架如何合理都是徒劳的。

架构师是一个充满挑战的职业，知识面的宽窄往往决定着一个架构师的架构能力，所以在这一点上我比较赞成你的学习方式，就是要阅读大量的技术书籍，但我希望你不要仅限于软件相关的书籍，经常泡技术论坛，一方面可以结交朋友，一方面可以增加自己的知识面。

公司的大小往往决定了所做的项目规模，一般的大项目不太可能直接总包给小公司去做，但这并不妨碍小公司可以分包到大项目的一部分。在做小项目的同时也可以积累丰富的经验，我自己就是一个这样的例子。

我在小公司混迹了5年多，其中也偶尔有1两个大公司，比如大唐电信，但是基本上都是小公司，从基层的程序员到公司的开发总监都做过，甚至自己还设计过包括LED显示屏，密码键盘在内的收费系统，自己联系厂家OEM，当然这些今天已经广泛应用了，当时我们的客户用上之后还是非常震撼的。

知识面的宽广对于一名出色的架构师来说是必不可少的技能，也许很多人对架构的理解还停留在设计模式，重构，SOA等等的软件层面，然而这仅仅是非常基本的东西，架构师的脑子里不光需要知道让软件如何高效的运行，还需要知道如何去结合网络，存储，甚至一些文件系统的特性，比如GFS，NFS，XFS，NTFS等等，而且架构师还需要知道一些编程语言的特性，C，C++，Java，PHP，Python，Lisp，JS等等，现在是一个混合编程的时代，只了解一种语言，即使再精通也会使你在架构系统的时候受到很大的局限性。

再有一点，架构师需要对数据库技术有深刻的认识，因为现今是一个信息时代，大量的信息都是需要存储并检索的，数据库设计的不好，将会严重影响系统的性能，而这一点往往会被我们的设计人员忽略，他们只知道遵守那些范式而不会结合数据的特性去设计数据库。

从一个程序员到架构师是一个很大的变化，架构师需要从大的方面考虑，而不只是考虑这个模块该用哪种设计模式去开发。不能急于求成，也许是我自己变化的比较慢，我用了10年的时间，这10年里，我使用超过一年的编程语言包括了delphi，C++，Java，python，使用的数据库包括了oracle，infomix，sybase，sqlserver，mysql，javadb，sqlite等等，使用过大型机，小型机，服务器。unix，linux，windows都至少做过两年以上的开发，这些使用和开发的经历会大大增强一个人在做架构师这个职业时的技术素养。

总之，想要成为架构师，需要有耐心，不断学习，拓宽自己

## 架构师的必备素质和成长途径

它山之石可以攻玉，尽管每个架构师都有自己的成长路径，但是了解其他架构师的成长之路，对未来想成为架构师的人有一定的借鉴价值。首先以我自己的成长过程为例，描述一下我的架构师之路。

![x](./Resource/14.jpg)

1989年研究生毕业后进入政府机构工作了三年，随后加入新加坡国际航空公司，从事IBM主机系统的汇编语言研发。顺应互联网技术的发展，航空公司开始把订票业务从传统的主机终端转向现代化的彩色PC客户端。为此需要在IBM主机系统和UNIX／Oracle数据库之间来回传输数据，所以我就开始研究Unix/Oracle，取得了Sun、HP和Oracle的认证，并由此进入了互联网技术领域。

2000年以前，很多系统都是采用两位数字来标识年份，比如02代表1902，一个客户的出生年份是1902，系统会把他的年龄当成是两岁，这就是所谓的世纪之虫。很多医院、铁路、银行、政府机构都面临着这个问题，采用新的基于Unix/Oracle和互联网技术的新系统成为一个有效的解决方案。美国在这个方面有大量的需求，因此我就去了美国，专门做主机系统和Unix/Oracle以及互联网上的信息交互，这让我有机会接触大量不同的架构和系统，从而积累了丰富的经验，为后期的架构师之路奠定了坚实的基础。日本工程师的特点是专、深、细，但是缺乏把所有的要素整合到一起解决一个问题的系统集成能力，所以我就成为负责系统集成的总体架构师，大量的系统集成业务为我提供了丰富的锻炼机会，把业务需求转换成技术解决方案，并进一步设计成各种系统，这些工作为我积累了丰富的架构经验。

2004年，加入Abacus任首席架构师，开始协调其他的架构师一起做航空订票方面的互联网技术架构工作。

2008年开始在eBay和PayPal任移动应用的高级架构师，从互联网时代进入移动互联时代。

纵观自己的架构师成长之路，我认为必须要踏踏实实地做好当下的事情，保持好奇心，不断地学习新技术、积累新经验和掌握新技能。紧跟时代的发展和技术的进步，不断地扩大自己的业务和技术领域，那么成长成为架构师就是水到渠成的事情。

### 建筑设计与软件架构

![x](./Resource/15.jpg)

要了解架构师的成长之路，就要先清楚什么是架构。架构一词不是软件行业的专有名词，而是从古老的建筑行业借来的。在墨西哥有个很出名的古代玛雅金字塔，叫ChiChen Itza。塔的四个面分别代表春夏秋冬四个季节，每个面上有91级台阶，代表每个季节91天，4X91=364，再加上塔顶共365，代表一年有三百六十五天。在每年的冬至和夏至，塔身因为阳光照射会出现神奇的蛇影，准确地预测季节变化。古玛雅人的架构设计形神兼具，甚为奇妙，充分体现了架构之美。我们今天的软件系统架构设计与之相比，相形见绌。

![x](./Resource/16.jpg)

在日常工作中，架构师在设计系统的时候会画一张图，HP的服务器，思科的路由器，Palo Alto的防火墙，Tomcat的应用容器，MySQL的数据库等，把各种产品拼凑在一起叫架构设计。这是很棒的产品宣传。如果这是一部电影，可以售卖植入式广告。每个解决方案的供应商都肯定会对这个架构设计表示由衷的感激。对建筑物，最好的建筑师从来不用供应商的名称来描述桁架、梁和支撑，而是用这些部件的大小、负载能力和组成等。这是因为建筑师会基于价格、信誉和质量选择不同供应商的解决方案。建筑师心里很清楚，用供应商的名字描述的是实施，而通过规范和要求来描述，这才是架构设计。

实施代表着你已经作出了选择性的决策，这些决策包括成本的考虑、自建与外购、投资回报率、团队的技能等等。用C++、Java或PHP作为编程语言并不代表你的架构；相反，这些只是为实施架构的组成部分而选择的工具和材料。选择微软数据库，还是Sybase、MySQL或者Oracle数据库，这并不是架构，而是实施架构中的数据库组件。选择使用开源系统还是由供应商提供的解决方案是另一个实施决策的例子，这与使用微软的操作系统还是Linux的某个版本同样是实施决策。

假设现在某个业务需要一个解决方案，架构师负责把业务解决方案转换成技术解决方案，如果把所有产品罗列起来或许可以解决问题，但是也肯定不会有什么创新的机会。相反，如果从事情的本源或本质出发，往往有机会创造新工具或新方法，这就是非技术设计的概念。

例如，当我们要解决近实时的动态交易量统计的时候，可以利用传统的数据库来做累加。也可以写一套类似Storm的工具，既轻松优雅地解决了问题，同时也带来了创新。做为一个合格的架构师，就要有能力从事情的本源出发去独立思考问题并做出各种分析和设计，最后拿出一个非常合适的解决方案。

### 架构师的必备素质

![x](./Resource/17.jpg)

做为一个合格的架构师必须具备八个重要的素质，包括业务理解、技术广度、技术深度、丰富经验、美学素养、动手能力和沟通能力。

架构师的业务素质就是指要懂业务，对业务有足够的敏感度，能够清楚地知道自己的设计能给公司带来多大的业务影响。对技术素质最基本的要求是深度和广度。美学素质是要求架构师有美感和艺术感，所以易宝经常安排技术人员听音乐会，看艺术表演，因为艺术和设计是相通的。动手能力是指在适当的时候架构师能够上手实际操作，需要写代码的时候动手写代码，尤其是底层的关键代码。沟通能力也极为关键，因为架构师水平再高，如果沟通能力很差，花半天时间说不清楚自己的方案，那么再好的方案又有什么用途？在易宝每个周五的下午请架构师进行内部分享，讲讲最近都设计了什么有价值的系统，把自己做的解决方案用一句或几句话清楚地表达出来。因为能简洁地表达清楚意味着架构师已经深刻地思考和提炼了自己的设计思想。

在美国工作时，曾经有一位CTO跟我说：我不希望架构师有太多的协作，希望架构师都是孤单的鹰。你什么时候看见过鹰是一群一群飞的？真正的雄鹰都是飞得很高很孤独的，架构师也是这样。这里并不是说架构师不需要交流，而是在正常的情况下，架构师应该有足够的智慧和独立思考能力去做出最优的技术与业务判断。架构师的位置越高这种孤独性就越大。假如你是CTO，整个公司的技术问题都要你自己去规划，并对结果负责，根本没有人可以商量。要求有鹰飞的高度还有一个原因，就是只有飞到一定的高度才能够看到全面和整体。另外，除了飞得高，还要求架构师要有鹰一样敏锐的眼睛，能够观察到设计中不为人知而又很重要的细节。

架构师还要具备有艺术的品位，设计出的系统足够优雅，那么，应该怎么理解这个品位呢？每个系统研发人员，如果做研发的唯一目的是实现一些代码，做出某些满足业务需求的功能，那么就没有什么艺术品位。所谓的品位是指有个人独特的风格。做出的解决方案，具有不同于常人的地方，是经过架构师充分的独立思考提出来的。我们非常看重有独立思考和个人风格的艺术品味。

![x](./Resource/18.jpg)

架构师要怎么做才能具备鹰飞的高度、鹰眼的敏锐和艺术的品味呢？

首先架构师要有较高的智商，其次，架构师要有一定的的情商，做为一个高级的技术人员，拥有开放的心态、谦虚的态度、幽默的气质会帮助他传播自己的设计理念，形成自己的设计风格，赢得广泛的影响力。再次，还有另外一个不常为人知的悟商亦至关重要。这是百悟科技的负责人张总从老子《道德经》里领悟出来的，我有幸为该书作序。所谓的悟商是指足够快速感应并适应周边环境变化的学习能力。做为一个架构师，要能跟随技术发展的脚步，该做主机系统的时候学习主机系统，该做分步式计算的时候能适应分布式处理，该做移动应用时能设计移动服务。技术在不断地演进，业务在不断地变化，在这个世界上唯有变化是永恒的，特别是互联网技术领域，架构师的悟商有多高，学习和适应能力有多强，基本上决定了这个人能在架构师之路上能够走多远。

### 架构师成长途径

关于架构师的成长之路，还存在着一个误区，就是把架构师默认为软件架构师。

因为今天我们所遇到的架构师，大多数都是围绕着软件研发。事实上这个认识有一定的片面性。诚然，现今我们所构建的系统都是软件系统，但是在实际的工作过程中，随着信息技术在深度和广度上的快速发展，除了软件研发以外，测试、网络、安全、配置、系统和数据都已经形成了具有自己独特专业知识和经验的领域，也都需要各个领域的架构师。比如信息安全是一个非常专业的领域，要软件架构师无法完全理解和驾驭信息安全是勉为其难。网络架构师日常研究的各种网络问题，软件架构师也难以置喙，因为这是完全不同的两个领域。数据方面亦如此，能够把整个公司业务数据之间的关联性了然于胸的人，一个公司或许能有一两个，这种人就是数据架构师。现实的情况是，软件架构师占据主导地位，基本上掩盖了其他领域架构师的光芒。当然出现今天这种情况的主要原因也是因为大部分的技术领导者也都是来源于研发领域。这种状态要尽快改变，否则在运维、安全、数据、测试等其他领域工程师很难有自己的成长空间。

![x](./Resource/19.jpg)

架构师的成长基本上可以分为初级、中级、高级、架构四个阶段。

初级阶段是指大学毕业后的两年时间。这两年主要就是学习，目前大学的教材和讲义往往比现在企业正在使用或者发展的技术有一个时间差。学校教授的东西可能是几年前的技术，不是当下正需要的，所以毕业进入企业后要通过不断的学习赶上新技术发展的步伐。

中级阶段是指两年到四年这段时间，主要是积累知识和技能，比如，怎么思考业务问题、怎么解决问题的技能，在这一阶段的人会在自己的工作小组内暂露头角，小有影响力。

高级阶段是指四到七年这段时间，在这一阶段主要是积累经验，就是说以前类似的业务问题是怎样转换成技术解决方案的，这次应该怎么解决，方案的优点是什么，缺点在哪儿，未来怎么改进等等，这个阶段的人会逐步在自己的部门内有一定的影响力，开始带团队。

架构阶段是指至少具备七年以上的经验，在美国，其实架构师不少都是鬓染白发的技术领导者，我在eBay工作的时候属于比较年轻的架构师。到了架构师这一阶段，企业期望架构师具有能够把各种经验和知识综合发挥的智慧，这里强调的是智慧，而不仅仅是经验，而且要求他们具有跨部门的影响力，也就是架构师的设计方案能够影响到公司副总裁一级的决策。

### 给准架构师的建议

总而言之，对普通技术人员成长为架构师，我有五个建议：

- 第一要有高度，培养自己的思维高度，从而对技术和业务有整体的视野。
- 第二要有深度，培养自己独立思考问题，看清问题本质的能力。
- 第三要有广度，拓宽自己的技术和业务范围，从而确保自己不成为井底之蛙。
- 第四要有新度，培养自己的好奇心，对任何相关的东西都感兴趣，并想去了解，不断地学习新技术掌握新技能。
- 第五要有沟通力，培养讲清楚方案的能力，特别是用一句话把事情讲清楚的能力。

今天，互联网技术飞速发展，已经成为社会和生产的重要推动力，架构师的作用由此变得愈来愈重要，成为很多技术人员的职业目标。从普通技术人员成长为架构师是一条艰苦漫长而且布满荆棘的路，如何对准目标、设计路径、培养素质、积累经验是每个想成为架构师的技术人员都必须要认真思考的问题。

### 架构设计师—你在哪层楼

有个故事说某人经过了一个建筑工地，看到有些人站在好几层高的脚手架上，在一面墙前忙活着，问你们在干什么呢？第一层的人答道：“这不明摆着么？我在磊砖呢”接着问第二层的人，道：“我正在砌一面墙，不仅起承重的作用，在功能上是大厅走廊的一个连接部分，和其他很多部分都有联系”。接着问第三层的人，说：“我在建一座智能大厦，未来在这里办公的人能在合理设计的空间内实现高效的合作”

如果拿这个故事来比喻IT架构设计的话，可能不太恰当。我只是借故事传达个意思。

**第一层的架构师看到的只是产品本身。**

例子中指的是砖。按照客户的要求，我给他垒砖就是了。我想的是砖怎么垒的整齐，怎么牢靠。至于其他的我不太关心。以产品为导向的供应商中，这种思维模式并不少见。因为过多关注产品本身，局限了你站的高度和思维方式。这需求特别清晰并不经常变化的情况下，这种专注可以带来短期的有效收益。可是在当今多变的IT环境下，这种思维限制了可持续的发展，也消极的放弃了在产品之外增加利润增长点的可能性。

**第二层的架构师不仅看到自己的产品，还看到了整体的方案。**

除了砖本身之外，看到了墙以及其他的连接部分。在大型的项目中，往往某些产品只是全局的的一个部分而已，用户真正关心的是整体方案是否能满足需求，以及方案各个组成部分是否无缝整合。这就要求架构师能眼光更开阔一些，可以预见性的考虑整合中可能的风险和问题，并提前准备。

**第三层的架构师看到的是商业价值。**

IT项目的背后都有Sponsor，那么Sponsor真正关心的问题是什么，TA要实现的商业价值是什么？如何衡量该价值的实现？第三层的架构师不应该太拘泥于具体实现的技术本身，而是更多关注愿景实现、商业流程、IT运行模式以及持续IT服务等方面。这也就是所说的EnterpriseArchitect所关心的方面。

本文无意评判三层楼孰优孰劣，每一层都有其存在的合理性以及价值。而且每个人的职责能力时间也决定了TA只能在某个方面有所侧重。我只是希望从思维的角度挑战自己，让自己在可能的情况下，多到不同的层面上看看，也许会有意想不到的收获，同时可能为客户创造最大的价值。

## 软件架构设计思想与模式

**核心思维：**

- 实现企业核心价值观。
- 企业核心价值：投入产出比。

**能力：**

1. 力争使用总体上能力一般的队伍，通过组织和设计的力量，生产出符合质量要求的产品。
2. 因为需求变更不可避免，造成设计调整进而造成总体投入增加，所以必须研究架构设计如何更好的适应变更，使变更、维护与升级的成本下降。

**软件质量：**

软件质量被越来越重视，如何设计高质量的软件产品，成为软件架构设计的重要主题。80%的质量问题由需求分析和架构设计两个环节造成，如何改进：

1. 需求分析：充分理解用户需求。
2. 架构设计：合理组织技术方案（把人和任务作为一个重要因素进行考虑），充分激发集体的智慧。
3. 项目管理：与架构设计匹配协调，使技术方案的高质量实现成为可能，重视产品线架构和核心资产库构建的理论、方法、组织和技术。

**软件项目历史概况：**

随着时代的进步，同样规模的软件成本在大幅下降，投资回报在大幅上升。

![x](./Resource/34.png)

### 架构定义

**两大派别：**

- 组成派：组件 + 交互。关注分割与交互
- 决策派：软件架构是一系列重要决策：
  - 软件系统的组织
  - 构成系统的结构化元素，接口和它们相互协作的行为的选择
  - 结构化元素和行为元素组合成粒度更大的子系统的方式的选择
  - 指导这一组织（元素及其接口、协作和组合方式）的架构风格的选择。

**设计原则：**

现代软件架构设计的原则来自于软件复用

软件开发实际上是从问题域向最终解决方案逐步映射和转换的过程，而特定领域软件架构(DSSA)和软件架构风格(Architectural Style)分别从问题域和软件解决方案两个方向提供了若干经过考验的候选转换路径。

特定领域软件架构（DSSA）：一个领域中的所有应用系统所共有的体系结构，是针对领域模型中的领域需求给出的解决方案，也是识别、开发和组织特定领域可复用构件的基础。

架构风格（AS）: 与面向对象的设计模式或框架一样，为设计经验的复用提供技术支持（一组可以用于某种风格实例中的构件和连接方案，以及它们的拓扑结构、组装规则以及局部和全局约束）

**为谁设计：**

1. 架构师要为客户负责，满足他们的业务目标和约束条件
2. 架构师要为用户负责，使他们关心的功能需求和运行期质量属性得以满足
3. 架构师必须顾及处于协作分工“下游”的开发人员
4. 架构师还必须考虑“周边”的管理人员，为他们进行分工管理、协调控制和评估监控等工作提供清晰的基础

![x](./Resource/35.png)

**架构师职责：**

1. 技术负责，解决方案的提供者；
2. 与项目经理合作，制定计划，决定成员，组织团队；
3. 保证项目按计划和走向完成；

**架构师思维：**

1. 架构设计的源泉来自于需求分析。
2. 架构设计重心和特点来自于质量需求（非功能性需求）
3. 架构的实现依赖于好的项目管理

**现实情况：**

- 在信息系统战略规划（ITSP）的大环境下进行设计

  信息技术战略规划（ITSP）的核心思想简述如下：在信息时代知识经济的背景下，正确的结合 IT 规划，整合企业的核心竞争力，在新一轮的产生、发展中取得更大的市场竞争力是必要的。

- 换位思考

  从企业管理者和使用者的角度思考：

  - 为谁设计？
  - 可以解决用户的什么问题？
  - 为什么要解决这些问题？

任何项目都是由项目的陈述开始的，在陈述的过程中比较难解决的问题是表达可度量的价值，所谓可度量价值实际上是一个预估，只是说由于加入了信息系统，解决了过去存在的问题，从预估的角度业务水平可能提升的一个度量数据。但并不等于说管理依然混乱，只要有了这个信息系统，什么事情都做就可以达到这个水平，这实际上是不切实际的幻想。

所谓信息系统战略规划的本质，并不是说信息系统可以包打天下，而是说在整体规划下的信息系统，提升了组织管理水平，减少了不必要的环节，提高了效率，通过全方位的努力，在可预测的未来，确实可以提升整体的经济效益，而且这个预测经过努力是可以达到的。

## 经典软件开发生命周期与过程

**瀑布式过程：**

1. 收集市场数据，做市场分析。
2. 确定用户，与用户交流，理解用户，理解用户的工作并与用户建立良好的关系，以便将来的设计和开发过程中经常得到他们的反馈意见。
3. 建立典型用户群，通过对用户工作的了解，发现和自己设计工作有关的典型用户群。这些典型用户群应该能够描述用户工作中的一个或者几个重要环节。
4. 与用户交流进一步细化典型用户群，并写出场景脚本。
5. 确定软件的主要功能。
6. 确定这些功能的主次，并确定优先级。
7. 确定需求并写出说明书。
8. 由用户群检查需求说明书，看需求说明能不能满足用户的需要。
9. 进行软件架构设计。

![x](./Resource/36.png)

早期的模型要求在项目的第一阶段，在任何设计和实现工作之前，尽可能的推敲，把需求完全定义清楚，并把它稳定下来，并且实际开发前冻结需求，但历史证明这种方式是失败的，在项目很大的时候，冻结需求几乎没有可能。

**增量模型：**

原理：首先构建部分系统，再逐渐增加功能或者性能的过程。

优点：降低了取得初始功能之前的成本，强调采用构建方法来帮助控制更改需求的影响，也提高了创建可操作系统的速度

实现：在生命周期的早期阶段（计划、分析、设计），建立一个考虑了整个系统的架构，这个架构具有强的可集成性，后续的构件方式开发，都建立在这个架构之上。剩下的生命周期阶段（编码、测试、交付）来实现每一个增量。

![x](./Resource/37.png)

## 现代软件开发管理原理

1. 把过程建立在构架优先的基础之上
2. 建立一个能尽早面对风险的迭代式生命周期过程
3. 设计方法向强调基于构件的开发转变
4. 建立一个变更管理环境
5. 通过支持双向工程的工具增强变更的自由度：双向工程指的是不同格式（例如需求规格说明、设计模型、源代码、可执行代码、测试用例等）自动转化并同步工作信息所需要的一个环境支持。
   例如：需求工具RequisitePro使我们可以在迭代之间跟踪用例的部分完成情况
6. 用严格的、基于模型的符号标记系统：UML
7. 为过程配备工具进行客观的质量控制以及进展评估
8. 使用基于演示的方法评估中间制品
9. 计划在大量的使用场景中使用细节的进化等级进行中间发布
10. 建立一个经济上具有伸缩性的可配置的过程

**软件产品线：**

![x](./Resource/38.png)

什么是软件产品线：软件产品线是指具有一组可管理的、公共特性的、软件密集性系统的集合，这些系统满足特定的市场需求或任务需求，并且按预定义的方式从一个公共的核心资产集开发得到

什么是软件产品线架构：所谓软件产品线架构，是针对一个公司或组织内的一系列产品而设计的通用架构。这一系列产品必须有很多相似性，从而它们可以共享同一个架构和部分具体实现，提高生产率

产品线架构和单个产品架构的区别何在：产品线架构必须考虑一系列明确许可的变化

产品线架构一定要文档化，必须提供“产品创建者指南”，描述架构的实例化过程

在实践中，软件产品线架构除了定义组成产品的各部分的职责，以及它们之间的交互之外，往往还将系列产品共用的模块事先实现，供直接重用；有时还将架构设计方案用框架的形式予以实现，供定制使用。此时，软件产品线架构就有了一个流行的名字：平台。

**软件维护：**

![x](./Resource/39.png)

**软件架构重构：**

- what：指对软件架构进行比较大的修改和调整，使它适应新需求及开发和维护的需要。
- why：1、架构太混乱了，以致进行一个小修改都会牵动全身；2、将要进行的软件升级力度很大，原先的架构己不再适应新需求了

软件架构重构属于“再工程(Reengineering)”的一种情况，一般会经历逆向工程、重新规划、正向工程 3 个步骤

**软件开发流程：**

![x](./Resource/40.png)

**如何做好架构：**

架构设计不是孤立的节点，应该放在整个项目过程的大环境下来研究，针对每个关键节点对设计的影响特点进行研讨。

架构设计应该从方法论的角度、从质量属性对架构设计影响的角度、从建立可度量的架构质量保证体系以及安全性和可扩展性的角度，在理论和实践两方面全方位研究问题。

好的软件架构应当具有的品质：

- 良好的模块化：每个模块职责明晰，模块之间松藕合，模块内部高聚合并合理地实现了信息隐藏
- 适应功能需求的变化，适应技术的变化：典型地，应该保持应用相关模块和领域通用模块的分离，技术平台相关模块和独立于具体技术的模块相分离，从而达到“隔离变化”的效果
- 对系统的动态运行有良好的规划：标识出哪些是主动模块，哪些是被动模块一一面向对象中往往是主动类(Active Class)和被动类(Passive Class)，明确这些模块之间的调用关系和加锁策略，并说明关键的进程、线程、排队、消息等机制
- 对数据的良好规划：不仅应包括数据的持久化存储方案，还可能包括数据传递、数据复制和数据同步等策略
- 明确、灵活的部署规划：还往往涉及到可移植性、可伸缩性、持续可用性和互操作性等大型企业软件特别关注的质量属性的架构策略
- 时间就是系统架构设计的生命。架构设计并非“好的就是成功的”，而是“适合的才是成功的”

## 需求抽取与业务建模

**定义：**

什么是需求：产品为用户在特定的背景中所必须满足的约束。需求工程包括需求抽取、需求分析和需求管理

![x](./REsource/41.png)

**软件缺陷：**

软件的质量问题往往表现为缺陷（bug），软件缺陷的产生主要有两个原因：软件产品的特点（技术）和开发过程（管理）。

需求分析的不到位，是产生软件缺陷的最大原因。

**好需求？**

好的需求意味着需求、设计和实现可以通过一系列的迭代循环来实现，每次迭代都会得到一些有用的功能。如下图：

![x](./Resource/42.png)

**需求的主要内容：**

1. 功能性需求：为了向风险承担者提供的产品必须执行的动作；用户给定业务背景下必须要做的事情
2. 非功能性需求：描述了产品必需具备的属性和品质
3. 限制条件：全局性的需求，又称之为“约束条件”，它可以是项目本身的限制，或者是对产品最终设计的限制

**需求演进流程：**

项目开始：

1. 需求分析师、风险承担者研究场景及其它模型，讨论“业务需求”
2. 风险承担者对有助于自己工作的“最佳”产品做出决定，需求分析师编写“产品需求”，非功能性需求与限制条件一起被记录下来，不涉及技术
3. 需求交给设计者，添加“技术需求”，为构建者提供最终《设计规格说明书》

![x](./Resource/43.png)

**需求的过程定义：**

我们定义的过程是为了得到提交产品的一个指南，而不是一个一成不变的程序，更不是一个必须的“做事情的方式”，我们可以从中理解很多有用的事情，从而更有效、更准确地收集需求。

定义需求过程的本身，也是进行业务建模的一个训练，可以使用数据流图(DFD)表达。

![x](./Resource/44.png)

和所有高层图一样，图中并不需要表示面面俱到的内容，而只是把最重要的关系表达出来，细节可以通过过程的分解来达到。

![x](./Resource/45.png)

主要子过程

**项目启动**主要确定3件事：

- 产品实现的目标以及确定范围。
- 发现和确定主要风险承担者。
- 限制条件以及项目的可行性。

主要流程：

1、调查研究技术：事实上它是一个需求获取过程，在这个过程中，一定要注意不要把症状当成问题，我们必须关注真正的问题到底在哪里，以期找到业务上的问题症结所在。工具：鱼骨图

![x](./Resource/46.png)

2、范围定义：

（1）列出问题和机会：紧急程度、可见性、收益、优先权、可能方案等

（2）协商项目初步范围：可以描述成一个简单的列表，但不需要定义列表中的项目，也不十分关心精确的需求分析，尤其不关心任何费时的建模或者原型化。

（3）评估项目价值

（4）计划项目进度表和预算

（5）汇报项目计划

3、问题分析

除非你已经理解了它，否则不要试图修改它。通常包含如下任务：

- 研究问题领域：需要解决什么问题
- 分析问题和机会：通过因果分析得出对问题的真正理解
- 分析业务过程
- 制定系统改进目标
- 修改项目计划
- 汇报调查结果和建议：项目的目的不应该仅仅是解决问题，还要提供业务上的好处，如果存在这种好处，就必须度量它。

4、项目陈述

一般包括如下几个方面的考虑：

- 问题
- 机会
- 指示

具体陈述：

- 项目目标
- 项目概念
- 问题陈述
- 项目影响范围
- 项目构想
- 有关约束

网罗需求

项目启动后：

1、分析师学习确定的业务，并分解成一些业务用例；

2、让风险承担者密切参与，当产品特点被描述清后，分析师开始编写需求。

分析团队和用户一起工作，用户描述他们正在做以及他们希望做的工作，而分析师向用户咨询，使我们知道产品将来工作是什么样子的。

分析团队也可能需要帮助用户创造一个更好的工作方式，并且构造一个系统来支持这样更好的工作方式。基于这一点，可以举行有创造性的研讨会。

软件需求的引出有一系列的方法和共同活动的思想，下面是一些重要的引出方法：

- 找出工作的本质：不事先确定实现方式
- 解决正确的问题：避免华而不实
- 业务重组与创新的产品：CMMI
- 为需求制作原型
- 面谈：提出问题、选择面谈者、计划联系方式、进行面谈
- 需求项框架：需求卡片
- 业务用例研讨会：每个业务事件都有一个或多个风险承担者，他们是这部分工作的专家，他们对这个业务用例的输出有特别的兴趣。研讨会的目的，就是通过这些专家把业务用例相关的知识传授给需求分析师。JAD（联合应用开发）风格研讨会

  ![x](./Resource/47.png)

- 创造性研讨会
- 头脑风暴会议：通过收集会议成员的即兴想法，为具体问题找到解决方案。头脑风暴采用团队工作来产生想法和解决问题，这是一种群体决策技术，它的要点是，不进行评价或者解释说明，而是快速产生设想，任何设想都可以：离奇的、疯狂的或者不切实际的。会议结束后，再进行评价，而且不断地进行评价，把设想分为3类：有效的、可能的、似乎不是。
- 确定产品应该是怎样的：业务用例通常是工作对外界服务请求的响应，所以，优化的响应就是以最低的时间、原材料或工作量成本（从组织的角度来说），提供最有价值的服务（从顾客的角度来说）。需求分析师的任务是找到最佳的业务用例，最佳的业务用例总是最接近工作本质的那一个，有时候还包括一些创新。

**业务事件和业务用例：**

业务用例分析还是比较倾向于使用传统的面向过程需求分析，也就是把业务看成一个过程的集合体。

业务需求分析阶段：需求分析关注的是“什么”，而不是“如何”。

需求分析要做的事情是：

(1) 定义需求：包括功能性，以及非功能性需求。

(2) 排列需求的优先次序；

(3) 修改项目计划。

(4) 交流需求陈述。

过程模型研究的问题范围主要是建立业务用例，下面简单讨论一下面向过程分析的特点：

(1) 采用“抽象”和“分解”两个基本手段，用抽象模型的概念，按照具体业务内部数据传递、变换关系，由顶向下逐层分解，直到找到满足需要的所有可实现的业务元素为止。

(2) 采用“分解”的方式来理解一个复杂业务系统，“分解”需要有描述手段，数据流图(DFD)就是作为描述信息流程和分解的手段而引入的。

做学徒是获取业务用例的好方法：在实际中观察业务是如何工作的

业务的上下文范围与图

下面是客户支持系统的顶层关联图简单例子，其中箭头表示数据的流向

![x](./Resource/48.png)

- 过程分解：过程分解实际上是一种工作划分方法，不过，过程分解一般是一个事先方法，当过程定义清楚以后，所有的参与者都必须遵循这个过程。图示：

  ![x](./Resource/49.png)

  但是，仅仅靠过程分解是不够的，因为这时候的过程研究还是属于静态的、理解性的、事实上可能还是事先的，甚至是主观的。对工作的进一步理解和分析，还需要进行动态的，更加客观的、更加深入的分析，这就要考虑利用事件及其业务响应来建立过程模型。

- 业务事件：所有的系统或者工作都会对外部发生的事件做出响应，这些事件称为“业务事件”；对业务事件的响应称为“业务用例”。DFD 的细节称作片段，以事件为基础的片断可以组合到一个事件划分系统模型或者称为0 层图中去。其中，每个过程为一个事件的处理。

  ![x](./Resource/50.png)

- 为什么业务事件和业务用例是好想法：经验告诉我们，以客观的方式划分工作的价值，以及在规划解决方案之前先理解工作本身的价值，结果就会使我们发现真正的需求，而且会更快地发现它们。

  事件是一种非主观方式来划分工作的，也就是确定工作对外界的响应。不从内部看，而从外部看，这样我们就可以清楚地发现划分工作的最有效方式。

  业务事件指出了哪些东西是在一起配合工作的，从而我们可以提交一些内聚的部分，并且使这些部分的接口最小化。同时，这也可以使工作的这一部分成为详细需求调研的基础。这些部分的依赖性越少，分析师就越有可能关注于这部分的细节，而不需要知道其它部分。

  但是，使用业务用例最重要的原因，是研究业务事件到来的时候到底发生了什么。分析师必须超越那些显然的东西，这意味着理解工作真正的本质。我们建议通过一个非正式的过程来发现业务事件。

- 发现业务事件：业务事件是发生的一些事情，这些事情让工作作出某种反应，他们发生在工作的范围之外，或者是某个时间到达的时候。

### 示例：订单处理子系统

问题陈述：

项目名称：电源设备订单处例子系统
系统目标	1、客户直接利用因特网购买电源设备，客户选择设备，设备分为普通不间断电源、服务器专用不间断电源和专业级不间断电源加自主供电设备等。
2、客户可以选择标准配置，也可以在线建立自己的配置。
3、可配置的构件显示在一个下拉列表中，对每一种配置，系统可以计算价格。
系统要求	1、发出订单时，客户需要填上运送和付款信息，系统可接受的付款方式为信用卡和支票，一旦订单输入，系统将向客户发送一个确认e-mail 信息，并且附上订单细节，在等待电源设备送到的时候，客户可以在任何时候在线查到订单状态。
2、后端订单处理包括下面所需的步骤：由客户服务子系统提供这个客户的等级以及根据等级和促销策略计算出的相扣方式应折，验证客户的信任度和付款方式，向仓库请求所订购的配置，打印发票，并且请求仓库将电源设备运送给客户。

		上下文图：

![x](./Resource/51.png)

	大多数事件图包括一个单一过程，并且需要说明以下内容：
	1）输入及输入来源，来源被描述为外部代理。
	2）输出及输出目的地，目的地被描述为外部代理。
	3）必须读取记录的任何数据存储都应该被加入到事件图中，事件流应该加入命名。
	4）对数据的任何增、删、改、查都应该加入到事件流中，事件流应该加入命名。
	一个简化的“订单处理子系统”的过程事件图如下。

参与者	事件（或者用例）	触发器（输入）	响应（输出）
客户	选择产品（由Web 页面驱动）	产品查询	生成“目录描述”
客户	发出订单	新客户订单	生成“客户订单确认”，在数据库中创建“客户订单”和“客户订购的产品”。
客户	修改订单	客户订单修改请求	生成“客户订单确认”，修改数据库中“客户订单”和“客户订购的产品”。
客户	取消订单	客户订单取消	生成“客户订单确认”，在数据库中逻辑的删除“客户订单”和“客户订购的产品”。

	建议在项目的启动阶段就开始确定这些业务事件的过程，那时候风险承担者都在，他们都非常熟悉这些业务事件。但是需求分析师的兴趣在于工作是事件的响应，这就是对业务用例的分析。
产品用例与关注点捕获
	所谓产品用例，指的是站在产品的角度，仔细的研究和分析客户业务如何与产品融合，我们可以用用例和用例图来表达产品用例，这也是需求分析的重要部分。
	产品用例必须基于最初的业务事件和业务用例。

![x](./REsource/52.png)

用例图
	用例图主要表现各个用例之间宽泛的关系，而且主要表达技术层面的事情。

![x](./Resource/53.png)

	在“处理销售”用例中，为什么主要参与者是收银员而不是顾客呢？这和系统边界有关，我们定义的销售系统边界，服务目标是收银员。如果把系统边界定义为企业交款服务，那顾客就是一个主要参与者了。

![x](./Resource/54.png)

	用例的一个场景（说故事），用来研究一部分工作的分步骤情节，而这个情节或者情景必须用规定的格式来描述。用例事件流所应该包含的内容：
	简要说明：描述该使用案例的作用（可以不写出）。
	前置条件：开始使用该用例之前必须满足的系统和环境的状态和条件（必要条件而不是充分条件）。
	主事件流：用例的正常流程（事件流是关注系统干什么，而不是怎么干），也称为用例的路径。可能包含有基本路径、备选路径、异常路径、成功路径和失败路径等几个方面的内容。
	其它（备选）事件流：用例的非正常流程，如错误流程。
	后置条件：用例成功结束后系统应该具备的状态和条件（但不是每个用例都有后置条件）。
	用例模版示例：

![x](./Resource/55.png)

	对于较大的系统，可以把用例模型划分到不同的用例包里面去，每个包包含针对一组参与者的一组用例，形成一个个的功能区。
	用例的场景是利用事件流，以此可以实现用例的实例，用例事件流的描述文档前面已经讨论过，当文本不能很好的描述的时候，可以使用活动图或者流程图来表达。
	对于某些交互序列重复发生的事件流，可以把这些部分独立描述，定义成子事件流，而子事件流的引用，可以使用超级链接等实现技术来完成它。
	设想一个“酒店管理系统”的简单例子，我们描述一下场景（事件流）的文档，主要表达的是对子事件流的引用。

![x](./REsource/56.png)

	这种用例文档也可以用可视化的方式表达，比如下面的方式。

![x](./Resource/57.png)


	一般来说，如果需要概要的讨论系统中的用例，在抽象级别展现系统功能的关系，可以使用椭圆符号，这也是 UML 的标准符号。如果需要展现一个或者几个事件流的细节，比如在需求讨论会上，类元的标识符号更加合理，尽管它不是UML 标准符号，但实践中非常有用。
	在用例分析的时候，还需要避免在基础用例上分解出更小的用例，这称为“功能分解”，这是要避免的，因为一般情况过细的分解并不能向涉众提供真实的价值，而且很可能掉进分解的陷阱。如果发现有200 个用例，一般已经掉进了功能分解的陷阱。所以，用例分解的时候一定要参考用户需要获取什么价值。
	在用例建模的时候，不同用例之间的关系如下：
	包含（include）
	泛化（generalization）
	扩展（extend）

![x](./Resource/58.png)


	扩展用例包括一个或者多个扩展事件流，扩展事件流与备选事件流很相似，只不过它是在另一个用例中添加行为

![x](./Resource/59.png)


	对于不同用例的相似步骤，可以把这些公共事件抽取出来，放在被包含的用例中，其它用例可以引用这些被包含用例中的事件流。

![x](./Resource/60.png)


	{basic}标签表示这个事件可以由参与者启动，{sub}标签表示这个事件流只能被其它事件流包含或者引用

![x](./Resource/61.png)


	泛化与类的泛化意义相同，表达用例之间存在“is-a-kind-of”关系。一般父用例是抽象的，而子用例将继承父用例的特性。

![x](./Resource/62.png)

![x](./REsource/63.png)

	事件流执行的规则如下：实例化首先出现在子用例中，沿着基本事件流运行，如果子用例没有定义基本事件流，则沿着父基本事件流执行

![x](./Resource/64.png)


	理解涉众真实的关注点，是软件开发获得成功的关键，关注点源于不同的角色，并可能与系统的不同的方面相关。如何才能满足这些关注点，用例为描述系统提供了一种简单的方法，把用例分成两种主要的类型，它们是应用用例（application use case）和基础结构用例（infrastructrue use case）。
	应用用例描述用户如何与系统交互以实现预期的功能，而基础结构用例描述的是应用用例的每一步，如何添加诸如可用性、可靠性、性能、容错性等质量属性。
如何理解涉众关注点
1、理解问题域
	系统能够正确地反映问题域是非常重要的，这可以把问题用“类”来描绘，这就是概念类或者称之为领域类，为这样的问题建模，称之为领域建模。
	“酒店管理系统”的简化的领域模型：

![x](./Resource/65.png)

	领域建模目的是通过对核心业务场景的分析，标示出系统必须保存与维护的那些信息，这样的模型只需要捕获核心概念及关系，并不需要向数据库设计中数据建模那样的过于考究细节，这个工作可以放在以后进行。
2、抽取系统特性
	系统关键特性列表

![x](./Resource/66.png)

	渐进式的得到用例的功能性需求：

![x](./Resource/67.png)

	为了发现最重要的用例，需要对用例的重要性或者开发风险进行评估，可以采用用例分级和评估矩阵来做这个初步分析，数据的来源可以采用项目相关人员和开发团队打分法来完成。

![x](./Resource/68.png)

	2000年以后，软件产品走上了规模经济的时代，随着产品规模的上升，软件组织已经有可能改善投资回报（ROI）。伴随着非常大型的项目，软件组织将达到更好的经济规模。正是这种规模软件经济的理念，在分析与设计方法的思路上，提出了和过去完全不同的要求，重用、复用和变更成为一个重要的主题。

![x](./Resource/69.png)


从需求开发到架构设计
需求开发向设计规划的转化
一、需求和进度安排
二、需求和预估
三、从需求到设计和编码
构造弹性软件架构
	架构师应该致力于标识系统的关键用例来构建架构，通过分析这些关键用例，可以创建一个弹性架构，也就是说各个不同类型的关注点保持独立，而系统中的一部分发生变化的时候，对其余部分的影响要最小。
一、好的架构的特点
1、分离功能性需求
2、从功能需求中分离出非功能性需求
3、分离平台特性
4、把测试从被侧单元中分离出来
二、建立架构基线的步骤
1、架构基线
	架构是最终系统的一个早期版本，也称之为架构基线。架构基线是整个系统的子集，我们称之为骨架系统（skinny system）
2、用例驱动的架构基线
	架构基线是由关键用例子集驱动建立起来的，我们称这个子集为架构重要用例。
	在识别用例中，确认哪些是最重要的，所谓“重要”，意味着它们组合在一起，可以覆盖所有需要作出的关键决策
	识别用例和描述用例区别：
	识别用例是对系统需要做的事情进行界定、探索和发现。
	描述用例是对用例中的流程和步骤进行细化。
	描述用例会贯穿项目的整个个生命周期，而识别用例则必须尽可能尽早的完成。
3、迭代地建立架构基线
	每次架构迭代中需要全面的考虑所有关注点。
	迭代一直需要持续到所有的架构关注点都已经解决。
	伴随着架构基线的产生需要一个架构描述文档
	架构描述必须经过评审，还应该附上一张修定表说明历史演变，同时它也说明了重要的决策
系统设计的应用架构策略
	两种最常用的策略方法
一、企业应用架构策略
	作为战略信息系统规划项目的一部分，期望每个信息系统开发项目都根据这个架构使用或者选择技术
二、战术应用架构策略
	没有企业级应用架构时，项目自定义的架构。对于开发人员使用新技术有更大的自由度
模块化架构设计策略
一、概念
	模块：数据说明、可执行语句等程序对象的集合，是单独命名的并且可以通过名字来访问，例如过程、函数、子程序、宏等。
	模块化：软件被划分成独立命名和可独立访问的被称作模块的构件，每个模块完成一个子功能，它们集成到一起可以满足问题需求。
	注意事项：随着模块数量的增加，开发成本减低，但是系统集成的成本增加。所以模块数量要适当
二、实现手段
	1、抽象：抽出事物的本质特性而暂时不考虑它们的细节。
	2、信息隐蔽：一个模块内包含的信息（过程和数据）对于不需要这些信息的模块来说，是不可访问的。
	模块独立性问题：
	1、模块独立是指开发具有独立功能而且和其它模块之间没有过多的相互作用的模块。
	2、模块独立的意义：
		1）功能分割，简化接口，易于多人合作开发同一软件；
		2）独立的模块易于测试和维护。
	3、模块独立程度的衡量标准：
		1）耦合性：对一个软件结构内不同模块间互连程度的度量。
		2）内聚性：标志一个模块内各个处理元素彼此结合的紧密程度，理想的内聚模块只做一件事情。
	耦合分类：
	1、无任何连接：两个模块中的每一个都能独立地工作而不需要另一个的存在（最低耦合）。
	2、数据耦合：两个模块彼此通过参数交换信息，且交换的仅仅是数据（低耦合）。
	3、控制耦合：两个模块之间传递的信息有控制成分（中耦合）。
	4、公共环境耦合：两个或多个模块通过一个公共环境相互作用：
		1）一个存数据，一个取数据（低耦合）；
		2）都存取数据（低--中之间）。
	5、内容耦合（一般比较高）：
		1）一个模块访问另一个模块的内部数据；
		2）两个模块有一部分程序代码重叠；
		3）一个模块不通过正常入口而转移到另一个的内部；
		4）一个模块有多个入口（意味着该模块有多个功能）。
	内聚分类：
	1、功能内聚：一个模块完成一个且仅完成一个功能（高）。
	2、顺序内聚：模块中的每个元素都是与同一功能紧密相关，一个元素的输出是下一个元素的输入（高）。
	3、信息内聚：模块内所有元素都引用相同的输入或输出数据集合（中）。
	4、时间内聚：一组任务必须在同一段时间内执行（低）。
	5、逻辑内聚：一组任务在逻辑上同属一类，例如均为输出（低）。
	6、偶然内聚：一组任务关系松散（低）。
	设计原则：
	1、力争尽可能弱的耦合性：尽量使用数据耦合，少用控制耦合，限制公共环境耦合的范围，完全不用内容耦合。
	2、力争尽可能高的内聚性：力争尽可能高的内聚性，并能识别出低内聚性。
面向构件的方法
一、方法简述
	构件也称为组件，面向构件的方法包含许多关键理论：
	1、构件基础设施
	2、软件模式
	3、软件架构
	4、基于构件的软件开发
	四点原则：封装、多态、后期绑定、安全
	在构件方法中完全摒弃了继承而是调用，在构件术语里，这些调用称作“代理”（delegation）。
	构件利用组装来创建系统，在组装的过程中，可以把多个构件结合在一起创建一个比较大的实体，如果构件之间能够匹配用户的请求和服务的规范，它们就能进行交互而不需要额外的代码，这通常被称之为“即插即用”（Plug-and-Play），是后期绑定的一种形式。
	最近几年兴起了面向服务的架构(Service Oritented Architecture，SOA)，它能帮助企业有效地使用IT资源，使IT系统灵活配合业务需求。为了使客户能够更加简单地实现向面向服务架构的转变，现在提出了一种新的服务构件模型。它提供了一种统一的调用方式，从而使得客户可以把不同的构件都可以通过一种标准的接口来封装和调用。这种服务构件的编程模型可以大大简化客户的编程，提高应用的灵活性，这就是面向服务构件的架构SCA(Service Component Architecture，SCA)。
二、面向构件的软件模式
	基于面向构件的架构可以描述为：系统=框架+构件+组建。
	面向构件技术将把软件开发分成几种：框架开发设计、构件开发设计、组装
高层设计中的架构分析
	架构分析是在功能性需求过程中，识别非功能性需求（质量需求）的活动，这些信息对于架构设计来说，是最值得关注的。
	架构分析的一个重要目标，是了解架构因素的影响、优先级和可变性。因此，大多数架构方法，都提倡对以下信息建立一个架构因素表。

![x](./Resource/70.png)


	在用例中，特殊需求、技术变化、未决问题应该被反复审核。其隐含或者清晰的架构因素要被统一整理到补充规范里面去。

![x](./Resource/71.png)


	不管目前架构决策的原则有多少，事实上所有的架构方法都推荐记录；这些记录按不同的的形式或者完善程度，被称之为：技术备忘录。

![x](./Resource/72.png)


高层架构设计中的层模式
    概念：
	层模式是构造弹性架构的基础，好的架构几乎都是在层这个模式基础上建立起来的；但是分层不是目的，分层必须把分离性与易变性、灵活性结合起来。
	层为逻辑架构定义了一个N层模型，称之为分层架构（Layers Architecture），它作为模式得到了极为广泛的应用和引述。
	实践：我们一般使用成熟的框架来实现分层架构模式！
	示例：

![x](./Resource/73.png)


面向服务架构（SOA）
	概念：
	面向服务的架构 (Service-Oriented Architecture SOA)是一种形式化的分离服务的架构风格。
	面向服务的架构关注的是哪些是服务向用户提供的功能，哪些是需要这些功能的系统，这种分离，使用一种服务合约（Service Contract）的机制来完成。
	实践:
	最常用的SOA是用Web Service来实现。这主要因为Web Service的独立于平台的特性和其特性更符合SOA的规则。
	规则：
	服务具有明确的接口（合约）与策略。
	服务通常代表业务功能或者领域。
	服务拥有模块化的设计。
	服务被松散的耦合在一起。
	服务是可以被发现的。
	服务的位置对客户是透明的。
	服务是独立于传输层的。
	服务是独立于平台的。
用例驱动与基于方面的架构设计
	概念：
	面向方面（Aspect-Oriented）的方法
	面向方面的软件开发（AOSD），目标是，使功能性需求、非功能性需求、平台特性等许多不同的关注点更好的模块化，从而使它们互相独立，并且一直延伸到软件开发的全过程。
用例驱动的分析模型
	分析模型是说明问题域里（对建模者来说）有意义的分析类
	概念：
	我们设计一个系统，总是希望它能解决一些问题，这些问题总是会映射到现实问题和概念。对这些问题进行归纳、分析的过程就是分析建模。
	好处：
	1、通过建立分析模型能够从现实的问题域中找到最有代表性的概念对象
	2、发现出其中的类和类之间的关系，因为所捕捉出的类是反馈问题域本质内容的信息。
	实践：
	经典的面向对象分析的步骤，是把一个相关的领域，分解为单个分析类或者对象；分析模型是分析类或者是我们感兴趣的现实对象的可视化表示，它们也被称之为：概念模型、领域对象模型、分析对象模型等。
	3种分析类：
	边界类
	实体类
	控制类

![x](./Resource/74.png)


	3种分析类之间交互规则：

![x](./Resource/75.png)


	1、用例的参与者只能与边界对象交互（这相当于结构化分析里面的自动化边界）
	2、边界对象只能与控制对象和动作者交互（即不能直接访问实体对象）
	3、实体对象只能与控制对象交互
	4、控制对象可以和边界对象交互，也可以和实体交互，但是不能和动作者交互
	示例：两个分析类 Payment（支付）Sale（售出）在分析模型中以一种有意义的方式关联。

![x](./Resource/76.png)


	分析类可以按照它的符号、内涵和外延来考虑。
	符号：代表一个分析类的单词或者图片。
	内涵：分析类的定义
	外延：分析类定义的一组实例。

![x](./Resource/77.png)

![x](./Resource/78.png)

设计和实现模型

从分析模型到设计模型：

![x](./Resource/79.png)

	当我们实现一个用例的时候，必须表示出所需要的类，以及这些类的特性（属性、方法和关系），如果我们引进一个“用例切片”的概念，这个切片把功能实现部分放在一个模型中（设计模型），而通用的和复用的部分则保存在一种非特定用例部分中，把所有这些切片的叠加将构成系统的设计模型。

![x](./REsource/80.png)

![x](./Resource/81.png)


	基于所有针对各个用例的不同模型的切片进行工作，就可以把这些切片放到一个单独的包中，我们称这样的包为“用例模块”。
	
	<<trace>>依赖关系，表明上游模型得出的一个下游模型存在着一些规则
	用例模块之间的关系：

![x](./Resource/83.png)

![x](./Resource/84.png)

![x](./Resource/85.png)


使用方面技术解决关注点分离问题
对等（peer）关注点
	概念：
	所谓对等关注点，就是关注点相互独立，其重要性也不能相互比较。
	问题：
	构件在保持对等关注点分离方面的局限性，结果就是结构的混乱状态和分散。

![x](./Resource/86.png)


扩展（extension）
	概念：
	扩展是在基础（base）构件上定义的构件，用来表示附加的服务或者功能。
	问题：

![x](./Resource/87.png)


分离关注点的解决方案
	基础：
	1、关注点分离技术（Concern Separation Technique）
	2、关注点合成机制（Concern Composition Mechanism）
	典型：
	面向方面是使横切关注点更好的分离的一组技术，所以有时候也称高层关注点分离。而AOP提供了面向方面的实现基础，比较典型的是Java 语言的一个扩展AspectJ。
	实践：
	通过叠加用例切片来构建系统：

![x](./Resource/88.png)


	使用对等用例保持分离：

![x](./Resource/89.png)

	使用扩展用例保持分离：

![x](./Resource/90.png)

![x](./Resource/91.png)


基于质量属性的架构设计
质量度量模型与质量属性场景
三层软件质量度量模型
	ISO 9126把软件质量定义为“与软件产品满足声明的或隐含的需求能力有关的特性和特性的总和”，可以分为6 个特性，即：功能性、可靠性、效率、可使用性、可维护性以及可移植性。
	软件质量模型包括3 层，即高层：软件质量需求评价准则(SQRC)；中层：软件质量设计评价准则(SQDC)；低层：软件质量度量评价准则(SQMC)。

![x](./Resource/92.png)

	ISO 9126 标准也定义了评价软件质量的过程：

![x](./Resource/93.png)

软件架构质量属性的场景

![x](./Resource/94.png)

可靠性质量解决方案
一、可靠性质量属性场景
	系统的可靠性一般定义成系统正常运行的比率：
	α = 平均正常工作时间/（平均正常工作时间+平均修复时间）
二、健康监测
	1、命令/响应（ping/echo）
	2、心跳（dead man）计时器
	3、异常
三、错误恢复
	1、表决
	2、主动冗余（热重启）
	3、被动冗余（暖重启/双冗余/三冗余）
	4、备件
	5、shadow操作
	6、状态再同步
	7、检查点/回滚
四、错误预防
	1、从服务中删除
	2、事务
	2、进程监视器
基于高可靠性的架构设计
一、进程间提升可靠性的方法
	大型系统一般是按照多处理器环境设计的，逻辑上组成处理器组，处理器组的目的是运行一个或者多个应用程序的副本，这一思想对于支持容错性和可靠性是非常重要的。在多个运行副本中，一个为主，称为主地址空间（PAS），其它的为辅，称为备用地址空间（SAS）。

![x](./Resource/95.png)

软件架构设计过程

打造有效的架构设计过程
一般的软件过程：项目经理、架构师、开发人员、测试人员等所有人共同遵守的过程，是一个在许多方面都“大而化之”的“公共软件过程”。 阶段图如下所示：

![x](./Resource/96.png)



参考书目：
	《软件架构设计》
《架构即未来 2.0》

架构是一个过程，而非一个结果。
在大多数人的谈论中，架构是一个目标产物，而作为架构师的责任就是去生产它。所以无论如何，架构是可以"做"出来的，而且也应该有一些"做"的方法、技术、技巧。
有人问过我：架构的最主要产出是什么？我的答案是:图。这里面有两层含义:一层含义是如同建筑师描绘的蓝图一样，用于引导实施者；另一层含义是架构师头脑中清晰的目标系统。如果架构师头脑中没有系统清晰的图像，他是没有办越把它画出来的。
要知道与代码不同的是，"虚幻"的架构常常让人认为其有很多玄妙之处，只因它大多难以落在纸上。特别是与很多大师谈及架构时，经常落入他们的一些"陷阱"，并往往为自己达不到大师的精明与技巧而叹息。殊不知，被我们所津津乐道的这些架构，是他们在日常工作里经历了大量的错误、重复的尝试、无数的代码、长久的考验所积淀下来的只言片语。
美丽至简。美丽的架构应尽可能简单，但不要过于简单。很多大型的软件架构，从大型的电信网络管理系统，到大规模应用的互联网架构，以及企业级的ERP软件，系统总是遵循从无到有，从简单到复杂，再到简单这样的过程。最终，支撑这些大型系统稳定可靠运行的就是这个最基本的道理。美丽的架构应尽可能精益，并且是演进式发展的。当你架构一个亿万人同时在线的大规模网站系统的时候，你无法从一开始就提供最完善的解决方案，它应该是随着用户的增长而可扩展的。精益的思想让你避免了过度设计，也使架构不断演进，趋于完美。
那么如何设计出美丽的架构呢？从代码逻辑到物理网络，从单机到分布式，无数的技术可供架构师选择，如分层、组件化、服务化、标准化、缓存、分离、队列、复制、冗余、代理等，不过它们仍然只是"术"的范畴，而何时何处如何恰到好处地使用它们才是"道"的范畴，比如顿悟变化的道理，在博弈中寻找平衡，以系统化的角度来分析问题，寻找相对与绝对的奥秘、开放的心态……
虽然人们常用建筑架构设计来类比软件架构，但音乐作曲可能是更好的类比。建筑师创建的是相对静止的结构(该架构必须考虑到人员和服务在建筑内的移动，以及承重结构)的静态描述(蓝图或其他图纸)。在音乐作曲和软件设计中，作曲家(软件架构师)创建一段音乐的静态描述(架构描述和代码)，这段音乐以后将演奏{执行)许多次。在音乐和软件中，设计都依靠许多组件的交互来得到期望的结果，结果依赖于演奏者、演奏环境，以及演奏者所傲的诠释。
架构概述
架构师必须做出许多设计决定。要想有用，这些决定必须用文档记录下来，这样就能够进行复审、讨论、修改和批准，然后作为后续决定和构建时的约束。对于软件系统，这些设计决定包括行为上的和结构上的。
外部行为描述展示了产品如何与它的用户、其他系统和外部设备进行交互，这应该表现为需求。结构描述展示了产品如何划分为多个部分，以及这些部分之间的关系。我们还需要内部行为描述，用于描述组件之间的交互接口。结构上的描述常常展示相同部分的一些不同视图，因为不可能把所有信息以有意义的方式组织到一张图纸或一份文档中。一个视图中的组件，可能是另一个视图中一个组件的一个部分。
软件架构常常表现为分层的层次结构，这种层次结构将几种不同的结构放在一张图中。20世纪70年代， Parnas指出"层次结构"这个术语已经被滥用，然后精确地定义了它，并给出了几个不同结构的例子，它们在设计不同系统时实现了不同的目的(Parnas 1974)。将架构的结构描述为一组视图(view)，每个视图关注不同的部分，现在已成为了广泛接受的标准架构实践(Clements等2003; IEEE 2000)。我们将使用"架构"这个词来代指一组有标注的图纸和功能描述，它说明了设计和构建一个系统时所使用的结构。
一个程序或计算系统的软件架构是系统的一种结构或一组结构，它包含软件元素、这些元素的外部可见的属性，以及元素之间的关系。
"外部可见"的属性是其他元素对该元素可以做出的假定，诸如它提供的服务、执行时的特征、错误处理、共享资源的使用等。
架构是系统设计的一部分，它突出了某些细节，并通过抽象省略掉另一些细节。所以，架构是设计的一个子集。关注实现系统组件的开发者可能不会特别关心所有组件如何装配在一起，而是主要关注少数组件的设计和开发，包括他们必须遵守的架构约束和可以应用的规则。因此，开发者和架构师面对的是系统设计的不同方面。
如果说架构关注的是组件之间的关系和系统组件外部可见的属性，那么设计还要关注这些组件的内部结构。例如，如果一组组件包含了一些信息隐藏的模块，那么这些外部可见的属性就构成了这些组件的接口，内部的结构与模块内的数据结构和控制流一同考虑。
软件架构师的首要关注点不是系统的功能。
架构师的一项职责是确保系统设计能满足客户的需要，我们将利用品质关注点来帮助我们理解这些需要。
成功架构师的两项关键实践：让利益相关人参与以及同时关注功能和品质。作为一名架构师，你首先问我们想从系统中得到什么，有怎样的优先级。在实际项目中，你会找出其他的利益相关人。典型的利益相关人和他们的关注点包括：
	投资人，他们想知道项目是否能够在给定的资源和进度约束下完成。
	架构师、开发人员和测试人员，他们首先考虑的是最初的构建和以后的维护与演进。
	项目经理，他们需要组织团队，制定选代计划。
	市场人员，他们想通过品质特点实现与竞争者的差异化。
	用户，包括最终用户、系统管理员，以及安装、部署、准备、配置人员。
	技术支持人员，他们关注帮助平台电话呼入的数目和复杂性。
每个系统都有自己的品质关注点。有些关注点可能定义得很好，如性能、安全、可伸缩性等。但是，另一些同样重要的关注点却可能没有详细规定，如可变性、可维护性和可用性等。利益相关人希望把功能放到软件上，而不是放到硬件上，这主要是为了很容易、很快速地修改，然后通常在品质关注方面又对可变性轻描淡写。这很奇怪，不是吗？哪些改变能够迅速、容易地实现，哪些改变需要花时间并且很难实现，架构决定将对此产生重要影响。所以，架构师难道不应该在理解功能需求的同时，也理解利益相关人在"可变性"这样的品质方面的期望吗？
当架构师理解了利益相关人的品质关注点之后，接下来该做些什么？考虑折中。例如，对信息加密将加强安全性，但会损失性能。利用配置文件将增加可变性，但会降低可用性，除非我们能够验证配置是有效的。我们是否应该对这些文件使用标准的表示方式，如XML，还是使用自己发明的格式？创建系统的架构将在涉及许多这样的艰难折中。
这里有一份完整的架构师关注点清单，每个关注点都以问题的方式表述，架构师在项目过程中可能需要考虑它。当然，具体系统会有其他关键的关注点。

![x](./Resource/97.png)

那么，好的架构师如何来处理这些关注点？我们曾经提到过，需要将系统组织成一些结构，每种结构都定义了特定类型的组件之间的具体关系。架构师的主要关注点就是对系统进行组织，让每种结构有助于解答一个关注点所定义的问题。关键的结构决定将产品划分为组件，并定义了这些组件之间的关系。对于任何产品，都有许多结构需要设计。每种结构都必须单独设计，这样它就表现为一个独立的关注点。在接下来我们会讨论一些结构，你可以利用它们来考虑前面列表中的关注点。

![x](./Resource/98.png)


架构师玩的是折中的游戏。对于一组给定的功能需求和品质需求，没有唯一的正确架构和唯一的“正确答案”。
软件设计的关键品质是内聚和耦合。这不是什么新奇的"面向对象"概念，自从20世纪70年代出现结构化设计开始，开发者对这一概念已经谈论了许多年。我们的目标是通过设计使系统的组件具备下列品质：
高内聚(Strong cohesion)
内聚是一个测量指标，说明相关的功能如何聚集在一起，模块内的各部分作为一个整体工作得如何。内聚性是将模块粘成一个整体的胶水。
弱内聚的模块是不良分解的信号。每个模块都必须具有清晰定义的角色，而不只是一堆不相关的功能。
低耦合(Low coupling)
耦合是模块之间独立性的测量指标一一它们之间进出"电线"的数量。在最简单的设计中，模块几乎没有什么耦合，所以彼此间的依赖关系较少。
显然，模块不能够完全解耦，否则它们将根本不能够一起工作!
模块之间的联系有多种方式，有的是直接的，有的是间接的。模块可以调用其他模块中的函数，或被其他模块所调用。它可能使用其他模块提供的Web服务或设施，可能使用其他模块的数据类型，或提供某些数据让其他模块使用(可能是变量或文件)。
好的软件设计会限制通信的线路，只提供那些绝对需要的。这种通信线路是确定架构的一部分因素。

分布式设计


稳定性 & 高可用
可靠的系统是业务稳定、快速发展的基石。那么，如何做到系统高可靠、高可用呢？下面首先讲一下高可用需要面临的常见问题，再从技术方面介绍几种提高系统可靠性、可用性的方法。
高可用方法论
下面的表格里，列出了高可用常见的问题和应对措施。

问题	典型案例	增大 MTBF	减小 MTTR
程序、配置 Bug	程序、配置 Bug	提升研发、测试质量，灰度发布	监控告警、快速回滚
机器、机房故障	宕机、机房断电	硬件冗余、多机房	自动故障转移，切流到其他冗余机器、机房
突发流量	上游系统异常重试、外部攻击	上游系统容错调度防雪崩、流量配额、防攻击、防抓取	其他同容量不足
容量不足	主流程容量不足	容量规划、容量预警	限流、降级、熔断弱依赖、快速扩容
依赖服务故障	依赖服务失败率高、超时严重	弱依赖降级解耦，强依赖递归使用前述方法增强可靠性	熔断弱依赖
扩展
扩展是最常见的提升系统可靠性的方法，系统的扩展可以避免单点故障，即一个节点出现了问题造成整个系统无法正常工作。换一个角度讲，一个容易扩展的系统，能够通过扩展来成倍的提升系统能力，轻松应对系统访问量的提升。
一般地，扩展可以分为垂直扩展和水平扩展：
1、垂直扩展：是在同一逻辑单元里添加资源从而满足系统处理能力上升的需求。比如，当机器内存不够时，我们可以帮机器增加内存，或者数据存不下时，我们为机器挂载新的磁盘。 
垂直扩展能够提升系统处理能力，但不能解决单点故障问题。
优点：扩展简单。
缺点：扩展能力有限。
2、水平扩展：通过增加一个或多个逻辑单元，并使得它们像整体一样的工作。 
水平扩展，通过冗余部署解决了单点故障，同时又提升了系统处理能力。
优点：扩展能力强。
缺点：增加系统复杂度，维护成本高，系统需要是无状态的、可分布式的。
	可扩展性系数 scalability factor 通常用来衡量一个系统的扩展能力，当增加 1 单元的资源时，系统处理能力只增加了 0.95 单元，那么可扩展性系数就是 95%。当系统在持续的扩展中，可扩展系数始终保持不变，我们就称这种扩展是线性可扩展。
在实际应用中，水平扩展最常见： 
1. 通常我们在部署应用服务器的时候，都会部署多台，然后使用 nginx 来做负载均衡，nginx 使用心跳机制来检测服务器的正常与否，无响应的服务就从集群中剔除。这样的集群中每台服务器的角色是相同的，同时提供一样的服务。 
2. 在数据库的部署中，为了防止单点故障，一般会使用一主多从，通常写操作只发生在主库。不同数据库之间角色不同。当主机宕机时，一台从库可以自动切换为主机提供服务。
隔离
隔离，是对什么进行隔离呢？是对系统、业务所占有的资源进行隔离，限制某个业务对资源的占用数量，避免一个业务占用整个系统资源，对其他业务造成影响。
隔离级别按粒度从小到大，可以分为线程池隔离、进程隔离、模块隔离、应用隔离、机房隔离。在数据库的使用中，还经常用到读写分离。 
1. 线程池隔离：不同的业务使用不同的线程池，避免低优先级的任务阻塞高优先级的任务。或者高优先级的任务过多，导致低优先级任务永远不会执行。 
2. 进程隔离：Linux 中有用于进程资源隔离的 Linux CGroup，通过物理限制的方式为进程间资源控制提供了简单的实现方式，为 Linux Container 技术、虚拟化技术的发展奠定了技术基础。在工作中的实际应用，可以看看这篇文章：日志压缩资源消耗优化: Linux CGroup 的使用。 
3. 模块隔离、应用隔离：很多线上故障的发生源于代码修改后，测试不到位导致。按照代码或业务的易变程度来划分模块或应用，把变化较少的划分到一个模块或应用中，变化较多的划分到另一个模块或应用中。减少代码修改影响的范围，也就减少了测试的工作量，减少了故障出现的概率。 
4. 机房隔离：主要是为了避免单个机房网络问题或断电。 
5. 读写分离：一方面，将对实时性要求不高的读操作，放到 DB 从库上执行，有利于减轻 DB 主库的压力。另一方面，将一些耗时离线业务 sql 放到 DB 从库上执行，能够减少慢 sql 对 DB 主库的影响，保证线上业务的稳定可靠。
解耦
在软件工程中，对象之间的耦合度就是对象之间的依赖性。对象之间的耦合越高，维护成本越高，因此对象的设计应使模块之间的耦合度尽量小。在软件架构设计中，模块之间的解耦或者说松耦合有两种，假设有两个模块A、B，A依赖B：
1、第一种是，模块A和模块B只通过接口交互，只要接口设计不变，那么模块B内部细节的变化不影响模块A对模块B服务能力的消费。 
面向接口设计下真正实现了将接口契约的定义和接口的实现彻底分离，实现变化不影响到接口契约，自然不影响到基于接口的交互。
模块A和B之间的松耦合，主要通过合理的模块划分、接口设计来完成。如果出现循环依赖，可以将模块A、B共同依赖的部分移到另一个模块C中，将A、B之间的相互依赖，转换为A、B同时对C的依赖。
2、第二种是，将同步调用转换成异步消息交互。 
比如在买机票系统中，机票支付完成后需要通知出票系统出票、代金券系统发券。如果使用同步调用，那么出票系统、代金券系统宕机是会影响到机票支付系统，如果另一个系统比如专车系统也想要在机票支付完成后向用户推荐专车服务，那么同步调用模式下机票支付系统就需要为此而改动，容易影响核心支付业务的可靠性。
如果我们将同步调用替换成异步消息，机票支付系统发送机票支付成功的消息到消息中间件，出票系统、代金券系统从消息中间件订阅消息。这样一来，出票系统、代金券系统的宕机也就不会对机票支付系统造成任何影响了。专车系统想要知道机票支付完成这一事件，也只需要从消息中间件订阅消息即可，机票支付系统完全不需要做任何改动。
异步消息解耦，适合那些信息流单向流动（类似发布-订阅这样的），实时性要求不高的系统。常见的开源消息队列框架有：Kafka、RabbitMQ、RocketMQ。
限流
为什么要做限流呢？举一个生活中的例子，大家早上上班都要挤地铁吧，地铁站在早高峰的时候经常要限制客流，为什么呢？有人会觉得这是人为添堵。真是这样吗？如果不执行客流控制，大家想想会是什么场景呢？站台到处都挤满了乘客，就算你使出洪荒之力也不一定能顺利上车，且非常容易引发肢体碰撞，造成冲突。有了客流控制之后，地铁站才能变得秩序井然，大家才能安全上地铁。
一个系统的处理能力是有上限的，当服务请求量超过处理能力，通常会引起排队，造成响应时间迅速提升。如果对服务占用的资源量没有约束，还可能因为系统资源占用过多而宕机。因此，为了保证系统在遭遇突发流量时，能够正常运行，需要为你的服务加上限流。
常见的限流算法有：漏桶、令牌桶、滑动窗口计数。
分类
按照计数范围，可以分为：单机限流、全局限流。单机限流，一般是为了应对突发流量，而全局限流，通常是为了给有限资源进行流量配额。
按照计数周期，可以分为：QPS、并发（连接数）。
按照阈值设定方式的不同，可以分为：固定阈值、动态阈值。
漏桶算法
下面这张图，是漏桶的示意图。漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大时，会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。漏桶算法(Leaky Bucket)是网络世界中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。

![x](./Resource/99.png)


漏桶算法可以使用 Redis 队列来实现，生产者发送消息前先检查队列长度是否超过阈值，超过阈值则丢弃消息，否则发送消息到 Redis 队列中；消费者以固定速率从 Redis 队列中取消息。Redis 队列在这里起到了一个缓冲池的作用，起到削峰填谷、流量整形的作用。
令牌桶算法
对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。桶里能够存放令牌的最高数量，就是允许的突发传输量。

![x](./Resource/100.png)

Guava 中的限流工具 RateLimiter，其原理就是令牌桶算法。
滑动窗口计数法
计数法是限流算法里最容易理解的一种，该方法统计最近一段时间的请求量，如果超过一定的阈值，就开始限流。在 TCP 网络协议中，也用到了滑动窗口来限制数据传输速率。

![x](./Resource/101.png)


滑动窗口计数有两个关键的因素：窗口时长、滚动时间间隔。滚动时间间隔一般等于上图中的一个桶 bucket，窗口时长除以滚动时间间隔，就是一个窗口所包含的 bucket 数目。
滑动窗口计数算法的实现，可以查看这篇文章：降级熔断框架 Hystrix 源码解析：滑动窗口统计。
动态限流
一般情况下的限流，都需要我们手动设定限流阈值，不仅繁琐，而且容易因系统的发布升级而过时。为此，我们考虑根据系统负载来动态决定是否限流，动态计算限流阈值。可以参考的系统负载参数有：Load、CPU、接口响应时间等。
详细内容请看：基于系统负载的动态限流 dynamic-limiter。
降级
业务降级，是指牺牲非核心的业务功能，保证核心功能的稳定运行。简单来说，要实现优雅的业务降级，需要将功能实现拆分到相对独立的不同代码单元，分优先级进行隔离。在后台通过开关控制，降级部分非主流程的业务功能，减轻系统依赖和性能损耗，从而提升集群的整体吞吐率。
降级的重点是：业务之间有优先级之分。降级的典型应用是：电商活动期间关闭非核心服务，保证核心买买买业务的正常运行。
业务降级通常需要通过开关工作，开关一般做成配置放在专门的配置系统，配置的修改最好能够实时生效，毕竟要是还得修改代码发布那就太 low 了。开源的配置系统有阿里的diamond、携程的Apollo、百度的disconf。
降级往往需要兜底方案的配合，比如系统不可用的时候，对用户进行提示，安抚用户。提示虽然不起眼，但是能够有效的提升用户体验。
熔断
谈到熔断，不得不提经典的电力系统中的保险丝，当负载过大，或者电路发生故障时，电流会不断升高，为防止升高的电流有可能损坏电路中的某些重要器件或贵重器件，烧毁电路甚至造成火灾。保险丝会在电流异常升高到一定的高度和热度的时候，自身熔断切断电流，从而起到保护电路安全运行的作用。
同样，在分布式系统中，如果调用的远程服务或者资源由于某种原因无法使用时，没有这种过载保护，就会导致请求阻塞在服务器上等待从而耗尽服务器资源。很多时候刚开始可能只是系统出现了局部的、小规模的故障，然而由于种种原因，故障影响的范围越来越大，最终导致了全局性的后果。而这种过载保护就是大家俗称的熔断器(Circuit Breaker)。
下面这张图，就是熔断器的基本原理，包含三个状态： 
1. 服务正常运行时的 Closed 状态，当服务调用失败量或失败率达到阈值时，熔断器进入 Open 状态 
2. 在 Open 状态，服务调用不会真正去请求外部资源，会快速失败。 
3. 当进入 Open 状态一段时间后，进入 Half-Open状态，需要去尝试调用几次服务，检查故障的服务是否恢复。如果成功则熔断器关闭，如果失败，则再次进入 Open 状态。

![x](./Resource/102.png)


目前比较流行的降级熔断框架，是由 Netflix 开源的 Hystrix 框架。
发布相关
模块级自动化测试
众所周知，一个项目上线前需要经历严格的测试过程，但是随着业务不断迭代、系统日益复杂，研发工程师、产品经理、测试工程师等都在测试过程中投入了大量精力，而一个个线上故障却表明测试效果并不是那么完美。究其原因，目前的测试工作主要存在两方面问题： 
1. 测试范围难以界定：随着业务逻辑的不断迭代、系统的不断拆分与细化，精确评估项目改动的影响范围变得越来越困难，从而很难梳理出覆盖全面的测试点。 
2. case验证成本过高：验证一个case需要构造测试场景，包括数据的准备和运行环境的准备，当case量较大或者存在一些涉及多个系统模块且触发条件复杂的case时，这一过程也将花费大量的时间。
解决上述问题可以使用模块级自动化测试。具体方案是：针对某一模块，收集模块线上的输入、输出、运行时环境等信息，在离线测试环境通过数据mock模块线上场景，回放收集的线上输入，相同的输入比较测试场景与线上收集的输出作为测试结果。
模块级自动化测试通过简化复杂系统中的不变因素（mock），将系统的测试边界收拢到改动模块，将复杂系统的整体测试转化为改动模块的单元测试。主要适用于系统业务回归，对系统内部重构场景尤其适用。
具体如何收集线上数据呢？有两种方法： 
1. AOP：面向切面编程，动态地织入代码，对原有代码的侵入性较小。 
2. 埋点：很多公司都开发了一下基础组件，可以在这些基础组件中嵌入数据收集的代码。
更多细节，可以查看下面参考文献中的文章：Qunar 自动化测试框架 ARES。
灰度发布 & 回滚
单点和发布是系统高可用最大的敌人。一般在线上出现故障后，第一个要考虑的就是刚刚有没有代码发布、配置发布，如果有的话就先回滚。线上故障最重要的是快速恢复，如果等你细细看代码找到问题，没准儿半天就过去了。
为了减少发布引起问题的严重程度，通常会使用灰度发布策略。灰度发布是速度与安全性作为妥协。他是发布众多保险的最后一道，而不是唯一的一道。在这篇文章来自 Google 的高可用架构理念与实践里提到：
做灰度发布，如果是匀速的，说明没有理解灰度发布的意义。一般来说阶段选择上从 1% -> 10% -> 100% 的指数型增长。这个阶段，是根据具体业务不同按维度去细分的。 
这里面的重点在于 1% 并不全是随机选择的，而是根据业务特点、数据特点选择的一批有极强的代表性的实例，去做灰度发布的小白鼠。甚至于每次发布的 第一阶段用户(我们叫 Canary/金丝雀)，根据每次发布的特点不同，是人为挑选的。
发布之前必须制定详细的回滚步骤，回滚是解决发布引起的故障的最快的方法。
其他
1.	设置超时：请求对外接口的时候，需要设置合理的超时时间，避免外部接口挂掉时，阻塞整个系统。
2.	失败重试：失败重试能够提高成功率，但是也会造成响应时间变慢，服务提供方压力倍增。具体要不要重试要根据具体情况决定：对响应时间有要求吗？接口失败率如何？重试会不会造成雪崩？
总结
技术	解决什么问题
扩展	通过冗余部署，避免单点故障
隔离	避免业务之间的相互影响 2. 机房隔离避免单点故障
解耦	减少依赖，减少相互间的影响
限流	遇到突发流量时，保证系统稳定
降级	牺牲非核心业务，保证核心业务的高可用
熔断	减少不稳定的外部依赖对核心服务的影响
自动化测试	通过完善的测试，减少发布引起的故障
灰度发布	灰度发布是速度与安全性作为妥协，能够有效减少发布故障
	在这篇文章中，我们探讨了一些提供系统可靠性的技术方案。关于高可用的更多问题可以看看这篇文章 陈皓：关于高可用的系统，这篇文章的核心在于提出：
5个9的SLA在一年内只能是5分钟的不可用时间，5分钟啊，如果按一年只出1次故障，你也得在五分钟内恢复故障，让我们想想，这意味着什么？ 
如果你没有一套科学的牛逼的软件工程的管理，没有牛逼先进的自动化的运维工具，没有技术能力很牛逼的工程师团队，怎么可能出现高可用的系统啊。 
是的，要干出高可用的系统，这TMD就是一套严谨科学的工程管理。
	可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。
	隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。
	解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。
	限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。
	降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。
	熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。
	自动化测试：通过完善的测试，减少发布引起的故障。
	灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。

伸缩性架构设计
Darkstar项目由Sun公司实验室的一个研究小组承担，它将在架构的伸缩性领域不断探索。这个项目特别有趣之处在于，它是针对MMO（大型多人在线游戏）和虚拟世界的创建者。
在线游戏戏和虚拟世界已经找到办法来实现伸缩性，以应对数量巨大的用户。目前的方法可以分成两大类。
	基于地理位置实现。游戏设计成包含一组不同的区域，每个区域运行在一台服务器上。
	分区(sharding)。一个分区是该区域的一份副本，运行在它自己的服务器上，独立于其他的分区，它代表了游戏中相同的部分，即原来的区域。
记忆留存
这两点影响了系统的架构:它必须做什么?它必须在什么限制条件下工作?这两点也确定了问题空间。
通过解决这些重要问题，在要求的行为和限制条件之间进行探索，我们创造并考察解决方案空间。如果对各项限制条件的解决方案形成了一致的整体，我们就可能创造出一个优雅的、美丽的解决方案。
Creation Center项目做到了这一点。
在这个项目中，我们面对了一些明确的事实。有些只是业务的特点，另一些会改变，但不在我们考虑的范围内。不管怎样，我们认为这些事实是不会变的。这些事实构成了图中的左边一列。

![x](./Resource/103.png)

多品牌	LPS今天支持多个品牌，将来可能加入更多品牌。至少，Creation Center会有两个
视觉上截然不同的界面主题，而且添加界面主题应该不需要大量的工作。
合伙人是摄影师，不是圈像艺术家	摄影师接受过如何使用照相机的培训，但没有接受过使用Photoshop的培训。当一个没有经验的用户使用Photoshop时，最可能的结果是得到糟糕的图片。对于强大的用户来说， Photoshop是强大的工具，照相馆的摄影师应该没有必要去体验Photoshop的学习曲线。Photoshop和类似的工具会让照相馆的工作流程变慢。照相馆的合伙人需要快速创造出漂亮的图像。
照相馆是远程的	照相馆在地理上是分布式的，很少或没有本地技术支持。硬件交付或替换需要来回运送部件。
网络是不可靠的	某些照相馆没有网络连接。即便对于有网络连接的照相馆，因断网而导致照相馆停工也是不可接受的。
客户希望得到他们自己的产品	客户收到的照片应该包括他们自己的设计和要求的文字。
生产是集中式的	高品质的照片打印机正变得越来越常见，但制作能够保存几十年的产品需要贵得多的设备。
生产吞吐量很重要	使用到相同的打印机也是生产过程中的约束条件。因此，过程中的其他步骤必须服从于这个约束条件。

我们选择了一些结构来解决这些重要问题。图中右边的一列展示了架构的这些关注点。当然，这些并不是Creation Center的全部值得讨论的特性，但架构中的这些考虑是普遍关注的。我也认为它们同时展示了很好的关注点分离和相互支持的结构。
将一个多维的、动态的系统简化为一种线性的描述形式总是一项挑战，不论我们是在谈论对还不存在的系统的愿景，还是试图解释已经构建好的系统中各个部分的交互。
当我们研究每一个架构关注点时，要记住它们是研究整个系统的不同方式。例如，我们使用模块化的架构来支持不同的部署场景。同时，每个模块又是按分层架构来创建的。它们是正交的、相互穿插的考虑。每个模块都按照相同的方式来分层，每个层都可以在所有模块中找到。
实际上，我们感到非常满意，因为我们既能够保持这些关注点的分离，同时又让它们互相支持。
一直以来，我们都在考虑"产品家族"而不是单个"应用程序"，因为我们必须支持几种不同的部署场景，而这些场景使用同样的底层代码。特别是，我们从一开始就知道会有以下几种配置:
照相馆客户端	照相馆有2~4台这样的工作站。摄影师使用它们来参与整个工作流，从加载图像到创建订单。
照相馆服务器	每个照相馆的中心服务器上运行着MySQL ，保存客户和订单等结构化数据。服务器的存储也比工作站更健壮，使用了RAID来实现可恢复性。我们也利用照相馆服务器将每天的订单刻录到DVD 中。
渲染引擎	在生产过程中，我们决定构建自己的渲染引擎。渲染照相馆屏幕和准备打印的图像使用的是相同的代码，所以我们绝对可以肯定客户会拿到他们期望的照片。
最初，我们认为这些不同的部署配置只是一些不同的.jar文件集。我们创建了一些顶层目录来保存每种部署的代码，还有一个Common 目录。每个顶层目录都有自己的source 、test和bin 目录。
没过多久，这种结构就让我们遭遇了挫折。例如，我们有一个庞大的/lib目录，里面积累了许多构建时的库和运行时的库。我们也苦于寻找地方存放那些非代码文件，如图像、颜色描述、Hibernate配置文件、测试图像等。我们中的一些人也觉得必须通过手工的方式来维护.jar文件的依赖关系是不舒服的事情。
在刚开始那些日子里，我们常常发现很多包放在了错误的目录中。而在运行时，有些类又会加载失败，因为它依赖于另一个.jar文件中的类。
大约在项目的第3次选代时我们引入了Spring，这时转折点出现了。我们采用"敏捷架构"的方式：保持最小的架构，只有当避兔新架构特性的代价超过实现它的代价时，才采用新的架构。这在"精益软件开发"中称为"最后负责时刻"。在此之前，我们对Spring只有一些不全面的了解，所以我们决定不依赖它，但是我们都预计后来会用到它。
当我们加入Spring时，.jar文件的依赖问题被配置文件问题放大了。每个部署配置都需要它自己的beans.xml，但大约超过一半的beans会在这些文件中重复出现，这明显违反了"不要重复你自己"的原则，而且是缺陷的必然来源。所有人都不应该手工同步几千行XML文件中的bean定义。此外，几千行的XML文件本身难道不是一种坏味道吗？
我们需要一个解决方案，让我们能够模块化Spring的beans文件、管理.jar文件的依赖关系、使库贴近使用它们的代码，并管理构建时和运行时的classpath。





面向资源的结构：在Web中












系统架构师的工作是复杂设计总体解决方案以及领域对象的逻辑和物理布局，这是一项在复杂环境中高风险、高影响力的活动。
1、软件架构的定义：软件架构(Software Architecture)也称之为软件体系结构，它是一组有关如下要素的重要决策：软件系统的组织，构成系统的结构化元素，接口和它们相互协作的行为的选择，结构化元素和行为元素组合成粒度更大的子系统方式的选择，以及指导这一组织（元素及其接口、协作和组合方式）的架构风格的选择。换句话说，软件架构实际上是对系统整体结构设计的刻划，系统架构师是做全局的、整体的把握工作。架构的组成与决策是架构设计的两个基本概念。架构=>蓝图+规则+解决方案
软件架构是一个认识事物的过程：原型、发现、改进、再发现、再改进，这是软件开发的必由螺旋。
2、架构师成长路线图：系统架构师已经不仅仅是技术精湛的技术专家，他需要与业务团队紧密合作，并且精通市场、业务与管理。从上升趋势来说，可以有三个层面的路线图：第一个层面，要关注系统思考。在这个层面，重要的不仅仅是掌握设计的知识点，而是更重视分析能力、创新思维能力的提升，需要更广阔的思路，这方面的空间非常大。这是第一层面的能力基础。第二个层面，要关注总结和指导，思维空间要转向群体。如何把已有的经验总结出来，并让这种智力资产真正发挥作用？成为架构师上升第二层面的能力基础。第三个层面，要提升自身的全面修养。我们必须引发自己思维方式的变革，要培养组织力、领导力、创新力以及拥有激情，这是架构师上升第三层面的能力基础。
要看到自身的弱点，思路要宽，多思考
架构师并不是一个普通的技术人员，他对设计站的角度更高，需要的知识和能力结构更复杂，他需要具有其他人所没有的思想、眼光和感知世界的方法，必须突破已有的思维模式和行为模式，突破长期束缚自己的思维瓶颈，才可能达到自己从未达到过的高度。
架构师要养成每项工作都记录并分析的好习惯，以形成更扎实的工作风格。在每个项目完成都需要进行总结。
3、架构师要保持自己的竞争力：架构师必须关注今天的IT技术、商业模式变革以及由此引发的软件产业变革的重大趋势，勤于思考并迎接新的挑战。一个人最核心的竞争优势是学习能力。架构师作为技术层面资深的一群，为了保持竞争力需要注意以下几个问题：(1)保持激情：关键是信念。激情源自于信念，有了信念才会主动挑战自我，迎接挑战才会有激情，有了激情工作才会更有意思。(2)创新思考：在工作中多尝试一些新方法，是维持自我能力的重要手段。(3)逆向思维：逆向思维指的是使用与正常思路相反的思维方式去分析同一个问题，使思路多样化。逆向思维能够帮助人们冲破传统思维的束缚，克服惯性思维方式。从反方向考虑问题往往会取得出人意料的结果。
4、架构师要关注软件的新趋势：目前传统软件危机暴露出的问题还未真正解决，新的挑战却已摆在眼前。在人们不断思考面临的挑战以及对策中，形成了一些新的趋势，包括：(1)软件质量以服务质量形式展现，对质量的投资可获得更高的投资回报。(2)软件过程扩展到用户，希望更多的用户深入参与到软件全生命周期。(3)功能至上远远不够，用户体验得到空前重视。(4)系统集成模式面临变革，软件、服务、终端、IT基础设施将形成更紧密的价值体系。(5)研发要更多关注非功能性需求，如安全性质量、性能、可靠性、可扩充性、可伸缩性、可用性等，从而不断提高软件的价值。
知识就是力量==>信息就是力量
架构并不完全是概要设计。概要设计还是停留在图纸上，而架构必须证明这个技术路线可行，并且能够证明大多数质量风险已经得到了解决。
5、所谓设计就是解决问题的过程：软件设计是一种思维活动，设计的魅力在于破解难题，通过直面问题的挑战，以及对相应解决方案的仔细推敲，才可能设计出真正有灵性的产品。(1)设计不具普遍性：软件设计很少具有普通性，不同的目标需要不同的设计来支持。(2)做出权衡：所谓软件设计，本质上就是在质量、成本、时间以及其它各种因素之间做出权衡。(3)记录设计的理由（设计文档）。
多关注各方面的架构设计
6、质量属性决定了架构风格：一种架构的风格，很大程度上与设计者如何满足质量要求的对策有关。需求的功能和非功能两方面都可能有质量要求。具体归纳如下：(1)与功能性有关的质量属性主要包括：A、正确性：是指软件按照需求正确执行任务的能力。B、健壮性：指的是在异常情况下，软件能够正常运行的能力。正确性与健壮性的区别在于，前者是在功能需求之内描述问题，后者是在功能需求之外描述问题。健壮性一般有两层含义：首先是容错能力，其次是恢复能力。容错指的是发生异常情况不出错误的能力，而恢复指的是软件发生错误以后能恢复到没有发生错误钱的状态的能力。C、可靠性：是一个与时间相关的属性，指的是在一定的环境下，在一定的时间段，系统不出现故障的概率。通常用平均无故障时间来衡量。(2)与非功能性有关的质量属性主要包括：A、性能：是指软件的“时间-空间”效率，而不仅仅是指软件运行速度。换句话说是速度要快而占用资源要少。性能=速度/资源。B、易用性：指的是用户使用软件的容易程度。C、清晰性：意味着工作成果易读、易理解。D、安全性：它的目的是系统应该具备防止非法入侵的能力，这既属于技术问题也属于管理问题。E、可扩展性：这反映软件适应“变化”的能力，包括需求、设计的变化、算法的改进和变化。F、可移植性：指的是软件不经修改（或者稍加修改）就可以在不同软硬件环境中使用的能力。
7、抵制前期进行庞大设计的诱惑：(1)架构应该具备易演化特征；(2)项目开发周期不要超过6个月；(3)分而治之：抓住真正的需求、分而治之（把大项目分成小项目）、设置优先级、尽快交付；(4)增量式开发与交付：如果前期需求比较清楚，可以把一个大项目分成若干相对独立能够持续交付的部分，这样就可以把大问题分成若干小问题；(5)迭代式开发与交付：如果前期需求不是太清楚，项目带有强烈的创新成分，可以使用具有强迭代的逐步求精的模型。
8、重构：在不影响整体外部行为的前提下，不断地对软件进行细微的设计改进，这种渐进式的实践叫做重构。通过重构不仅能够降低维护成本，而且也为我们提供了改进代码质量的通用标准，并使我们能迅速添加新功能。从本质上说，重构根本上就是一个态度问题，而不全是技术问题。
在集中精力完成了代码逻辑以后，就需要集中精力做第二件事情，那就是重构。在对代码进行重构时，我们不会增加新功能，甚至也不会去修复bug。相反，我们会通过将代码变得更易于理解来提升代码的可读性。
重构要坚持不懈：(1)重构可以加快进度；(2)重构应该是小步骤地进行；(3)技术债务积累越多，重构的难度就越大。
9、对结构进行优化的基本原则：在完成了功能逻辑之后，除了代码重构以外，很多情况下还需要重新审视一下软件结构，对结构进行重构。良好的结构设计需要遵循一些原则，而原则本身就是经验的总结。依据这些原则，我们就可以在设计中有良好的设计指向。如需求不变则不需结构。
结构的4条设计原则：(1)单一职责原则(SRP)：也被称之为内聚性原则；SRP原则的描述为：就一个类而言，应该仅有一个引起它变化的原因；(2)开放--封闭原则(OCP)：OCP的关键是依赖于抽象。OCP原则的目的，是要求我们设计的软件实体（类、组件、函数等等）应该是可以扩展的，但是不可修改的。A、对于扩展是开放的：这意味着组件的行为是可以扩展的，当应用的需求改变时，我们可以对组件进行扩展，使其具有满足那些改变的新行为。换句话说我们可以改变组件的功能。B、对于更改是封闭的：对组件行为进行扩展时，不必改动组件的源代码，无论是动态链接库、DLL或者是Java的jar文件都无需改动。(3)依赖倒置原则(DIP)：使用传统的结构化设计所创建出来的依赖关系结构，策略是依赖于细节的，这是糟糕的，因为这样会使策略受到细节改变的影响。面向对象的程序设计倒置了依赖关系结构，使得细节和策略都依赖于抽象，并且常常是客户拥有服务接口。事实上，这种依赖关系的倒置正是好的面向对象设计的标志所在。DIP的原则是：A、高层组件不应该依赖于低层组件。二者都应该依赖于抽象；B、抽象不应该依赖于细节，细节应该依赖于抽象。(4)接口隔离原则(ISP)：这个原则用来处理“胖(fat)”接口所具有的缺点。类的“胖”（不内聚）接口可以分解成多组方法。每一组方法都服务于一组不同的客户程序。这样，一些客户程序可以使用一组成员函数，而其它客户程序可以使用其它组的成员函数。实际中当然也存在有一些对象，它们确实不需要内聚的接口，但是ISP建议客户程序不应该看到它们作为单一的类存在。相反，客户程序看到的应该是多个具有内聚接口的抽象基类。
10、关注变化、关注特征：拥抱着变化而设计。让变化成为一个重要的设计要素，需求总是会发生变化。面向对象是个思维方式。基于接口进行设计。
软件复用(SoftwareReuse)：是将已有软件的各种有关知识用于建立新的软件，以缩减软件开发和维护的花费。软件复用是提高软件生产力和质量的一种重要技术。早期的软件复用主要是代码级复用，被复用的知识专指程序，后来扩大到包括领域知识、开发经验、设计决定、体系结构、需求、设计、代码和文档等一切有关方面。
软件重用，是指在两次或多次不同的软件开发过程中重复使用相同或相似软件元素的过程。软件元素包括程序代码、测试用例、设计文档、设计过程、需要分析文档甚至领域知识。通常，可重用的元素也称作软构件，可重用的软构件越大，重用的粒度越大。
11、面向服务的架构(Service-OrientedArchitecture, SOA)：面向服务的架构成功的要点是服务识别。服务识别的基本过程：(1)了解项目的性质；(2)业务牵头，一定不是技术牵头；(3)明确产品的战略目标；(4)研究企业业务流程；(5)重用行业制品；(6)建立契约基线；(7)完善服务属性等级矩阵(ARMS)；(8)使用业务敏捷场景仿真(BASS)进行测试；(9)拥抱变更。
12、架构与框架的区别：框架是一个软件，但架构不是软件，而是关于软件如何设计的重要决策。但是在引入软件框架以后，软件架构决策往往会体现在框架设计之中。不论是架构技术还是框架技术，都是为了解决软件日益复杂所带来的困难，而采取的“分而治之”的结果。架构的思维是先大局后局部，这是一种问题在抽象层面地解决方案，首先考虑大局而忽略细节。框架的思维是先通用后专用，这是一种半成品，还需要通过后期的定制才能成为具体的软件。
框架和架构的关系可以总结为两个方面：(1)为了尽早验证架构设计，或者出于支持产品线开发的目的，可以把通用机制甚至整个架构以框架方式实现；(2)企业可能存在大量可重用框架，这些框架可能已经实现了架构所需的重要机制，或者对某个子系统提供了可扩展的半成品，最终软件架构可以借助这些框架来构造。
框架设计最重要的部分，其实并不在于采用何种技术方案来实现，而是对已经存在的业务过程进行深入思考，寻找它们的共性，探究其中的规律，建立恰当的模式，然后选择恰当的技术实现方案。
带团队关键因素：决心、手段（方法）、激情、信心，技术不是关键因素。
13、把经验归纳总结成理论：总结是两方面的，(1)总结过程：归纳出良好设计必须遵循的步骤，以及每一步骤的目标、解决什么问题、应该有什么样的思考点和思考方向。(2)总结模式（设计模式）：模式是一种实践经验的总结，通过总结每个思考点的各种解决方案，并且和过程的节点装配在一起，形成能够指导他人的模式语言。
目前大约有110多种设计模式，模式不是教条，模式仅仅是经验的总结
   	模式是一种经过命名的对于解决方案的格式化经验总结，它能有效地帮助我们归纳和使用经验。
14、在软件设计中，宏观上看自上而下大致上可以分成三个大的过程域，它包括：顶层架构设计过程域；领域对象设计过程域；资源应用设计过程域，图1。

![x](./Resource/20.jpg)

图 1
顶层架构设计过程域的目标是：建立一个系统的概念性架构，为系统描绘一个初始的轮廓，并且对涉及全局的问题进行决策。
    领域对象设计过程域的目标是：根据细化的领域对象模型，在细节层面对每一个领域对象进行刻画，并且对于这些细节层面的技术问题进行决策。
    资源应用设计过程域的目标是：在宏观和微观两个层面，对于涉及内存、对象、数据等方面的方案和问题进行决策。
    为了进一步的细化，在每个过程域内部，又可以包括一系列的过程，（用于解决一个特定的主题和问题，被称之为过程）。这样一来，宏观设计过程就可以分成11组内聚的过程（问题域）。要注意到尽管过程的描述是清晰分离的，但整个软件的设计并不仅仅是自上而下逐步求精的过程，而是相互影响、互相支持、在设计过程中不断优化的不断反馈过程，图2。
![x](./Resource/21.jpg)

图 2
设计模式汇总：
Domain Model：定义了一个应用领域结构和工作流的精确模型，其中还包括它们的变化。
Layers：解决系统合理分层的问题。
   	Model-View-Controller：解决对用户界面变化的支持问题。支持某一特定用户界面的变化。
  	Presentation-Abstraction-Control：解决相同业务具有多种表现形式问题。
   	Microkernel：解决业务具有多种不同业务方法的问题。
   	Refelection：解决需要动态改变软件系统结构和行为的问题。
   	Pipes and Filters：解决算法的结构化并可以重新构建的问题。
Shared Repository：适用于网络管理和控制系统领域。
Blackboard：解决运行中智能化改进处理方法的问题。
   	Domain Object：表现为已经将自我完备的连贯功能和基础性责任封装成定义良好的实体，通过一个或多个“显示接口”提供功能，并隐藏内部结构和实现。
   	Messaging：由一系列相互连接的MessageChannel和Message Router管理着跨网络的不同服务间的消息交换。
 	Message Channel：解决如何把彼此协作的客户端和服务连接起来的问题。
   	Message Router：解决如何根据条件接受“信道”消息的问题。
   	Message Translator：解决如何转换消息格式的问题。
   	Message Endpoint：解决把数据转换为消息中间件能够理解的形式的问题。
Publisher-Subscriber：为了在应用中更好的把彼此关注的事件通知给其它领域对象。
   	Broker：通过一个代理管理器管理领域对象间远程互操作的各个关键方面。
Client Proxy：解决客户端应用与网络基础设施相互屏蔽的问题。
   	Requestor：解决应用代码被基础设施的代码污染而影响可移植性的问题。
   	Invoker：解决服务代码被基础设施的代码污染而影响可移植性的问题。
  	Client Request Handler：解决客户端应用与通信相互影响的问题，它封装了客户端在统一的接口背后进行的进程间通信的细节。
  	Server Request Handler：解决服务端应用与通信相互影响的问题，封装了服务器端在统一的接口背后进行的进程间通信的细节。
  	Reactor：解决在应用中避免使用多线程的问题。
   	Proactor：解决在多线程的背景下出现性能问题的缺陷。
   	Acceptor-Connector：把事件初始化与具体处理方法分离，从而提高可维护性。
 	Asynchronous Completion Token：解决异步到达的事件仍然能按一定顺序处理的问题。
   	Explicit Interface：解决如何正确设计接口的问题。
 	Extension Interface：随着时间的推移，组件的接口是会膨胀的，一个胖的接口将更脆弱。解决防止“胖”接口并分离接口。
  	Introspective Interface：解决公开内部信息接口的问题。
   	Dynamic Invocation Interface：解决同一个接口允许客户端调用多种方法的问题。
  	Proxy：解决在同一个接口下通过代理屏蔽某些实现的问题。
  	Business Delegate：由本地业务代表来完成所有网络任务，分离了应用和网络处理的业务，减少了开发难度、提高了可理解性和可维护性。
   	Facade：解决屏蔽子系统的变化辐射到高层应用的问题。
   	Combined Method：解决多种相互关联的方法不合理的分布的问题。
  	Iterator：解决分布式元素能够方便迭代的问题。
Enumeration Method：解决减少外部迭代方式多次对聚合中的元素进行独立访问开销的问题。
Batch Method：解决多次访问加大网络开销的问题。

![x](./Resource/22.jpg)

Encapsulated Implementation：解决对象划分的基本原则和方法问题。
   	Composite：建立一种结构灵活的树状结构对象组织形式，形成“整体/部分”层级结构。
   	Half-Object plus Protocol：通过在分布式系统中合理布局对象，以减少不合理的网络流量和服务器压力。
   	Replicated Component Group：解决分布式系统容错的问题，复制的组件实现位于不同的网络节点，并组成一个组件组。
  	Half-Sync/Half-Async：对并发系统中的异步和同步服务处理解耦合以简化编程，但又不会过度地影响性能。
Leader/Followers：解决大批量小处理的环境下减少并发线程应用的问题。
Active Object：为了减少服务器并发线程应用。
Monitor Object：解决并发业务相互协调的问题。
Guarded Suspension：在并发性程序中，当某个线程对一个资源进行访问的时候，首先需要判断这个资源的警戒条件是否成立。
   	Future：并发调用的服务可能需要向客户端返回结果。
   	Thread-Safe Interface：避免自死锁和加锁开销。
  	Strategized Locking：在创建或声明时，为组件配置适当类型的锁实例。使用该锁实例来保护组件中的所有临界区。
   	Scoped Locking：解决复杂繁琐代码中的疏忽发生漏释放造成死锁的问题。
   	Thread-Specific Storage：解决频繁使用对象造成反复加锁解锁造成的性能问题。
  	Copied Value：解决共享的值对象必须锁定带来的性能问题。
   	Immutable Value：解决共享的值对象必须锁定带来的性能问题。
   	Observer：定义一个特定的更新接口，通过该接口，Observer获得Subject状态变更的通知。
  	Double Dispatch：根据运行时多个对象的类型确定方法调用的过程。
   	Mediator：封装集合中所有对象的聚合协作行为，从而将这些对象解耦合。
  	Command：为这些对象定义一个通用接口，来执行它们所代表的请求。
   	Memento：解决在不破坏封装性的前提下正确存储和读取分布式对象状态的问题。
Context Object：解决在松耦合系统中共享与程序执行上下文相关的通用信息的问题。
Data Transfer Object：解决细粒度调用多次访问远程对象单个属性所带来的巨大开销问题。
Message：解决网络协议只支持比特流这种最简单的数据传输形式，并不能识别服务调用和数据类型的问题。
Bridge：解决在下层稳定的业务中嵌入上次变化部分的问题。
   	Object Adapter：解决接口变化导致的不兼容问题。
   	Chain of Responsibility：解决对象结构和请求分发逻辑上的变化影响到客户端的问题。
   	Interceptor：解决构建一个可插拔的框架变化模型的问题。
  	Visitor：解决将服务的实现分散在定义对象结构的各个类中难以进行集中处理的问题。
   	Decorator：解决在稳定的核心功能外围添加扩展的问题。
  	Template Method：解决在下层稳定的业务中嵌入上次变化部分的问题。
   	Strategy：解决在一个或多个方法中根据不同的情况执行不同行为的问题。
   	Wrapper Facade：主要解决应用代码使用底层API所提供的服务但代码难以理解的问题，需要对底层API进行面向对象的封装，通过提供一个简洁的、健壮的、可移植的、内聚的面向对象的接口，来达到封装函数和数据的目的。
  	Declarative Component Configuration：建立需要安装各类插件的宿主基础设施，使其能够正确管理运行时环境，可靠运用系统资源和服务的问题。

![x](./Resource/23.jpg)

Container：解决领域对象直接处理平台环境造成它与平台紧密耦合并增加实现的复杂性的问题。
	Component Configurator：解决在组件生命周期后期和升级时重新配置组件的问题。
	Object Manager：解决客户端依赖对象管理增加应用内部的耦合度和复杂度的问题。
	Virtual Proxy：解决从一个巨大数据库中把所有的对象全部加载进来消耗大量资源的问题。
	Resource Pool：解决获取和释放资源（网络连接、线程或者内容）引入一定的性能开销问题。
	Resource Cache：解决几个有限的资源用户频繁创建和释放资源带来不必要的性能开销问题。
	Automated Garbage Collection：解决不能及时将不再使用的内存收回可能耗尽内存的问题。
	Counting Handles：解决确保在堆上创建的共享对象能够可靠地、安全地、及时地回收的问题。
	Abstract Factory：解决一批对象用统一的方法进行创建和销毁的问题。
	Builder：解决对需要多步完成对象的创建时，简化创建过程的复杂性和多样性问题。
	Factory Method：解决直接创建对象可能导致代码的混乱并影响调用端代码的独立性问题。
	Disposal Method：解决销毁对象时可能需要多个步骤而引人过度的耦合问题。
	Database Access Layer：它通过在两种之间引人一个映射层将面向对象应用设计同关系型数据库分离开。
	Data Mapper：解决数据模型和持久化的表结构之间完全的解耦合的问题。
	Row Data Gateway：解决更细致的数据模型和持久化的表结构之间完全解耦的问题。
	Table Data Gateway：解决更细致的数据模型和持久化的表结构之间完全解耦的问题。
	Active Record：解决降低应用中面向对象数据模型与数据库中表结构之间的耦合的问题。

![x](./Resource/24.jpg)


软件经济学与架构设计
	软件方法发展：
	20 世纪60 到70 年代，典型的手工工艺时代
	20 世纪80-90 年代，软件产业成熟了并且变得更具工程规模，但还是研究密集型，规模不经济
	2000 年以后，向规模经济为主流的产品密集型的方法发展
软件经济学
    工作量 = 人员 × 环境 × 质量 × 规模过程
	如果过程指数大于 1.0，则软件就是规模不经济的。系统的规模效益主要表现在项目的后续期，当架构设计合理的时候，随着后续系统的开发，软件系统的投资回报(ROI)则上升。
软件规模预估
	凭经验估算具有很大的主观性。比较科学的项目估算方法：一种是经典的代码行规模度量，另一种是现在可能更流行也更实用的功能点规模度量。但是，规模度量更多的是一种预估，它是以历史数据作为基准的，如果在过去开发中历史数据保留不全面，是不可能进行正确的规模预估的。
成本估计
	工作量的估计主要是用两种模型：成本模型、约束模型

技术

并发与多线程
为什么使用并发：
并行执行任务，提高处理效率
何时使用并发：
如果一个API调用时间超过40ms，就最好使用异步模式
进程与线程
1、进程通常由三部分组成。一部分是程序，一部分数据集合，另一部分被称为进程控制块（ProcessControlBlock，简记PCB）
2、进程包含资源，每个进程都分配了虚拟内存，一个进程至少包含一个线程。
3、创建进程的高消耗（每个进程都有独立的数据和代码空间），进程之间通信的不方便（消息机制），进程切换的时间太长，这些导致了多线程的提出。
4、线程是程序中独立的指令流，是程序执行时的一个单独路径，用来执行单一任务。
5、线程有一个优先级、实际上正在处理的程序的位置计数器、一个存储其局部变量的栈。
6、每个线程都有自己的栈，但程序代码的内存和堆由一个进程的所有线程共享。这使一个进程的所有线程之间的通信非常快，因为该进程的所有线程都寻址相同的虚拟内存。但是，这也使处理比较困难，因为多个线程可以修改同一个内存位置。
7、线程有优先级。线程的运行由操作系统调度，优先级最高的线程可以在CPU上运行。线程如果在等待资源，它就会停止运行，并释放CPU。
8、前/后台线程：前台线程不受主线程影响；后台线程随着主线程结束而结束；当主进程将要终止时，会等待所有的前台线程先终止，然后终止所有的后台线程。
为什么需要线程池：
创建线程需要时间，如果有不同的短任务要完成，就可以事先创建许多线程，在应完成这些任务时发出请求。
使用线程池的最佳实践：
1、线程数最好在需要更多的线程时增加，在需要释放资源时减少。
2、池中的最大线程数是可配置的。也可以指定在创建线程池时应立即启动的最小线程数，以及线程池中可用的最大线程数。
3、如果有更多的作业要处理，线程池中线程的个数也到了极限，最新的作业就要排队，且必须等待线程完成其任务。
4、一般来说，线程池中的所有线程都是后台线程。如果进程的所有前台线程都结束了，所有的后台线程就会停止，且不能把入池的线程改为前台线程。
5、不能给入池的线程设置优先级或名称。
6、入池的线程一般只用于时间较短的任务。
线程状态：
1、新建状态(New): 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。
2、就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。
3、运行状态(Running): 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。
4、阻塞状态(Blocked): 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种
    a、等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。
    b、同步阻塞 -- 线程在获取synchronized同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态。
    c、其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
5、死亡状态(Dead): 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

![x](./Resource/104.png)





	
参考
《机器人启示录》 
《人月神话》



CMMI
CMMI是什么东西？
CMMI英文全称是Capability Maturity Model Integration，直接翻译就是能力成熟度模型，直接看这几个中文字，你还是没有办法搞清楚CMMI是什么东西的。
大家可能在网上见过很多《成功人士的七个习惯》（可能还有很多类似的名字）的文章吧？有人总结了成功人士的成功的原因，总结出他们的习惯，如果我们也能具备这些习惯，那么我们也很可能成为成功人士。类似的，CMMI可以看作是成功企业如何做好软件的一些习惯、做法、准则等的集合，是如何做好软件的最佳实践的集合。如果企业也能按照CMMI的要求做好，那么企业就很可能成为成功的企业。
CMMI里面所有的要求，都是来自于成功企业的最佳实践的，她的先进性我们不必怀疑，如果我们没有做好，那不是CMMI本身的问题，而是我们自己没有理解好或者是没有执行好的原因。
说到CMMI，就不可避免会提到另外3个字母SEI，SEI全称是Software Engineering Institute的全称，直译就是软件工程学院，是美国的一所大学，CMMI标准就是他们搞出来的。
CMMI目前最新版本是V1.2，如果你是现在才开始了解CMMI的，那么你完全没有必要去搞清楚V1.1与V1.2的差别，更加没有必要去比较CMM与CMMI的差别，直接了解CMMI V1.2就可以了，你只需要知道CMM是CMMI的前身，而CMMI V1.1虽然比CMM要新很多，但现在已经不用了。现在在互联网上还有很多比较CMM与CMMI的文章的，除非你很想了解或者你有很多时间，建议不必去看这些内容。
 
连续式 vs 阶段式
CMMI有两种表述方式：连续式与阶段式，两种方式只是从不同的角度来阐述CMMI，其实质上表达的内容是一致的。就好像我们做数据库设计的时候，可能会设计不同的视图来查看相同数据表的数据，只是角度不一样。
大家可能会问，好好的CMMI，为什么要搞两种表达方式呢？不怕把大家搞糊涂吗？
确实这两种方式把不少人给搞糊涂了，这是SEI的一个败笔。以前的CMM是只有阶段式的表达方式的，连续式是后来提出来的，SEI内部分成两派，一派支持连续式，一派支持阶段式，互不相让，最后达不成一致，就出来了现在这个样子，连续式与阶段式两者共存。
连续式其实更加能反应过程改进的本质，并且能更好地引导企业把过程改进做到实处，但连续式比较难以理解。阶段式是直接继承CMM的，大家都比较容易理解，而且阶段式有一个级别，在商业上更好宣传，但很容易导致企业为了过级而过级。
连续式和阶段式同时也是评估的两个不同角度，用连续式评估，企业会得到很多个PA的Level，用阶段式评估，企业会得到一个整体的Level。
对CMMI还不是很熟的人士，先了解这么多就可以了，以后再慢慢了解。
 
CMMI 1至5级简述
这里我们用比较容易理解的阶段式的角度，来描述一下CMMI的级别。
在模型中，所有软件组织的软件能力成熟度划分为5个等级——第1到第5级。数字越大，成熟度越高，高成熟度等级代表比较强的综合软件能力。
5个成熟度等级分别是：
第1级：初始级
第2级：受管理级
第3级：已定义级
第4级：定量管理级
第5级：持续优化级
第1级是不需要评估的，哪怕你们是手工作坊开发的软件公司，也可以说是CMMI1级。从2级开始到5级，SEI在每个级别都有详细的标准。
那怎样才算达到某个级别呢？
要通过高级别的评估，要满足这个级别以下所有级别的标准。
例如：
一个进行4级评估的企业，评估的时候首先是看是否达到2级要求，然后是3级要求，然后才是4级要求。
评估的时候，如果2级的标准达到，但3级的要求达不到，就算4级的要求达到了，也只能算2级。

每个级别又代表怎样的意思呢？下表简要地说明了1到5级的差异：

![x](./Resource/105.png)


2级比较容易做到，要做到3级要做的事情多很多，一般来说建议2、3级一起来做。3级到4级跨度很大，要做到4级非常不容易。如果4级做得比较好，要做到5级难度不算很大。
过程域(PA)、目标(Goal)与实践(Practice)
CMMI2级到5级，每个级别都包含几个到十几个PA(Process Area)，直接翻译就叫做：过程域。
PA简单地说就是要做好软件开发的某一个方面，如果要达到某个级别的要求，就要达到该级别所有PA的要求。一个PA包含几个Goal（目标），如果要达到某个PA的要求，就意味着要达到该PA每个Goal的要求。
每个Goal怎样才算达到要求呢？每个Goal又包含几个到十几个Practice（实践），如果这些Practice都做到了，就认为该Goal达到要求了。
级别、PA、Goal与Practice的关系示意图如下：

![x](./Resource/106.png)


2级有7个PA，3级有11个PA，4级有2个PA，5级有2个PA，一共22个PA，Practice的总数量超过400个。如果要达到5级的要求，意味着必须满足这400多个Practice的要求。

评估办法
评估一个企业达到多少级别的要求，其实就是看相应的Practice是否达到要求。评估办法根据严谨的程度，分为以下办法：
SCAMPI C
SCAMPI B
SCAMPI A
SCAMPI A是最严谨的，进行正式评估的时候，必须采用该办法。下面我们简单体会一下SCAMPI A评估方法。
举一个日常的例子，比方说你今天中午吃了饭，但别人不知道，别人要判断你是不是吃了饭，用SCAMPI A的办法来判断的话，需要提供以下证据：
1)书面直接证据，能证明你吃了饭的书面的直接的证据。如果你去餐厅吃饭的，你的帐单就可以用来做直接证据，如果你在家做饭，那就麻烦，可能没有能留下直接书面证据了。
2)书面间接证据：比方说你在家做饭，之前去买菜了，你买菜的账单就可以作为间接书面证据。
3)访谈证据：如果别人问你，今天中午有没有吃饭，你能准确说出来，并且没有疑点，那就认为证据有效了，或者是如果你和别人吃饭，别人能说出跟你吃了饭，也认为证据有效了。
以上3方面的证据，第一个证据书面直接证据，是必须要有的，同时第2和第3类证据，至少要有一个。以上证据都具备，才能认为你吃了饭。
我想大家可能要“吐血”了，为了要证明吃了饭，居然要这样麻烦！当然吃饭只是一个例子，我们进行CMMI评估的时候，每一个Practice都需要提供这样的证据。
准备评估没有什么捷径，就是老老实实按照CMMI的要求去做，认真做好过程改进的工作，认真准备书面证据，访谈的时候就按照实际的做法老老实实的回答。
 

企业商业目标与CMMI
有一种业内普遍的误解，好像CMMI级别越高，项目的成本就越高。那么我们要问，为什么我们还要去追求高级别呢？企业到底为什么要去评估CMMI？
业内也有另外一种误解，CMMI是用来提高软件质量的。那么CMMI不用来加快软件开发进度，节省成本吗？软件开发从来就是质量、进度、成本的平衡，CMMI只关注一个方面吗？
公司的商业目标，简单地说两个字可以概括——“赚钱”！为了赚钱，我们有很多办法：
提高质量，我们的质量不需要很高，比竞争对手高就可以了。
加快进度，我们的进度也不需要很快，但至少要比竞争对手快。
减少成本，成本也不必减少很多，关键是能支持公司运作，能带来利润就可以了。

CMMI是为企业的商业目标服务的！既不是纯粹提高质量，也不是光增加公司的成本而不提高效益。CMMI是为了提高企业的生产力！
如果贵公司实施了CMMI，而没有提高生产力的话，改进是失败的，违背CMMI的初衷的。CMMI是个好东西，我们没有做好，并不是CMMI的错，是我们没有理解好或者是执行好。
要让CMMI切实为企业带来价值，难度很高，如何才能做到？这些内容可以写一本书。本文希望能澄清大家的一些思想误区，扫扫CMMI的文盲，为切实发挥CMMI的作用做好准备。

需求卡片模板

![x](./Resource/107.png)























