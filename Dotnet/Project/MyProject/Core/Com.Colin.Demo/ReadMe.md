# C#代码示例

## 1. 面向对象示例

### 继承

如果一个类继承自一个基类，那么这个类会从基类得到所有的方法、属性(attribute)、特性(property)、事件。

例外的是，类不会从基类继承构造函数、析构函数和静态构造函数，也不会继承那些显式拒绝访问的成员。

不支持多重实现继承，支持多重接口继承

构造函数的执行顺序：最先调用的总是基类的构造函数。

### 多态

多态的意思是能够以多种形式出现。

在面向对象语言中，多态指能够根据类或数据类型，以不同的方式处理对象。

换句话说，提供方法或属性的不同实现方法，但具有相同的名称。

多态性确保了能够调用正确的方法，而无须考虑数据类型。在.NET中，有三种类型的多态性：接口多态性、继承多态性和抽象类多态性。

1. 接口多态性：在.NET中，很多个类可以实现同样的接口，一个类也可以实现很多个接口。

2. 继承多态性：多态最常见的形式。通过virtual关键字的使用提供方法的不同实现。在继承一个基类时，会继承基类中所有的属性、方法、特性以及事件。但有的时候并不想继承某个功能，或者需要稍作变化。只要在基类中把方法或属性标记为virtual，就可以在子类中重写。

3. 抽象类多态性：抽象类是指用abstract类型修饰符标记的类。抽象类通常具有抽象方法，抽象方法是指定义了但没有实现的方法，这种方法不能实例化。用抽象类来实现多态有点类似于继承多态性。区别在于，方法是标记为abstract，而不是virtual。抽象方法不提供实现，因此完全依靠子类来实现功能。抽象方法也比较像接口中定义的方法，因为这种方法提供一个协定声明，表示该方法会在子类中实现。

### 委托

1. 委托类型 (delegate type) 表示对具有特定参数列表和返回类型的方法的引用。

   通过委托，我们能够将方法作为实体赋值给变量和作为参数传递。委托类似于在其他某些语言中的函数指针的概念，但是与函数指针不同，委托是面向对象的，并且是类型安全的。

2. 委托既可以引用静态方法，也可以引用实例方法。

   引用了实例方法的委托也就引用了一个特定的对象，当通过该委托调用这个实例方法时，该对象在调用中成为this。也可以使用匿名函数创建委托，这是即时创建的**内联方法**。

3. 委托的一个有趣且有用的属性在于，它不知道也不关心它所引用的方法的类；它仅关心所引用的方法是否与委托具有相同的参数和返回类型。

### 事件

1. 事件(event)是一种使类或对象能够提供通知的成员。事件的声明与字段类似，不同的是事件的声明包含event关键字，并且类型必须是委托类型。

2. 在声明事件成员的类中，事件的行为就像委托类型的字段（前提是该事件不是抽象的并且未声明访问器）。

   该字段存储对一个委托的引用，该委托表示已添加到该事件的事件处理程序。如果尚未添加事件处理程序，则该字段为 null。

3. 客户端通过事件处理程序(event handler)来响应事件。事件处理程序使用 += 运算符附加，使用 -= 运算符移除。

4. 对于要求控制事件的底层存储的高级情形，事件声明可以显式提供 add 和 remove 访问器，它们在某种程度上类似于属性的 set 访问器。

### 静态构造函数

它不依赖于对象的创建，它会在创建类后的某个时刻调用（一般在代码引用类的成员之前），但是不确定；

因此不应该把某个特定时刻（比如加载程序集）需要执行的代码放在静态构造函数中，也不能预计不同类的静态构造函数按什么顺序执行（静态构造函数中的代码不应依赖于其它类中静态构造函数执行情况)。

但是可以确保静态构造函数只执行一次。静态构造函数中只能处理类的静态字段或属性。因为只由自己本身调用，所以访问修饰符没有意义，参数列表也没有意义，一个类也只能有一个静态构造函数。

### 弱引用

***什么是强引用？**

例如：Object obj = new Object(); 就是一个强引用。

内存分配空间存储Object数据，这块内存有一个首地址，也就是变量obj所保存的数据，内存分配的空间中不仅保存Object对象信息，还保存自己（Object本身）被引用的次数。

当一个对象被强引用的形式创建的时候，本身被引用的次数已经为1。

接着 Object o = obj; 这句代码执行之后，obj指向的Object的存储空间已经被引用了2次，所以Object保存的被引用数值为2。

总结：强引用最终导致的结果就是被引用的对象的被引用次数+1;

相反的，弱引用就是不会对对象的被引用次数有任何影响。我们平常用的都是对象的强引用，如果有强引用存在，GC是不会回收对象的。

能不能同时保持对对象的引用，而又可以让 GC 需要的时候回收这个对象？.NET中提供了**WeakReference**来实现。

弱引用可以让您保持对对象的引用，同时允许 GC 在必要时释放对象，回收内存。

对于那些创建便宜但耗费大量内存的对象，即希望保持该对象，又要在应用程序需要时使用，同时希望 GC 必要时回收，则可以考虑弱引用。

***防止内存泄露**

通过异步访问网络资源时，耗时比较长，在数据返回之前，用户很可能转向了其他的页面。

如果异步访问的对象(obj)对本地的一个对象(Object)是强引用的话，那么在这个异步访问对象(obj)被释放之前，这个被引用的对象(Object)是不会被销毁的，这样一来，就导致内存一直被占用。

### 结构

1. 结构(struct)是能够包含数据成员和函数成员的数据结构。但是结构是值类型，不需要堆分配。结构类型的变量直接存储该结构的数据

2. 结构类型不支持用户指定的继承（父类）；结构的继承链是：每个结构派生自 System.ValueType 类，System.ValueType 类又派生自 System.Object

3. 结构构造函数也是使用 new 运算符调用，但是这并不意味着会分配内存。结构构造函数并不动态分配对象并返回对它的引用，而是直接返回结构值本身

   （通常是堆栈上的一个临时位置），然后根据需要复制该结构值。

4. 复制整个结构通常不如复制对象引用的效率高，因此结构的赋值和值参数传递可能比引用类型的开销更大。

   其次，除了 ref 和 out 参数，不能创建对结构的引用，这样限制了结构的应用范围。

5. 所有的基本类型都是结构类型。

6. 堆栈的执行效率比堆高，但是资源有限，因此实际运用中对于需要构造函数、常量、字段、方法、属性、索引器、运算符、事件和嵌套类型的复杂类型的处理建议使用class；

   简单并且不涉及复制的类型可以使用结构。

7. 结构是隐式的sealed，不能从另外的结构或类继承，但是可以实现接口

8. 默认构造函数把数值字段都初始化为0，把引用类型字段初始化为null。且总是隐式地给出，即使提供了其他带参数的构造函数，也是如此。提供字段的初始值也不能绕过默认构造函数。因此，在结构中给字段直接初始化是不允许的。

### 扩展方法

可以使用实例方法的语法来调用静态方法，扩展方法已经绑定到参数指定的类型上面。定义扩展方法注意事项：

1. 静态类：类必须用static关键字定义
2. 静态方法：扩展方法必须用static关键字定义
3. this关键字：扩展方法的第一个参数前，必须有this关键字

扩展类的方式之一，没有类的源代码时常用。即使扩展方法是静态的，也要使用标准的实例方法语法。如果扩展方法与类中的某个方法同名，就从来不会调用扩展方法。

### Object类

1. ToString()：转换为字符串，一般都重写
2. GetHashCode()：散列表中确定把对象放在什么位置，如果把类用作键，需要重载这个方法
3. Equals()和ReferenceEquals()：判断相等
4. Finalize()：什么都没做，需重写
5. GetType()：返回Type实例
6. MemberwiseClone()：浅表复制

## 2. 代码示例

### 运算符重载

1. 所有一元和二元运算符都具有可自动用于任何表达式的预定义实现。

   除了预定义实现外，还可通过在类或结构中包括 operator 声明来引入用户定义的实现。

   用户定义的运算符实现的优先级始终高于预定义运算符实现的优先级：仅当不存在适用的用户定义运算符实现时才考虑预定义的运算符实现。

2. 用户定义的运算符声明总是要求至少一个参数为包含运算符声明的类或结构类型。因此，用户定义的运算符不可能具有与预定义运算符相同的签名   

3. 用户定义的运算符声明不能修改运算符的语法、优先级或顺序关联性。

### 泛型

1. 只能为默认构造函数定义构造函数约束

2. 泛型类的静态成员只能在类的一个实例中共享，所以根据具体类类型，会有多组静态成员。

3. 如果泛型类型用 out 关键字标注，泛型接口就是协变的，这也意味着返回类型只能是 T。

   如果泛型类型用in关键字标注，泛型接口就是抗变的，这样接口只能把泛型类型T用作其方法的输入。

4. 开放类型：具有泛型类型参数的类型
   封闭类型：为所有类型参数都传递了实际的数据类型

### 索引

- 索引器(indexer)支持按照索引数组的方法来索引对象。
- 索引器的声明与属性类似，不同的是该成员的名称是 this，后跟一个位于定界符 [ 和 ] 之间的参数列表。
- 在索引器的访问器中可以使用这些参数。与属性类似，索引器可以是读写、只读和只写的，并且索引器的访问器可以是虚的。
- 索引器可以被重载，这意味着一个类可以声明多个索引器，只要其参数的数量和类型不同即可。

### 枚举

### 关键字

#### using

1. 获取一个或多个资源，执行一系列语句，然后释放该资源。

   一个资源(resource)是实现了****System.IDisposable****的类或结构，它只包含一个名为****Dispose****的不带形参的方法。

   正在使用资源的代码可以调用****Dispose****以表明不再需要该资源。如果不调用****Dispose****，则最终将因为垃圾回收而对该资源进行自动释放。

2. 设置别名

```C#
using colAlias = System.Collections;
```

#### lock

****lock****语句用于获取某个给定对象的互斥锁，执行一个语句，然后释放该锁。

当一个互斥锁已被占用时，在同一线程中执行的代码仍可以获取和释放该锁。但是，在其他线程中执行的代码在该锁被释放前是无法获得它的。

建议不要使用锁定****System.Type****对象的方法来同步对静态数据的访问。其他代码可能会在同一类型上进行锁定，这会导致死锁。

更好的方法是通过锁定私有静态对象来同步对静态数据的访问。

#### implicit, explicit

****implicit****关键字用于声明隐式的用户定义类型转换运算符。如果可以确保转换过程不会造成数据丢失，则可使用该关键字在用户定义类型和其他类型之间进行隐式转换。

****explicit****关键字用于声明必须使用强制转换来调用的用户定义的类型转换运算符。
