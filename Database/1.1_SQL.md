# 起步

## 目录

1. [SQL](#SQL)

## SQL

- SQL 是用于访问和处理数据库的标准的计算机语言。

  - SQL，指结构化查询语言，全称是 Structured Query Language。
  - SQL 让您可以访问和处理数据库。
  - SQL 是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。
  - SQL 对大小写不敏感：SELECT 与 select 是相同的。
  - SQL 语句后面的分号？

    某些数据库系统要求在每条 SQL 语句的末端使用分号。分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。

  - 一些最重要的 SQL 命令
    - SELECT - 从数据库中提取数据
    - UPDATE - 更新数据库中的数据
    - DELETE - 从数据库中删除数据
    - INSERT INTO - 向数据库中插入新数据
    - CREATE DATABASE - 创建新数据库
    - ALTER DATABASE - 修改数据库
    - CREATE TABLE - 创建新表
    - ALTER TABLE - 变更（改变）数据库表
    - DROP TABLE - 删除表
    - CREATE INDEX - 创建索引（搜索键）
    - DROP INDEX - 删除索引
  
  - 为什么使用SQL？

    - 允许用户访问在关系数据库管理系统的数据。
    - 让用户来描述数据。
    - 允许用户定义数据库中的数据和处理数据。
    - 允许使用SQL模块，库和预编译器的其他语言中嵌入。
    - 允许用户创建和删除数据库和表。
    - 允许用户创建视图，存储过程，函数在数据库中。
    - 允许用户设置表，过程和视图的权限
  
  - 历史

    - 1970 -- Dr. Edgar F. "Ted"  IBM的科德被称为关系数据库之父，是他描述了数据库的关系模型。
    - 1974 -- 结构化查询语言出现。
    - 1978 -- IBM合作开发Codd的想法并发布了名为System/R的产品。
    - 1986 -- IBM开发了关系型数据库的第一台样机，并通过ANSI标准化。第一个关系型数据库是由关系型软件及其后来成为甲骨文发布。

  - SQL命令
  
    标准的SQL命令进行互动使用在关系型数据库有：CREATE, SELECT, INSERT, UPDATE, DELETE 和 DROP。这些命令可分为基于其性质组。

    - DDL - 数据定义语言

      命令|描述
      -|-
      CREATE|创建一个新的表，表的视图，或者在数据库中的对象
      ALTER|修改现有的数据库对象，例如一个表
      DROP|删除整个表，数据库中的表或其他对象或视图

    - DML - 数据操纵语言

      命令|描述
      -|-
      SELECT|从一个或多个表中检索特定的记录
      INSERT|创建记录
      UPDATE|修改记录
      DELETE|删除记录

    - DCL - 数据控制语言

      命令|描述
      -|-
      GRANT|授予用户权限
      REVOKE|收回用户授予的权限

- RDBMS 指关系型数据库管理系统，全称 Relational Database Management System。RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server、IBM DB2、Oracle、MySQL 以及 Microsoft Access。

  RDBMS 中的数据存储在被称为表的数据库对象中。表是相关的数据项的集合，它由列和行组成。

  此外，它们也使用不同的方言，如：
  
  - MS SQL Server 使用 T-SQL
  - Oracle 使用 PL/SQL
  - MS Access 的SQL版本叫 JET SQL（本地格式）等

  ***SQL处理***
  
  当你对任何RDBMS执行SQL命令，系统决定开展您的要求的最佳途径和SQL引擎计算出如何解析任务。
  
  有包括在过程中的各种组件。这些组件查询调度，优化引擎，经典查询引擎和SQL查询引擎等等。经典查询引擎处理所有非SQL查询，但SQL查询引擎不会处理逻辑文件。
  
  以下是显示SQL架构一个简单的图表：

  ![x](./Resource/1.jpg)


SELECT
SELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。
语法
SELECT column_name,column_name
FROM table_name;
与
SELECT * FROM table_name;
SELECT DISTINCT
在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同(distinct)的值。DISTINCT 关键词用于返回唯一不同的值。
语法
SELECT DISTINCT column_name,column_name
FROM table_name;
WHERE
WHERE 子句用于过滤，提取那些满足指定条件的记录。
语法
SELECT column_name,column_name
FROM table_name
WHERE column_name operator value;
文本字段 vs. 数值字段
SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。
如果是数值字段，请不要使用引号。
WHERE 子句中的运算符

运算符	描述
=	等于
<>	不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !=
>	大于
<	小于
>=	大于等于
<=	小于等于
BETWEEN	在某个范围内
LIKE	搜索某种模式
IN	指定针对某个列的多个可能值


示例
Where 子句
搜索 empno 等于 7900 的数据：
Select * from emp where empno=7900;
Where +条件（筛选行）
条件：列，比较运算符，值
比较运算符包涵：= > < >= ,<=, !=,<> 表示（不等于）
Select * from emp where ename='SMITH';
例子中的 SMITH 用单引号引起来，表示是字符串，字符串要区分大小写。
逻辑运算
And:与 同时满足两个条件的值。
Select * from emp where sal > 2000 and sal < 3000;
查询 EMP 表中 SAL 列中大于 2000 小于 3000 的值。
Or:或 满足其中一个条件的值
Select * from emp where sal > 2000 or comm > 500;
查询 emp 表中 SAL 大于 2000 或 COMM 大于500的值。
Not:非 满足不包含该条件的值。
select * from emp where not sal > 1500;
查询EMP表中 sal 小于等于 1500 的值。
逻辑运算的优先级：
()    not        and         or
特殊条件
1.空值判断： is null
Select * from emp where comm is null;
查询 emp 表中 comm 列中的空值。
2.between and (在 之间的值)
Select * from emp where sal between 1500 and 3000;
查询 emp 表中 SAL 列中大于 1500 的小于 3000 的值。
注意：大于等于 1500 且小于等于 3000， 1500 为下限，3000 为上限，下限在前，上限在后，查询的范围包涵有上下限的值。
3.In
Select * from emp where sal in (5000,3000,1500);
查询 EMP 表 SAL 列中等于 5000，3000，1500 的值。
4.like
Like模糊查询
Select * from emp where ename like 'M%';
查询 EMP 表中 Ename 列中有 M 的值，M 为要查询内容中的模糊信息。
	 % 表示多个字值，_ 下划线表示一个字符；
	 M% : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。
	 %M% : 表示查询包含M的所有内容。
	 %M_ : 表示查询以M在倒数第二位的所有内容。
不带比较运算符的 WHERE 子句：
WHERE 子句并不一定带比较运算符，当不带运算符时，会执行一个隐式转换。当 0 时转化为 false，1 转化为 true。例如：
SELECT studentNO FROM student WHERE 0
则会返回一个空集，因为每一行记录 WHERE 都返回 false。
SELECT  studentNO  FROM student WHERE 1
返回 student 表所有行中 studentNO 列的值。因为每一行记录 WHERE 都返回 true。
AND & OR 运算符
AND & OR 运算符用于基于一个以上的条件对记录进行过滤。
如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。
如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。
ORDER BY
ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。
ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。
语法
SELECT column_name,column_name
FROM table_name
ORDER BY column_name,column_name ASC|DESC;
ORDER BY 多列的时候，先按照第一个column name排序，在按照第二个column name排序
ORDER BY 排列时，不写明ASC DESC的时候，默认是ASC
desc 或者 asc 只对它紧跟着的第一个列名有效，其他不受影响
INSERT INTO
INSERT INTO 语句用于向表中插入新记录。
语法
INSERT INTO 语句可以有两种编写形式。
第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：
INSERT INTO table_name
VALUES (value1,value2,value3,...);
第二种形式需要指定列名及被插入的值：
INSERT INTO table_name (column1,column2,column3,...)
VALUES (value1,value2,value3,...);
注意：没有指定要插入数据的列名的形式需要列出插入行的每一列数据
insert into select 和select into from 的区别
insert into scorebak select * from socre where neza='neza'  --插入一行，要求表scorebak必须存在
select *  into scorebak from score  where neza='neza'  --也是插入一行，要求表scorebak不存在
UPDATE
UPDATE 语句用于更新表中已存在的记录。
语法
UPDATE table_name
SET column1=value1,column2=value2,...
WHERE some_column=some_value;
请注意 SQL UPDATE 语句中的 WHERE 子句！
WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！
执行没有 WHERE 子句的 UPDATE 要慎重，再慎重。
在 MySQL 中可以通过设置 sql_safe_updates 这个自带的参数来解决，当该参数开启的情况下，你必须在update 语句后携带 where 条件，否则就会报错。
set sql_safe_updates=1; 表示开启该参数
DELETE
DELETE 语句用于删除表中的记录。
语法
DELETE FROM table_name
WHERE some_column=some_value;
请注意 SQL DELETE 语句中的 WHERE 子句！
WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！
您可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：
DELETE FROM table_name;
或
DELETE * FROM table_name;
注释：在删除记录时要格外小心！因为您不能重来！
mysql 中可以通过参数 sql_safe_updates 来限制 update/delete，防止全表更新或删除。
以下 3 种情况在采用此参数的情况下都不能正常进行操作：
	 1: 没有加where条件的全表更新操作;
	 2: 加了 where 条件字段，但是 where 字段没有走索引的表更新;
	 3: 全表 delete 没有加 where 条件或者 where 条件没有走索引。
这三种情况下都会抛出异常，无法执行。
下面是 sql_safe_updates 变量为 0 和 1 时的取值说明：
sql_safe_updates 有两个取值 0 和 1， 即 off 和 on。
sql_safe_updates = 1 (或 sql_safe_updates = on ) 时，不带 where 和 limit 条件的 update 和 delete 操作语句是无法执行的，即使是有 where 和 limit 条件但不带 key column 限制条件的 update 和 delete 也不能执行。
sql_safe_updates = 0 (或 sql_safe_updates = off ) 时，无 where 和 limit 条件的 update 和 delete 操作将会顺利执行。
很显然，在一般的 mysql 中此参数的默认值是 1。
在 sql_safe_updates = on 时，采取删除或更新全表时抛出的错误码为 1175。
truncate：删除表的内容，表的结构存在，可以释放空间，没有备份表之前要慎用；
SELECT TOP, LIMIT, ROWNUM
SELECT TOP 子句用于规定要返回的记录的数目。对于拥有数千条记录的大型表来说，是非常有用的。
注意:并非所有的数据库系统都支持SELECT TOP语句。MySQL支持LIMIT语句来选取指定的条数数据，Oracle可以使用ROWNUM来选取。
SQL Server / MS Access 语法
SELECT TOP number|percent column_name(s) FROM table_name;
MySQL 语法
SELECT column_name(s) FROM table_name LIMIT number;
Oracle 语法
SELECT column_name(s) FROM table_name WHERE ROWNUM <= number;
在 Microsoft SQL Server 中还可以使用百分比作为参数。
下面的 SQL 语句从 websites 表中选取前面百分之 50 的记录：
SELECT TOP 50 PERCENT * FROM Websites;
LIKE
LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。
语法
SELECT column_name(s) FROM table_name WHERE column_name LIKE pattern;
like语句中 _ % 怎么转义
select * from username where 用户名 like '段_%'    -- 会查出来段煜 段鑫
select * from username where 用户名 like '段\_%' escape '\'   -- 通过 \ 转义，只能查出来 段_煜
通配符
通配符可用于替代字符串中的任何其他字符。
在 SQL 中，通配符与 SQL LIKE 操作符一起使用。SQL 通配符用于搜索表中的数据。在 SQL 中，可使用以下通配符：

通配符	描述
%	替代 0 个或多个字符
_	替代一个字符
[charlist]	字符列中的任何单一字符
[^charlist] 或 [!charlist]	不在字符列中的任何单一字符
首先说下LIKE命令都涉及到的通配符：
% 替代一个或多个字符
_ 仅替代一个字符
[charlist] 字符列中的任何单一字符
[^charlist]或者[!charlist] 不在字符列中的任何单一字符
其中搭配以上通配符可以让LIKE命令实现多种技巧：
1、LIKE'Mc%' 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。
2、LIKE'%inger' 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。
3、LIKE'%en%' 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。
4、LIKE'_heryl' 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。
5、LIKE'[CK]ars[eo]n' 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。
6、LIKE'[M-Z]inger' 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。
7、LIKE'M[^c]%' 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。
SQL 中，通配符与 SQL LIKE 操作符一起使用。
不过，MySQL 、SQLite 只支持 % 和 _ 通配符，不支持 [^charlist] 或 [!charlist] 通配符（MS Access支持，微软office对通配符一直支持良好，但微软有时候的通配符不支持%，而是*，具体看对应软件说明）。通配符和正则不是一回事。
MySQL和SQLite会把like '[xxx]yyy'的中括号当成普通字符，而不是通配符。
比如：
select * from persons WHERE City LIKE '[b]eijing'
将查出city为[B]eijing的行，而不是city为beijing的行。
MySQL中要完成[^charlist]或[!charlist]通配符的查询效果，需要通过正则表达式来完成。
select * from persons WHERE City REGEXP '[b]eijing' 
SQLite不支持Regexp正则方法。
MySQL中使用REGEXP或NOT REGEXP运算符（或RLIKE和NOT RLIKE）来操作正则表达式。
下面的SQL语句选取name以"G"、"F"或"s"开始的所有网站：
SELECT * FROM Websites WHERE name REGEXP '^[GFs]';
下面的 SQL 语句选取 name 以 A 到 H 字母开头的网站：
SELECT * FROM Websites WHERE name REGEXP '^[A-H]';
下面的 SQL 语句选取 name 不以 A 到 H 字母开头的网站：
SELECT * FROM Websites WHERE name REGEXP '^[^A-H]';
IN
IN 操作符允许您在 WHERE 子句中规定多个值。
语法
SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1,value2,...);
IN 与 = 的异同
	 相同点：均在WHERE中使用作为筛选条件之一、均是等于的含义
	 不同点：IN可以规定多个值，等于规定一个值
in 与 = 的转换
select * from Websites where name in ('Google','菜鸟教程');
select * from Websites where name='Google' or name='菜鸟教程';
BETWEEN
BETWEEN 操作符选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。
语法
SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;
请注意，在不同的数据库中，BETWEEN 操作符会产生不同的结果！
在某些数据库中，BETWEEN 选取介于两个值之间但不包括两个测试值的字段。
在某些数据库中，BETWEEN 选取介于两个值之间且包括两个测试值的字段。
在某些数据库中，BETWEEN 选取介于两个值之间且包括第一个测试值但不包括最后一个测试值的字段。
因此，请检查您的数据库是如何处理 BETWEEN 操作符！
别名
通过使用 SQL，可以为表名称或列名称指定别名。基本上，创建别名是为了让列名称的可读性更强。
列的 SQL 别名语法
SELECT column_name AS alias_name
FROM table_name;
表的 SQL 别名语法
SELECT column_name(s)
FROM table_name AS alias_name;
在下面的情况下，使用别名很有用：
	在查询中涉及超过一个表
	在查询中使用了函数
	列名称很长或者可读性差
	需要把两个列或者多个列结合在一起
连接(JOIN)
SQL join 用于把来自两个或多个表的行结合起来。
下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。
![x](./Resource/24.png)

不同的 SQL JOIN
在我们继续讲解实例之前，我们先列出您可以使用的不同的 SQL JOIN 类型：
	INNER JOIN：内连接，又叫等值连接，只返回两个表中连接字段相等的行。
	LEFT JOIN：左连接，返回左表中所有的记录以及右表中连接字段相等的记录。
	RIGHT JOIN：右连接，返回右表中所有的记录以及左表中连接字段相等的记录。
	FULL JOIN：外连接，只要其中一个表中存在匹配，则返回行
	cross join：结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。
INNER JOIN
INNER JOIN 关键字在表中存在至少一个匹配时返回行。
语法
SELECT column_name(s)
FROM table1
[INNER] JOIN table2
ON table1.column_name=table2.column_name;
注释：INNER JOIN 与 JOIN 是相同的。
关键字 on
数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。
在使用 join 时，on 和 where 条件的区别如下：
	on 条件是在生成临时表时使用的条件
	where 条件是在临时表生成好后，再对临时表进行过滤的条件。
不管 on 上的条件是否为真都会返回 left 或 right 表中的记录，full 则具有 left 和 right 的特性的并集。 而 inner jion 没这个特殊性，则条件放在 on 中和 where 中，返回的结果集是相同的。
LEFT JOIN
LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。
语法
SELECT column_name(s)
FROM table1
LEFT [OUTER] JOIN table2
ON table1.column_name=table2.column_name;
注释：在某些数据库中，LEFT JOIN 称为 LEFT OUTER JOIN。
RIGHT JOIN 
RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。
语法
SELECT column_name(s)
FROM table1
RIGHT [OUTER] JOIN table2
ON table1.column_name=table2.column_name;
注释：在某些数据库中，RIGHT JOIN 称为 RIGHT OUTER JOIN。
FULL OUTER JOIN
FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.
FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。
语法
SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name=table2.column_name;
UNION
UNION 操作符用于合并两个或多个 SELECT 语句的结果集。
请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。
语法
SELECT column_name(s) FROM table1
UNION [ALL]
SELECT column_name(s) FROM table2;
注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。
使用UNION命令时需要注意，只能在最后使用一个ORDER BY命令，是将两个查询结果合在一起之后，再进行排序！绝对不能写两个ORDER BY命令。
另外，在使用ORDER BY排序时，注意两个结果的别名保持一致，使用别名排序很方便。当然也可以使用列数。
ORDER BY 除了可以对指定的字段进行排序，还可以使用函数进行排序:
order by abs(a);
ORDER BY 只能当前 SQL 查询结果进行排序，如要对 union all 出来的结果进行排序，需要先做集合。
select aa.* from 
(select country,name from websites where country = 'CN'
union all select country,app_name from apps where country='CN' ) aa
order by aa.name;
SELECT INTO
通过 SQL，您可以从一个表复制信息到另一个表。SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。
MySQL 数据库不支持 SELECT ... INTO 语句，但支持 INSERT INTO ... SELECT 。
当然你可以使用以下语句来拷贝表结构及数据：
CREATE TABLE 新表
AS
SELECT * FROM 旧表 
语法
SELECT column_name(s)
INTO newtable [IN externaldb]
FROM table1;
提示：新表将会使用 SELECT 语句中定义的列名称和类型进行创建（全部列可以用*）。您可以使用 AS 子句来应用新名称。
SELECT INTO 语句可用于通过另一种模式创建一个新的空表。只需要添加促使查询没有数据返回的 WHERE 子句即可：
SELECT * INTO newtable FROM table1 WHERE 1=0;
INSERT INTO SELECT
通过 SQL，您可以从一个表复制信息到另一个表。
INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。
语法
INSERT INTO table2
[(column_name(s))]
SELECT [column_name(s)|*]
FROM table1;
select into from 和 insert into select 都是用来复制表
两者的主要区别为：select into from 要求目标表不存在，因为在插入时会自动创建；insert into select from 要求目标表存在。
MySQL:
1. 复制表结构及其数据：
create table table_name_new as select * from table_name_old
2. 只复制表结构：
create table table_name_new as select * from table_name_old where 1=2;
或者：
create table table_name_new like table_name_old
3. 只复制表数据：
如果两个表结构一样：
insert into table_name_new select * from table_name_old
如果两个表结构不一样：
insert into table_name_new(column1,column2...) select column1,column2... from table_name_old
CREATE DATABASE
CREATE DATABASE 语句用于创建数据库。
语法
CREATE DATABASE dbname;
CREATE TABLE 
CREATE TABLE 语句用于创建数据库中的表。表由行和列组成，每个表都必须有个表名。
语法
CREATE TABLE table_name
(
column_name1 data_type(size),
column_name2 data_type(size),
column_name3 data_type(size),
....
);
column_name 参数规定表中列的名称。
data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。
size 参数规定表中列的最大长度。
提示：如需了解 MS Access、MySQL 和 SQL Server 中可用的数据类型，请访问完整的数据类型参考手册。
约束(Constraints)
SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。
约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。
语法
CREATE TABLE table_name
(
column_name1 data_type(size) constraint_name,
column_name2 data_type(size) constraint_name,
column_name3 data_type(size) constraint_name,
....
);
在 SQL 中，我们有如下约束：
	NOT NULL - 指示某列不能存储 NULL 值。
	UNIQUE - 保证某列的每行必须有唯一的值。
	PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。
	FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。
	CHECK - 保证列中的值符合指定的条件。
	DEFAULT - 规定没有给列赋值时的默认值。
NOT NULL
在默认的情况下，表的列接受 NULL 值。
NOT NULL 约束强制列不接受 NULL 值。
NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。
下面的 SQL 强制 "P_Id" 列和 "LastName" 列不接受 NULL 值：
CREATE TABLE Persons
(
    P_Id int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
)
删除表的字段的 not null 约束：
alter table x modify column_name null;
添加not null 约束：
alter table x modify column_name not null;
UNIQUE
UNIQUE 约束唯一标识数据库表中的每条记录。
UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。
请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。
CREATE TABLE 时的 SQL UNIQUE 约束
下面的 SQL 在 "Persons" 表创建时在 "P_Id" 列上创建 UNIQUE 约束：
MySQL：
CREATE TABLE Persons
(
    P_Id int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255),
    UNIQUE (P_Id)
)
SQL Server / Oracle / MS Access：
CREATE TABLE Persons
(
    P_Id int NOT NULL UNIQUE,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
)
如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：
MySQL / SQL Server / Oracle / MS Access：
CREATE TABLE Persons
(
    P_Id int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255),
    CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)
)
ALTER TABLE 时的 SQL UNIQUE 约束
当表已被创建时，如需在 "P_Id" 列创建 UNIQUE 约束，请使用下面的 SQL：
MySQL / SQL Server / Oracle / MS Access：
ALTER TABLE Persons ADD UNIQUE (P_Id)
如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：
MySQL / SQL Server / Oracle / MS Access：
ALTER TABLE Persons ADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)
撤销 UNIQUE 约束
如需撤销 UNIQUE 约束，请使用下面的 SQL：
MySQL：
ALTER TABLE Persons DROP INDEX uc_PersonID
SQL Server / Oracle / MS Access：
ALTER TABLE Persons DROP CONSTRAINT uc_PersonID
MySQL示例：
create table tb2(
    tb2_id int unique,
    tb2_name varchar(20),
    tb2_age int,
    unique(tb2_name)
);

select * from tb2;
insert into tb2(tb2_id,tb2_name,tb2_age) values (1,'张三',20);

--违反唯一约束
insert into tb2 values(2,'张三',25);

--建表时，创建约束，有约束名
create table tb3(
    tb3_id int ,
    tb3_name varchar(20),
    tb3_age int,
    constraint no_id unique (tb3_id)
);

insert into tb3 values (1,'张三',20);
insert into tb3(tb3_id,tb3_age) values(2,24);
select * from tb3;

--已经有了tb3_id为1的行记录，再次插入，违反唯一约束
insert into tb3(tb3_id,tb3_name,tb3_age) values(1,'李四',25);

--给tb3表添加主键约束，主键名为：pk_id
alter table tb3 add constraint pk_id primary key (tb3_id);

--给tb3_name添加唯一约束
alter table tb3 add constraint un_name unique (tb3_name);

--已存在姓名为张三的记录，违反唯一约束
insert into tb3 values (3,'张三',26);

--mysql 删除约束的语句，使用index，oracle SqlServer等使用constraint
alter table tb3 drop index un_name;

--删除约束后，允许存在多个tb3_name为张三的记录
insert into tb3 values (3,'张三',26);
sql server 2008 删除约束的语句
alter table table_name drop constraint_name;
uc_PersonID 是一个约束名！上面建的是唯一约束，为了方便区别约束名一般起得有规律点比如 UC（就是 UNIQUE CONSTRAINT 的缩写意思是唯一约束） uc_PersonID 就是对表中的PersonID 建唯一约束，强制约束 Id_P 和 LastName 唯一。
PRIMARY KEY
PRIMARY KEY 约束唯一标识数据库表中的每条记录。
主键必须包含唯一的值。
主键列不能包含 NULL 值。
每个表都应该有一个主键，并且每个表只能有一个主键。
CREATE TABLE 时的 SQL PRIMARY KEY 约束
下面的 SQL 在 "Persons" 表创建时在 "P_Id" 列上创建 PRIMARY KEY 约束：
MySQL：
CREATE TABLE Persons
(
    P_Id int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255),
    PRIMARY KEY (P_Id)
)
SQL Server / Oracle / MS Access：
CREATE TABLE Persons
(
    P_Id int NOT NULL PRIMARY KEY,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
)
如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法：
MySQL / SQL Server / Oracle / MS Access：
CREATE TABLE Persons
(
    P_Id int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255),
    CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)
)
注释：在上面的实例中，只有一个主键 PRIMARY KEY（pk_PersonID）。然而，pk_PersonID 的值是由两个列（P_Id 和 LastName）组成的。
ALTER TABLE 时的 SQL PRIMARY KEY 约束
当表已被创建时，如需在 "P_Id" 列创建 PRIMARY KEY 约束，请使用下面的 SQL：
MySQL / SQL Server / Oracle / MS Access：
ALTER TABLE Persons ADD PRIMARY KEY (P_Id)
如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法：
MySQL / SQL Server / Oracle / MS Access：
ALTER TABLE Persons ADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)
注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。
撤销 PRIMARY KEY 约束
如需撤销 PRIMARY KEY 约束，请使用下面的 SQL：
MySQL：
ALTER TABLE Persons DROP PRIMARY KEY
SQL Server / Oracle / MS Access：
ALTER TABLE Persons DROP CONSTRAINT pk_PersonID
撤销PRIMARY KEY约束时，不论约束条件为一列还是多列，对于MySQL，撤销都是
ALTER TABLE Persons DROP PRIMARY KEY
由于PRIMARY KEY唯一性，MYSQL处理办法简单。
但对于 SQL Server / Oracle / MS Access，一个列
ALTER TABLE Persons DROP CONSTRAINT P_Id
若起约束名，也可如下多个列
ALTER TABLE Persons DROP CONSTRAINT pk_PersonID
FOREIGN KEY
一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY（唯一约束的键）。让我们通过一个实例来解释外键。请看下面两个表：
"Persons" 表：
P_Id	LastName	FirstName	Address	City
1	Hansen	Ola	Timoteivn 10	Sandnes
2	Svendson	Tove	Borgvn 23	Sandnes
3	Pettersen	Kari	Storgt 20	Stavanger
"Orders" 表：
O_Id	OrderNo	P_Id
1	77895	3
2	44678	3
3	22456	2
4	24562	1
请注意，"Orders" 表中的 "P_Id" 列指向 "Persons" 表中的 "P_Id" 列。
"Persons" 表中的 "P_Id" 列是 "Persons" 表中的 PRIMARY KEY。
"Orders" 表中的 "P_Id" 列是 "Orders" 表中的 FOREIGN KEY。
FOREIGN KEY 约束用于预防破坏表之间连接的行为。
FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
CREATE TABLE 时的 SQL FOREIGN KEY 约束
下面的 SQL 在 "Orders" 表创建时在 "P_Id" 列上创建 FOREIGN KEY 约束：
MySQL：
CREATE TABLE Orders
(
    O_Id int NOT NULL,
    OrderNo int NOT NULL,
    P_Id int,
    PRIMARY KEY (O_Id),
    FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)
)
SQL Server / Oracle / MS Access：
CREATE TABLE Orders
(
    O_Id int NOT NULL PRIMARY KEY,
    OrderNo int NOT NULL,
    P_Id int FOREIGN KEY REFERENCES Persons(P_Id)
)
如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法：
MySQL / SQL Server / Oracle / MS Access：
CREATE TABLE Orders
(
    O_Id int NOT NULL,
    OrderNo int NOT NULL,
    P_Id int,
    PRIMARY KEY (O_Id),
    CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)
)
ALTER TABLE 时的 SQL FOREIGN KEY 约束
当 "Orders" 表已被创建时，如需在 "P_Id" 列创建 FOREIGN KEY 约束，请使用下面的 SQL：
MySQL / SQL Server / Oracle / MS Access：
ALTER TABLE Orders ADD FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)
如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法：
MySQL / SQL Server / Oracle / MS Access：
ALTER TABLE Orders ADD CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)
撤销 FOREIGN KEY 约束
如需撤销 FOREIGN KEY 约束，请使用下面的 SQL：
MySQL：
ALTER TABLE Orders DROP FOREIGN KEY fk_PerOrders
SQL Server / Oracle / MS Access：
ALTER TABLE Orders DROP CONSTRAINT fk_PerOrders

创建外键约束的方式
在创建表的时候指定外键约束
CREATE TABLE 表名
    (
        column1 datatype null/not null,
        column2 datatype null/not null,
        ...
        CONSTRAINT 外键约束名 FOREIGN KEY  (column1,column2,... column_n) 
        REFERENCES 外键依赖的表 (column1,column2,...column_n)
        ON DELETE CASCADE--级联删除
    );
在创建表后增加外键约束
ALTER TABLE 表名
    ADD CONSTRAINT 外键约束名
    FOREIGN KEY (column1, column2,...column_n) 
    REFERENCES 外键所依赖的表 (column1,column2,...column_n)
    ON DELETE CASCADE;--级联删除
使用工具plsql来新增外键约束
注意，在创建外键约束时，必须先创建外键约束所依赖的表，并且该列为该表的主键
Oracle数据库中，对指定外键的表进行增删改的情况：
子表：谁创建外键谁就是子表
父表：这个外键所依赖的表
create table father(
    f_no number(2)
);--插入数据1 2 3 4

create table son(
    s_no number(2),
    f_no number(2)
)--插入两列1 2 3 4

--删除父表数据
delete from father where f_no=1 --报错违反约束

--删除父表
drop table father  --报错违反约束

--更新父表数据
--禁用约束可以更新ALTER TABLE son disable constraint f_f; 

update father set f_no =7 where f_no=1--报错违反约束

--对父表插入数据
insert into father values(6)--可以插入

--删除子表数据
delete from son where s_on=1--可以删除

--删除子表
drop table son--可以删除

--更新子表数据
update son set s_no=6 where s_no=1 --可以更新
update son set f_no=6 where s_no=6  --可以更新

--对子表插入数据 
insert into son values(7,7)--父表没有7，违反约束
insert into son values(1,1)--父表有1可以插入    
insert into son values(8,1)--父表有1可以插入
总结：
一、删除时，未指定cascade时
  1）删除父表/数据
     a. 因为子表与父表一一对应，删除父表数据时，需要先把子表对应数据删除否则无法删除
     b. 同理，删除表的时候，也需要先删除子表再删除父表
解决方案：
     a.指定cascade，删除父表、数据
       CASCADE指当删除主表中被引用列的数据时，级联删除子表中相应的数据行。
     b.禁用约束（子表的外键约束）
       ALTER TABLE 表名 disable constraint 约束名;
 2）删除子表：可以删除子表或者数据不报错
二、更新时
        a.更新父表会违反约束
        b.可以更新子表
        c.没有针对约束的级联更新
三、插入时
         a.父表可以插入
         b.子表插入会违反约束 
CHECK
CHECK 约束用于限制列中的值的范围。
如果对单个列定义 CHECK 约束，那么该列只允许特定的值。
如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。
CREATE TABLE 时的 SQL CHECK 约束
下面的 SQL 在 "Persons" 表创建时在 "P_Id" 列上创建 CHECK 约束。CHECK 约束规定 "P_Id" 列必须只包含大于 0 的整数。
MySQL：
CREATE TABLE Persons
(
    P_Id int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255),
    CHECK (P_Id>0)
)
SQL Server / Oracle / MS Access：
CREATE TABLE Persons
(
    P_Id int NOT NULL CHECK (P_Id>0),
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
)
如需命名 CHECK 约束，并定义多个列的 CHECK 约束，请使用下面的 SQL 语法：
MySQL / SQL Server / Oracle / MS Access：
CREATE TABLE Persons
(
    P_Id int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255),
    CONSTRAINT chk_Person CHECK (P_Id>0 AND City='Sandnes')
)
ALTER TABLE 时的 SQL CHECK 约束
当表已被创建时，如需在 "P_Id" 列创建 CHECK 约束，请使用下面的 SQL：
MySQL / SQL Server / Oracle / MS Access:
ALTER TABLE Persons ADD CHECK (P_Id>0)
如需命名 CHECK 约束，并定义多个列的 CHECK 约束，请使用下面的 SQL 语法：
MySQL / SQL Server / Oracle / MS Access：
ALTER TABLE Persons ADD CONSTRAINT chk_Person CHECK (P_Id>0 AND City='Sandnes')
撤销 CHECK 约束
如需撤销 CHECK 约束，请使用下面的 SQL：
SQL Server / Oracle / MS Access：
ALTER TABLE Persons DROP CONSTRAINT chk_Person
MySQL：
ALTER TABLE Persons DROP CHECK chk_Person
DEFAULT 
DEFAULT 约束用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。
CREATE TABLE 时的 SQL DEFAULT 约束
下面的 SQL 在 "Persons" 表创建时在 "City" 列上创建 DEFAULT 约束：
My SQL / SQL Server / Oracle / MS Access：
CREATE TABLE Persons
(
    P_Id int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255) DEFAULT 'Sandnes'
)
通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值：
CREATE TABLE Orders
(
    O_Id int NOT NULL,
    OrderNo int NOT NULL,
    P_Id int,
    OrderDate date DEFAULT GETDATE()
)
ALTER TABLE 时的 SQL DEFAULT 约束
当表已被创建时，如需在 "City" 列创建 DEFAULT 约束，请使用下面的 SQL：
MySQL：
ALTER TABLE Persons ALTER City SET DEFAULT 'SANDNES'
SQL Server / MS Access：
ALTER TABLE Persons ADD CONSTRAINT ab_c DEFAULT 'SANDNES' for City
Oracle：
ALTER TABLE Persons MODIFY City DEFAULT 'SANDNES'
撤销 DEFAULT 约束
如需撤销 DEFAULT 约束，请使用下面的 SQL：
MySQL：
ALTER TABLE Persons ALTER City DROP DEFAULT
SQL Server / Oracle / MS Access：
ALTER TABLE Persons ALTER COLUMN City DROP DEFAULT
CREATE INDEX
CREATE INDEX 语句用于在表中创建索引。在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。
您可以在表中创建索引，以便更加快速高效地查询数据。
用户无法看到索引，它们只能被用来加速搜索/查询。
注释：更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。
SQL CREATE INDEX 语法
在表上创建一个简单的索引。允许使用重复的值：
CREATE INDEX index_name ON table_name (column_name)
SQL CREATE UNIQUE INDEX 语法
在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值。Creates a unique index on a table. Duplicate values are not allowed:
CREATE UNIQUE INDEX index_name ON table_name (column_name)
注释：用于创建索引的语法在不同的数据库中不一样。因此，检查您的数据库中创建索引的语法。
DROP
通过使用 DROP 语句，可以轻松地删除索引、表和数据库。
DROP INDEX 语句
DROP INDEX 语句用于删除表中的索引。
用于 MS Access 的 DROP INDEX 语法：
DROP INDEX index_name ON table_name
用于 MS SQL Server 的 DROP INDEX 语法：
DROP INDEX table_name.index_name
用于 DB2/Oracle 的 DROP INDEX 语法：
DROP INDEX index_name
用于 MySQL 的 DROP INDEX 语法：
ALTER TABLE table_name DROP INDEX index_name
DROP TABLE 语句
DROP TABLE 语句用于删除表。
DROP TABLE table_name
DROP DATABASE 语句
DROP DATABASE 语句用于删除数据库。
DROP DATABASE database_name
TRUNCATE TABLE 语句
如果我们仅仅需要删除表内的数据，但并不删除表本身，那么我们该如何做呢？
请使用 TRUNCATE TABLE 语句：
TRUNCATE TABLE table_name
ALTER TABLE
ALTER TABLE 语句用于在已有的表中添加、删除或修改列。
SQL ALTER TABLE 语法
如需在表中添加列，请使用下面的语法:
ALTER TABLE table_name ADD column_name datatype
如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：
ALTER TABLE table_name DROP COLUMN column_name
要改变表中列的数据类型，请使用下面的语法：
SQL Server / MS Access：
ALTER TABLE table_name ALTER COLUMN column_name datatype
MySQL / Oracle：
ALTER TABLE table_name MODIFY COLUMN column_name datatype
Oracle 10G 之后版本：
ALTER TABLE table_name MODIFY column_name datatype;
AUTO INCREMENT 
Auto-increment 会在新记录插入表中时生成一个唯一的数字。
用于 MySQL 的语法
下面的 SQL 语句把 "Persons" 表中的 "ID" 列定义为 auto-increment 主键字段：
CREATE TABLE Persons
(
    ID int NOT NULL AUTO_INCREMENT,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255),
    PRIMARY KEY (ID)
)
MySQL 使用 AUTO_INCREMENT 关键字来执行 auto-increment 任务。
默认地，AUTO_INCREMENT 的开始值是 1，每条新记录递增 1。
要让 AUTO_INCREMENT 序列以其他的值起始，请使用下面的 SQL 语法：
ALTER TABLE Persons AUTO_INCREMENT=100
要在 "Persons" 表中插入新记录，我们不必为 "ID" 列规定值（会自动添加一个唯一的值）：
INSERT INTO Persons (FirstName,LastName) VALUES ('Lars','Monsen')
上面的 SQL 语句会在 "Persons" 表中插入一条新记录。"ID" 列会被赋予一个唯一的值。"FirstName" 列会被设置为 "Lars"，"LastName" 列会被设置为 "Monsen"。
用于 SQL Server 的语法
下面的 SQL 语句把 "Persons" 表中的 "ID" 列定义为 auto-increment 主键字段：
CREATE TABLE Persons
(
    ID int IDENTITY(1,1) PRIMARY KEY,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
)
MS SQL Server 使用 IDENTITY 关键字来执行 auto-increment 任务。
在上面的实例中，IDENTITY 的开始值是 1，每条新记录递增 1。
提示：要规定 "ID" 列以 10 起始且递增 5，请把 identity 改为 IDENTITY(10,5)。
要在 "Persons" 表中插入新记录，我们不必为 "ID" 列规定值（会自动添加一个唯一的值）。
用于 Access 的语法
下面的 SQL 语句把 "Persons" 表中的 "ID" 列定义为 auto-increment 主键字段：
CREATE TABLE Persons
(
    ID Integer PRIMARY KEY AUTOINCREMENT,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
)
MS Access 使用 AUTOINCREMENT 关键字来执行 auto-increment 任务。
默认地，AUTOINCREMENT 的开始值是 1，每条新记录递增 1。
提示：要规定 "ID" 列以 10 起始且递增 5，请把 autoincrement 改为 AUTOINCREMENT(10,5)。
要在 "Persons" 表中插入新记录，我们不必为 "ID" 列规定值（会自动添加一个唯一的值）
用于 Oracle 的语法
在 Oracle 中，代码稍微复杂一点。
您必须通过 sequence 对象（该对象生成数字序列）创建 auto-increment 字段。
请使用下面的 CREATE SEQUENCE 语法：
CREATE SEQUENCE seq_person
MINVALUE 1
START WITH 1
INCREMENT BY 1
CACHE 10
上面的代码创建一个名为 seq_person 的 sequence 对象，它以 1 起始且以 1 递增。该对象缓存 10 个值以提高性能。cache 选项规定了为了提高访问速度要存储多少个序列值。
要在 "Persons" 表中插入新记录，我们必须使用 nextval 函数（该函数从 seq_person 序列中取回下一个值）：
INSERT INTO Persons (ID,FirstName,LastName) VALUES (seq_person.nextval,'Lars','Monsen')
给已经存在的colume添加自增语法：
ALTER TABLE table_name CHANGE column_name column_name data_type(size) constraint_name AUTO_INCREMENT;
比如：
ALTER TABLE student CHANGE id id INT(11) NOT NULL AUTO_INCREMENT;
视图(Views)
在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。
视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。
您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。
语法
CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
注释：视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。
您可以使用下面的语法来更新视图：
CREATE OR REPLACE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
SQL Server
ALTER VIEW [ schema_name . ] view_name [ ( column [ ,...n ] ) ] 
[ WITH <view_attribute> [ ,...n ] ] 
AS select_statement 
[ WITH CHECK OPTION ] [ ; ]

<view_attribute> ::= 
{ 
    [ ENCRYPTION ]
    [ SCHEMABINDING ]
    [ VIEW_METADATA ]     
} 
	schema_name: 视图所属架构的名称。
	view_name: 要更改的视图。
	column: 将成为指定视图的一部分的一个或多个列的名称（以逗号分隔）。
撤销视图
DROP VIEW view_name
视图的作用：
1、视图隐藏了底层的表结构，简化了数据访问操作，客户端不再需要知道底层表的结构及其之间的关系。
2、视图提供了一个统一访问数据的接口。（即可以允许用户通过视图访问数据的安全机制，而不授予用户直接访问底层表的权限）
3、从而加强了安全性，使用户只能看到视图所显示的数据。
4、视图还可以被嵌套，一个视图中可以嵌套另一个视图。
Date函数
当我们处理日期时，最难的任务恐怕是确保所插入的日期的格式，与数据库中日期列的格式相匹配。
只要您的数据包含的只是日期部分，运行查询就不会出问题。但是，如果涉及时间部分，情况就有点复杂了。
在讨论日期查询的复杂性之前，我们先来看看最重要的内建日期处理函数。
MySQL Date 函数
下面的表格列出了 MySQL 中最重要的内建日期函数：
函数	描述
NOW()
返回当前的日期和时间
CURDATE()
返回当前的日期
CURTIME()
返回当前的时间
DATE()
提取日期或日期/时间表达式的日期部分
EXTRACT()
返回日期/时间的单独部分
DATE_ADD()
向日期添加指定的时间间隔
DATE_SUB()
从日期减去指定的时间间隔
DATEDIFF()
返回两个日期之间的天数
DATE_FORMAT()
用不同的格式显示日期/时间
SQL Server Date 函数
下面的表格列出了 SQL Server 中最重要的内建日期函数：
函数	描述
GETDATE()
返回当前的日期和时间
DATEPART()
返回日期/时间的单独部分
DATEADD()
在日期中添加或减去指定的时间间隔
DATEDIFF()
返回两个日期之间的时间
CONVERT()
用不同的格式显示日期/时间
SQL Date 数据类型
MySQL 使用下列数据类型在数据库中存储日期或日期/时间值：
	DATE - 格式：YYYY-MM-DD
	DATETIME - 格式：YYYY-MM-DD HH:MM:SS
	TIMESTAMP - 格式：YYYY-MM-DD HH:MM:SS
	YEAR - 格式：YYYY 或 YY
SQL Server 使用下列数据类型在数据库中存储日期或日期/时间值：
	DATE - 格式：YYYY-MM-DD
	DATETIME - 格式：YYYY-MM-DD HH:MM:SS
	SMALLDATETIME - 格式：YYYY-MM-DD HH:MM:SS
	TIMESTAMP - 格式：唯一的数字
NULL值
如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下插入新记录或更新已有的记录。这意味着该字段将以 NULL 值保存。
NULL 值的处理方式与其他值不同。NULL 用作未知的或不适用的值的占位符。
注释：无法比较 NULL 和 0；它们是不等价的。
无法使用比较运算符来测试 NULL 值，比如 =、< 或 <>。我们必须使用 IS NULL 和 IS NOT NULL 操作符。
SQL ISNULL()、NVL()、IFNULL() 和 COALESCE() 函数
微软的 ISNULL() 函数用于规定如何处理 NULL 值。NVL()、IFNULL() 和 COALESCE() 函数也可以达到相同的结果。
在这里，我们希望 NULL 值为 0。下面，如果 "UnitsOnOrder" 是 NULL，则不会影响计算，因为如果值是 NULL 则 ISNULL() 返回 0：
SQL Server / MS Access
SELECT ProductName,UnitPrice*(UnitsInStock+ISNULL(UnitsOnOrder,0))
FROM Products
Oracle
Oracle 没有 ISNULL() 函数。不过，我们可以使用 NVL() 函数达到相同的结果：
SELECT ProductName,UnitPrice*(UnitsInStock+NVL(UnitsOnOrder,0))
FROM Products
MySQL
MySQL 也拥有类似 ISNULL() 的函数。不过它的工作方式与微软的 ISNULL() 函数有点不同。
在 MySQL 中，我们可以使用 IFNULL() 函数，如下所示：
SELECT ProductName,UnitPrice*(UnitsInStock+IFNULL(UnitsOnOrder,0))
FROM Products
或者我们可以使用 COALESCE() 函数，如下所示：
SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0))
FROM Products
通用数据类型
数据库表中的每个列都要求有名称和数据类型。Each column in a database table is required to have a name and a data type.
SQL 开发人员必须在创建 SQL 表时决定表中的每个列将要存储的数据的类型。数据类型是一个标签，是便于 SQL 了解每个列期望存储什么类型的数据的指南，它也标识了 SQL 如何与存储的数据进行交互。
下面的表格列出了 SQL 中通用的数据类型：
数据类型	描述
CHARACTER(n)	字符/字符串。固定长度 n。
VARCHAR(n) 或
CHARACTER VARYING(n)	字符/字符串。可变长度。最大长度 n。
BINARY(n)	二进制串。固定长度 n。
BOOLEAN	存储 TRUE 或 FALSE 值
VARBINARY(n) 或
BINARY VARYING(n)	二进制串。可变长度。最大长度 n。
INTEGER(p)	整数值（没有小数点）。精度 p。
SMALLINT	整数值（没有小数点）。精度 5。
INTEGER	整数值（没有小数点）。精度 10。
BIGINT	整数值（没有小数点）。精度 19。
DECIMAL(p,s)	精确数值，精度 p，小数点后位数 s。例如：decimal(5,2) 是一个小数点前有 3 位数，小数点后有 2 位数的数字。
NUMERIC(p,s)	精确数值，精度 p，小数点后位数 s。（与 DECIMAL 相同）
FLOAT(p)	近似数值，尾数精度 p。一个采用以 10 为基数的指数计数法的浮点数。该类型的 size 参数由一个指定最小精度的单一数字组成。
REAL	近似数值，尾数精度 7。
FLOAT	近似数值，尾数精度 16。
DOUBLE PRECISION	近似数值，尾数精度 16。
DATE	存储年、月、日的值。
TIME	存储小时、分、秒的值。
TIMESTAMP	存储年、月、日、小时、分、秒的值。
INTERVAL	由一些整数字段组成，代表一段时间，取决于区间的类型。
ARRAY	元素的固定长度的有序集合
MULTISET	元素的可变长度的无序集合
XML	存储 XML 数据
SQL 数据类型快速参考手册
然而，不同的数据库对数据类型定义提供不同的选择。
下面的表格显示了各种不同的数据库平台上一些数据类型的通用名称：
数据类型	Access	SQLServer	Oracle	MySQL	PostgreSQL
boolean	Yes/No	Bit	Byte	N/A	Boolean
integer	Number (integer)	Int	Number	Int
Integer	Int
Integer
float	Number (single)	Float
Real	Number	Float	Numeric
currency	Currency	Money	N/A	N/A	Money
string (fixed)	N/A	Char	Char	Char	Char
string (variable)	Text (<256)
Memo (65k+)	Varchar	Varchar
Varchar2	Varchar	Varchar
binary object	OLE Object Memo	Binary (fixed up to 8K)
Varbinary (<8K)
Image (<2GB)	Long
Raw	Blob
Text	Binary
Varbinary
注释：在不同的数据库中，同一种数据类型可能有不同的名称。即使名称相同，尺寸和其他细节也可能不同！ 请总是检查文档！
Microsoft Access 数据类型
数据类型	描述	存储
Text	用于文本或文本与数字的组合。最多 255 个字符。	
Memo	Memo 用于更大数量的文本。最多存储 65,536 个字符。注释：无法对 memo 字段进行排序。不过它们是可搜索的。	
Byte	允许 0 到 255 的数字。	1 字节
Integer	允许介于 -32,768 与 32,767 之间的全部数字。	2 字节
Long	允许介于 -2,147,483,648 与 2,147,483,647 之间的全部数字。	4 字节
Single	单精度浮点。处理大多数小数。	4 字节
Double	双精度浮点。处理大多数小数。	8 字节
Currency	用于货币。支持 15 位的元，外加 4 位小数。提示：您可以选择使用哪个国家的货币。	8 字节
AutoNumber	AutoNumber 字段自动为每条记录分配数字，通常从 1 开始。	4 字节
Date/Time	用于日期和时间	8 字节
Yes/No	逻辑字段，可以显示为 Yes/No、True/False 或 On/Off。在代码中，使用常量 True 和 False （等价于 1 和 0）。注释：Yes/No 字段中不允许 Null 值	1 比特
Ole Object	可以存储图片、音频、视频或其他 BLOBs（Binary Large OBjects）。	最多 1GB
Hyperlink	包含指向其他文件的链接，包括网页。	
Lookup Wizard	允许您创建一个可从下拉列表中进行选择的选项列表。	4 字节
MySQL 数据类型
在 MySQL 中，有三种主要的类型：Text（文本）、Number（数字）和 Date/Time（日期/时间）类型。
Text 类型：
数据类型	描述
CHAR(size)	保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。
VARCHAR(size)	保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。
TINYTEXT	存放最大长度为 255 个字符的字符串。
TEXT	存放最大长度为 65,535 个字符的字符串。
BLOB	用于 BLOBs（Binary Large OBjects）。存放最多 65,535 字节的数据。
MEDIUMTEXT	存放最大长度为 16,777,215 个字符的字符串。
MEDIUMBLOB	用于 BLOBs（Binary Large OBjects）。存放最多 16,777,215 字节的数据。
LONGTEXT	存放最大长度为 4,294,967,295 个字符的字符串。
LONGBLOB	用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。
ENUM(x,y,z,etc.)	允许您输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。
注释：这些值是按照您输入的顺序排序的。
可以按照此格式输入可能的值： ENUM('X','Y','Z')
SET	与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。
Number 类型：
数据类型	描述
TINYINT(size)	带符号-128到127 ，无符号0到255。
SMALLINT(size)	带符号范围-32768到32767，无符号0到65535, size 默认为 6。
MEDIUMINT(size)	带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9
INT(size)	带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11
BIGINT(size)	带符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size 默认为 20
FLOAT(size,d)	带有浮动小数点的小数字。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。
DOUBLE(size,d)	带有浮动小数点的大数字。在 size 参数中规显示定最大位数。在 d 参数中规定小数点右侧的最大位数。
DECIMAL(size,d)	作为字符串存储的 DOUBLE 类型，允许固定的小数点。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。
注意：以上的 size 代表的并不是存储在数据库中的具体的长度，如 int(4) 并不是只能存储4个长度的数字。
实际上int(size)所占多少存储空间并无任何关系。int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。就是在显示给用户的方式有点不同外，int(M) 跟 int 数据类型是相同的。
例如：
1、int的值为10 （指定zerofill）
int(9) 显示结果为000000010
int(3) 显示结果为010
就是显示的长度不一样而已 都是占用四个字节的空间
Date 类型：
数据类型	描述
DATE()	日期。格式：YYYY-MM-DD
注释：支持的范围是从 '1000-01-01' 到 '9999-12-31'
DATETIME()	*日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS
注释：支持的范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'
TIMESTAMP()	*时间戳。TIMESTAMP 值使用 Unix 纪元('1970-01-01 00:00:00' UTC) 至今的秒数来存储。格式：YYYY-MM-DD HH:MM:SS
注释：支持的范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC
TIME()	时间。格式：HH:MM:SS
注释：支持的范围是从 '-838:59:59' 到 '838:59:59'
YEAR()	2 位或 4 位格式的年。
注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。
即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。
SQL Server 数据类型
String 类型：
数据类型	描述	存储
char(n)	固定长度的字符串。最多 8,000 个字符。	Defined width
varchar(n)	可变长度的字符串。最多 8,000 个字符。	2 bytes + number of chars
varchar(max)	可变长度的字符串。最多 1,073,741,824 个字符。	2 bytes + number of chars
text	可变长度的字符串。最多 2GB 文本数据。	4 bytes + number of chars
nchar	固定长度的 Unicode 字符串。最多 4,000 个字符。	Defined width x 2
nvarchar	可变长度的 Unicode 字符串。最多 4,000 个字符。	
nvarchar(max)	可变长度的 Unicode 字符串。最多 536,870,912 个字符。	
ntext	可变长度的 Unicode 字符串。最多 2GB 文本数据。	
bit	允许 0、1 或 NULL	
binary(n)	固定长度的二进制字符串。最多 8,000 字节。	
varbinary	可变长度的二进制字符串。最多 8,000 字节。	
varbinary(max)	可变长度的二进制字符串。最多 2GB。	
image	可变长度的二进制字符串。最多 2GB。	
Number 类型：
数据类型	描述	存储
tinyint	允许从 0 到 255 的所有数字。	1 字节
smallint	允许介于 -32,768 与 32,767 的所有数字。	2 字节
int	允许介于 -2,147,483,648 与 2,147,483,647 的所有数字。	4 字节
bigint	允许介于 -9,223,372,036,854,775,808 与 9,223,372,036,854,775,807 之间的所有数字。	8 字节
decimal(p,s)	固定精度和比例的数字。
允许从 -10^38 +1 到 10^38 -1 之间的数字。
p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。
s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。	5-17 字节
numeric(p,s)	固定精度和比例的数字。
允许从 -10^38 +1 到 10^38 -1 之间的数字。
p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。
s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。	5-17 字节
smallmoney	介于 -214,748.3648 与 214,748.3647 之间的货币数据。	4 字节
money	介于 -922,337,203,685,477.5808 与 922,337,203,685,477.5807 之间的货币数据。	8 字节
float(n)	从 -1.79E + 308 到 1.79E + 308 的浮动精度数字数据。
n 参数指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。	4 或 8 字节
real	从 -3.40E + 38 到 3.40E + 38 的浮动精度数字数据。	4 字节
Date 类型：
数据类型	描述	存储
datetime	从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。	8 字节
datetime2	从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。	6-8 字节
smalldatetime	从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。	4 字节
date	仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。	3 bytes
time	仅存储时间。精度为 100 纳秒。	3-5 字节
datetimeoffset	与 datetime2 相同，外加时区偏移。	8-10 字节
timestamp	存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 值基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。	
其他数据类型：
数据类型	描述
sql_variant	存储最多 8,000 字节不同数据类型的数据，除了 text、ntext 以及 timestamp。
uniqueidentifier	存储全局唯一标识符 (GUID)。
xml	存储 XML 格式化数据。最多 2GB。
cursor	存储对用于数据库操作的指针的引用。
table	存储结果集，供稍后处理。
函数
SQL 拥有很多可用于计数和计算的内建函数。
SQL Aggregate函数
SQL Aggregate函数计算从列中取得的值，返回一个单一的值。
有用的 Aggregate 函数：
	AVG() - 返回平均值
	COUNT() - 返回行数
	FIRST() - 返回第一个记录的值
	LAST() - 返回最后一个记录的值
	MAX() - 返回最大值
	MIN() - 返回最小值
	SUM() - 返回总和
SQL Scalar函数
SQL Scalar函数基于输入值，返回一个单一的值。
有用的 Scalar 函数：
	UCASE() - 将某个字段转换为大写
	LCASE() - 将某个字段转换为小写
	MID() - 从某个文本字段提取字符，MySql 中使用
	SubString(字段，1，end) - 从某个文本字段提取字符
	LEN() - 返回某个文本字段的长度
	ROUND() - 对某个数值字段进行指定小数位数的四舍五入
	NOW() - 返回当前的系统日期和时间
	FORMAT() - 格式化某个字段的显示方式
提示：在下面的章节，我们会详细讲解 Aggregate 函数和 Scalar 函数。
AVG()函数
AVG()函数返回数值列的平均值。
COUNT()函数
COUNT()函数返回匹配指定条件的行数。
-- 查询所有记录的条数
select count(*) from access_log;

-- 查询websites 表中 alexa列中不为空的记录的条数
select count(alexa) from websites;

-- 查询websites表中 country列中不重复的记录条数
select count(distinct country) from websites;

select deptno,
count(1) 总人数,
count(case when job ='SALESMAN' then '1' end) 销售人数,
count(case when job ='MANAGER' then '1' end) 主管人数
from emp
group by deptno;--如果不group，会认为所有数据是一组，返回一个数据
FIRST()函数
FIRST()函数返回指定的列中第一个记录的值。
只有 MS Access 支持 FIRST() 函数。
SQL Server语法
SELECT TOP 1 column_name FROM table_name
ORDER BY column_name ASC;
MySQL 语法
SELECT column_name FROM table_name
ORDER BY column_name ASC
LIMIT 1;
Oracle语法
SELECT column_name FROM table_name
ORDER BY column_name ASC
WHERE ROWNUM <=1;
LAST()函数
LAST()函数返回指定的列中最后一个记录的值。
注释：只有 MS Access 支持 LAST() 函数。
MAX()函数
MAX()函数返回指定列的最大值。
语法
SELECT MAX(column_name) FROM table_name;
MIN()函数
MIN()函数返回指定列的最小值。
SUM()函数
SUM()函数返回数值列的总数。
GROUP BY语句
GROUP BY语句用于结合聚合函数，根据一个或多个列对结果集进行分组。
语法
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;
HAVING子句
在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。
HAVING 子句可以让我们筛选分组后的各组数据。
语法
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name
HAVING aggregate_function(column_name) operator value;

遍历
SQL Server：
CTE: Common Table Expression
可用于递归，使用 MAXRECURSION限制递归级数
在单条 SELECT、INSERT、UPDATE 或 DELETE 语句的执行范围内定义
CTE不能嵌套
分页
1、ROW_NUMBER() OVER()
select * from (
	select *, ROW_NUMBER() OVER(Order by ArtistId) AS RowId from ArtistModels) as b 
where RowId between 11 and 20 
/*  where RowId between (pageIndex-1)*pageSize+1 and pageIndex*pageSize  */
2、offset fetch next方式（SQL2012以上的版本才支持：推荐使用）
select * from ArtistModels order by ArtistId offset 4 rows fetch next 5 rows only
 /*  order by ArtistId offset (pageIndex-1)*pageSize rows fetch next pageSize rows only  */
	3、top not in（适应于数据库2012以下的版本）
select top pageSize * from ArtistModels 
where ArtistId not in (select top (pageIndex-1)*pageSize ArtistId from ArtistModels)
行列转换
在做数据统计的时候，行转列，列转行是经常碰到的问题。case when方式太麻烦了，而且可扩展性不强，可以使用 PIVOT，UNPIVOT比较快速实现行转列，列转行，而且可扩展性强
一、行转列
1、测试数据准备
CREATE  TABLE [StudentScores]
(
   [UserName]         NVARCHAR(20),        --学生姓名
   [Subject]          NVARCHAR(30),        --科目
   [Score]            FLOAT,               --成绩
)
INSERT INTO [StudentScores] SELECT '张三', '语文', 80
INSERT INTO [StudentScores] SELECT '张三', '数学', 90
INSERT INTO [StudentScores] SELECT '张三', '英语', 70
INSERT INTO [StudentScores] SELECT '张三', '生物', 85
INSERT INTO [StudentScores] SELECT '李四', '语文', 80
INSERT INTO [StudentScores] SELECT '李四', '数学', 92
INSERT INTO [StudentScores] SELECT '李四', '英语', 76
INSERT INTO [StudentScores] SELECT '李四', '生物', 88
INSERT INTO [StudentScores] SELECT '码农', '语文', 60
INSERT INTO [StudentScores] SELECT '码农', '数学', 82
INSERT INTO [StudentScores] SELECT '码农', '英语', 96
INSERT INTO [StudentScores] SELECT '码农', '生物', 78

![x](./Resource/25.png)

2、行转列sql
SELECT * FROM [StudentScores] /*数据源*/
AS P
PIVOT 
(
    SUM(Score/*行转列后 列的值*/) FOR 
    p.Subject/*需要行转列的列*/ IN ([语文],[数学],[英语],[生物]/*列的值*/)
) AS T
执行结果：
![x](./Resource/26.png)

二、列转行
1、测试数据准备
CREATE TABLE ProgrectDetail
(
    ProgrectName         NVARCHAR(20), --工程名称
    OverseaSupply        INT,          --海外供应商供给数量
    NativeSupply         INT,          --国内供应商供给数量
    SouthSupply          INT,          --南方供应商供给数量
    NorthSupply          INT           --北方供应商供给数量
)

INSERT INTO ProgrectDetail
SELECT 'A', 100, 200, 50, 50
UNION ALL
SELECT 'B', 200, 300, 150, 150
UNION ALL
SELECT 'C', 159, 400, 20, 320
UNION ALL

![x](./Resource/27.png)


2、列转行的sql
SELECT P.ProgrectName,P.Supplier,P.SupplyNum
FROM 
(
    SELECT ProgrectName, OverseaSupply, NativeSupply,
           SouthSupply, NorthSupply
     FROM ProgrectDetail
)T
UNPIVOT 
(
    SupplyNum FOR Supplier IN
    (OverseaSupply, NativeSupply, SouthSupply, NorthSupply )
) P
执行结果：
![x](./Resource/28.png)
