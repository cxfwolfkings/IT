# 备份与恢复

## 目录

1. MySQL
   - [MySQL备份/恢复策略](#MySQL备份/恢复策略)
   - [逻辑备份和恢复](#逻辑备份和恢复)
   - [物理备份和恢复](#物理备份和恢复)
   - [表的导入导出](#表的导入导出)
2. SQLServer
3. Redis

## MySQL

### MySQL备份/恢复策略

- 确定要备份的表的存储引擎是事务型还是非事务性，两种不同的存储引擎备份方式在处理数据一效性方面是不太一样的。
- 确定使用全备份还是增量备份。全备份的优点是备份保持最新备份，恢复的时候可以花费更少的时间；缺点是如果数据量大，将会花费很多的时间，并对系统造成较长时间的压力。增量备份则恰恰相反，只需要备份每天的增量日志，备份时间少，对负载压力也小；缺点就是恢复的时候需要全备份加上次备份到故障前的所有日志，恢复时间会长些。
- 可以考虑采取复制的方法来做异地备份，但是记住，复制不能代替备份，它对数据库的误操作也无能为力。
- 要定期做备份，备份的周期要充分考虑系统可以承受的恢复时间。备份要在系统负载较小的时候进行。
- 确保 MySQL 打开 log-bin 选项，有了BINLOG，MySQL 才可以在必要的时候做完整恢复，或基于时间点的恢复， 或基于位置的恢复。
- 要经常做备份恢复制试，确保备份是有效的，并且是可以恢复的。

### 逻辑备份和恢复

**逻辑备份** 和 **物理备份** 对比：

1. **逻辑备份** 可以用同样的方法备份各种存储引擎的数据库，而 **物理备份** 针对不同的存储引擎却有不同的备份方法。因此，对于不同存储引擎混合的数据库，用逻辑备份会更简单一些。
2. **物理备份** 的原理都是基于文件的 `cp`，所以备份和恢复的速度更快。

MySQL 中的逻辑备份是将数据库中的数据备份为一个文本文件，备份的文件可以被查看和编辑。

**备份指令mysqldump：**（重点掌握）

```sh
# 备份指定的数据库，或者此数据库中某些哀
mysqldump [options] db_name [tables]
# 备份指定的一个或多个数据库。
mysqldump [options] --database DB1 [DB2 DB3 ...]
# 备份所有数据库
mysqldump [options] --all-database

# 备份示例：

# 备份所有数据库
mysqldump -uroot - p --all-database > all.sql
# 备份数据库test
mysqldump -uroot -p test > test.sql
# 备份数据库test下的表emp
mysqldump -uroot -p test emp > emp.sql
# 备份数据库test下的表emp和dept
mysqldump -uroot -p test emp dept > emp_dept.sql
# 备份数据库test下的emp表的字段为逗号分割的文本，备份到/tmp
mysqldump -uroot -T /tmp test emp --fields-terminated-by ','
```

查看帮助：`--help`

>需要强调的是，为了保证数据备份的一致性，MyISAM 存储引擎在备份的时候需要加上 `-l` 参数，表示将所有表加上读锁，在备份期间，所有表将只能读而不能进行数据更新。但是对于事务存储引擎（InnoDB 和 BDB）来说，可以采用更好的边项 `--single-transaction`，此选项将使 InnoDB 存储引擎得到一个快照(Snapshot)，使得备份的数据能够保证一致性。+

**恢复指令：**

```sh
mysql -uroot -p dbname < bakfile
# 各份恢复后数据并不完整，还需要将备份后执行的日志进行重做
mysqlbinlog binlog-file | mysql -u root -p

# 完整示例：

# 上午9点，备份数据库。（-F表示生成一个新的日志文件）
mysqldump -u root -p -l -F test > test.dmp
# 9点半备份完毕，插入新的数据
mysql> insert into ...
# 10点，数据库突然故障，需要恢复备份
mysql -uroot -p test < test.dmp
# 使用 mysqlbinlog 恢复自 mysqldump 备份以来的 BINLOG
mysqlbinlog localhost-bin.000015 | mysql -u root -p 123456

# 在数据库交互模式下恢复（基本不用）
mysql> use dbName;
mysql> source backupFile;
```

**不完全恢复：**

由于误操作，比如误删除了一张表，这时使用 **完全恢复** 是没有用的，因为日志里面还存在误操作的语句，我们需要的是恢复到误操作之前的状态，然后跳过误操作语句，再恢复后面执行的语句，完成我们的恢复。

在 MySQL 中，不完全恢复分为 **基于时间点的恢复** 和 **基于位置的恢复**。

```sh
# 基于时间点恢复
# 如果上午10点发生误操作，跳过这个时间段的日志进行恢复
mysqlbinlog --stop-date="2020-01-30 9:59:59" bin.123456 | mysql -u root -p 123456
mysqlbinlog --start-date="2020-01-30 10:01:00" bin.123456 | mysql -u root -p 123456

# 基于位置恢复：针对同一时间有多条sql语句同时执行的情况
# 在/tmp目录下创建小的文本文件，查看此文件，找到出错语句前后的位置号
mysqlbinlog --start-date="2020-01-30 9:50:00" --stop-date="2020-01-30 9:59:59" bin.123456 > /tmp/restore.sql
# 恢复到停止位置为止的所有事务
mysqlbinlog --stop-position="368312" bin.123456 | mysql -u root -p 123456
# 恢复给定位置开始到结束的所有事务
mysqlbinlog --start-position="368315" bin.123456 | mysql -u root -p 123456
```

### 物理备份和恢复

**物理备份** 又分为 `冷备份` 和 `热备份`

**冷备份（很少使用）：**

这种方法对 `MyISAM` 和 `InnoDB` 存储引擎都适合，但是一般很少使用，因为很多应用是不允许长时间停机的。

进行备份的操作如下：停掉 MySQL 服务，在操作系统级别备份 MySQL 的数据文件和日志文件到备份目录。

进行恢复的操作如下：首先停掉 MySQL 服务，在操作系统级刷恢复 MySQL 的数据文件；然后重启 MySQL 服务， 使用 `mysqlbinlog` 工具恢复自备份以来的所有BINLOG。

**热备份：**

MySQL 中，对于不同的存储引擎热备份方法也有所不同，下面主要介绍 MyISAM 和 InnoDB 的热备份方法。

```sh
# MyISAM
# 使用 mysqlhotcopy（MySQL自带）工具，--help查看帮助
mysqlhotcopy db_name [/path/directory]
# mysqlhotcopy使用不正常，手工锁表复制
mysql> flush tables for read;
# 然后复制数据文件到备份目录即可
```

使用 `ibbackup`（免费使用1个月）工具热备份 InnoDB 存储引擎的数据库：

1. 编辑用于启动的配置文件 `my.cnf` 和用于备份的配置文件 `backup-my.cnf`

   ```ini
   # my.cnf
   [mysqld]
   datadir = /home/heikki/data
   innodb_data_home_dir = /home/heikki/data
   innodb_data_file_path = ibdata1:l00M;ibdata2:200M;ibdata3:500M:autoextend
   innodb_log_group_home_dir = /home/heikki/data
   set-variable = innodb_log_files_in_group=2
   set-variable = innodb_log_file_size=20M

   # backup-my.cnf，备份到 /home/heikki/backup
   [mysqld]
   datadir = /home/heikki/backup
   innodb_data_home_dir = /home/heikki/backup
   innodb_data_file_path = ibdata1:l00M;ibdata2:200M;ibdata3:500M:autoextend
   innodb_log_group_home_dir = /home/heikki/backup
   set-variable = innodb_log_files_in_group=2
   set-variable = innodb_log_file_size=20M
   ```

2. 开始备份

   ```sh
   ibbackup /home/pekka/my.cnf /home/pekka/backup-my.cnf
   ```

   >注意：ibbackup 工具不会覆盖任何重名的文件， 因此在新的备份开始之前，需要确保备份目录中没有重名文件， 否则备份很可能会失败。

   备份完成后，备份目录下包含有数据文件和日志文件。因为在复制数据文件时，文件内容在不断地变化，因此在不同的时间点复制的数据块中的数据很可能是不一致的。因此，`ibbackup` 在备份期间用一个日志文件 `ibbackup_logfile` 记录了备份期间数据的变化，在恢复的时候就可以用此日志文件对备份的数据文件进行日志重做，使得备份的数据能够保持完整性和一致性。

3. 恢复步骤

   ```sh
   # 进行自志重做
   ibbackup --apply-log /home/pekka/backup-my.cnf
   # 恢复后重启数据库服务
   mysqld_saft --defaults-file=/home/pekka/backup-my.cnf &
   # 服务重启后，利用 BINLOG 日志将备份点与战障点之间的剩余数据进行恢复。
   mysqlbinlog binlog-file | mysql -u root -p 123456
   ```

对于 InnoDB 和 MyISAM 混合的数据库，Innobase 公司还提供了一个开源的 Perl 脚本 innobackup。

### 表的导入导出

**SELECT...INTO OUTFILE...**（重点掌握）

```sql
select * from tableName into outfile 'targetFile' [option]
```

option参数：

- fields terminated by 'string' （字段分隔符，默认为制表符'\t'）
- fields [optionally] enclosed by 'char' （字段引用符，如果加 `optionally` 选项则只用在char、varchar 和 text 等字符型字段上。默认不使用引用符）
- fields escaped by 'char' （转义字符，默认为'\'）
- lines starting by 'string' （每行前都加此字符串，默认''）
- lines terminated by 'string' （行结束符，默认为'\n'）

```sql
select * from emp into outfile '/tmp/emp.txt' fields terminated by "," optionally enclosed by '"';
-- 查看导出文件
system more /tmp/emp.txt
-- output
1,"z1","aa"
2,"z1","aa"
3,"z1","aa"
...
```

>注意：在 MySQL 客户端连接成功后，如果要执行操作系统的命令，可以用 "system + 操作系统命令" 来进行执行。`SELECT...INTO OUTFILE...` 产生的输出文件如果在目标目录下有重名文件，将不会创建成功，源文件不能被自动覆盖。

**mysqldump：**

```sh
mysqldump -u root -T targetDir dbname tableName [option]
```

option参数：

- --fields-terminated-by='string' （字段分隔符）
- --fields-[optionally]-enclosed by 'char' （字段引用符，如果加 `optionally` 则只用在char、varchar 和 text 等字符型字段上）
- --fields-escaped-by='char' （转义字符）
- --lines-terminated-by='string' （记录结束符）

```sh
mysqldump -uroot -T /tmp test emp --fields-terminated-by ',' --fields-optionally-enclosed-by '"'
```

除了生成数据文件 emp.txt 之外，还生成一个 emp.sql 文件，里面记录了 emp 表的创建脚本。

`mysqldump` 实际调用的就是 `SELECT...INTO OUTFILE...` 提供的接口，并在其上面添加了一些新的功能而已。

**LOAD DATA INFILE...**（加载最快，重点掌握）

```sql
LOAD DATA [LOCAL] INFILE 'filename' INTO TABLE tablename [option]
```

option参数：

- fields terminated by 'string' （字段分隔符，默认为制表符'\t'）
- fields [optionally] enclosed by 'char' （字段引用符，如果加 `optionally` 选项则只用在char、varchar 和 text 等字符型字段上。默认不使用引用符）
- fields escaped by 'char' （转义字符，默认为'\'）
- lines starting by 'string' （每行前都加此字符串，默认''）
- lines terminated by 'string' （行结束符，默认为'\n'）
- ignore number lines （忽略输入文件中的前n行数据）
- (col_name_or_user_var, ...) （按照列出的字段顺序和字段数量加载数据）
- set col_name=expr,... 将列做一定的数值转换后再加载。

>其中 char 表示此符号只能是单个字符，string 表示可以是字符串。

```sql
-- 将 id 列的内容 +10 后再加就到表中
load data infile '/tmp/emp.txt' into table emp fields terminated by ',' enclosed by '"' ignore 2 lines (id, name, content) set id=id+10;
```

**mysqlimport：**

```sh
mysqlimport -u root -p 123456 [--local] dbName order_tab.txt [option]
```

option参数：

- --fields-terminated-by='string' （字段分隔符）
- --fields-[optionally]-enclosed by 'char' （字段引用符，如果加 `optionally` 则只用在char、varchar 和 text 等字符型字段上）
- --fields-escaped-by='char' （转义字符）
- --lines-terminated-by='string' （记录结束符）
- --ignore-lines=number （忽略输入文件中的前n行数据）

```sh
mysqlimport -uroot test /tmp/emp.txt --fields-terminated-by=',' --fields-enclosed-by='"'
```

>注意：如果导入和导出是跨平台操作的（Windows 和 Linux），那么要注意设置参数 `line-terminated-by`，
Windows 上设置为 `line-terminated-by='\r\n'`，Linux 上设置为 `line-terminated-by='\n'`。

**其它用于复制的SQL：**

```sql
-- 创建和旧表一样结构的新表
create table newTable like oldTable
-- 作用同上，但是会失去索引，自增属性，Timestamp属性，表类型也会变成 MyISAM
create table newTable select * from table
-- 复制数据
insert into newTable select * from oldTable
-- 自增容易出问题（重复），解决方法如下：
-- (1) insert ignore into... 忽略受影响记录
-- (2) replace代替insert into，覆盖受影响记录
-- (3) select @maxId := MAX(Id) from newTable;
--     insert into newTable select Id+@maxId,... from oldTable
```
