在这个函数里有两个关键字：break和continue。break 表示如果读取的行内容为空，则完全终止 while 的循环；continue 表示若行的首字符为"＃"，则终止这一次的循环，也就是 continue 以下的循环内的语句不执
行了，返回到循环的顶部继续下一次循环。

### 写入变量

write的参数只能是字符串，如果想把其它类型的变量写入文件，就必须将其转换成字符串。一个简单的方法是利用str函数：

```python
>>> f = open("test.dat", "w")
>>> f.write(str(1234.56) + '\n')
>>> f.write(str(1000))
>>> f.close()
```

另一种方法是利用格式化操作符"%"。当操作符"%"的两边是整数时，它是求余数的运算。如果第一个操作符是字符串，它就是格式化操作符。第一个参数是需要格式化的字符串，第二个参数是数组表达式。结果是包含表达式值的字符串。请看下面的例子：

```python
>>> age = 31
>>> "%d" % age
'31'
```

格式化序列"%d"表示数组中的第一个表达式的值应该是整数类型，字母d代表"decimal"。

格式化序列可以出现在字符串的任何位置，所以我们能够在句子中嵌入值：

```python
>>> age = 31
>>> "My age is : %d." % age
'My age is : 31.'
```

格式化序列"%f"对应是浮点数，默认的小数点后面有六位小数。"%s"对应是字符串。表达式要与字符串中的格式化序列相匹配，匹配包含两个方面，一个是有几个表达式，就有几个格式化序列；另一个是格式化序列与表达式值的类型相对应。

```python
>>> "In %d days we make %f million %s." % \
(31, 31*12.59, 'dollars')
'In 31 days we make 390.290000 million dollars.'
>>> "d% d% d%" % (3, 4 ,5 ,6)
ValueError: incomplete format #错误信息
>>> "d%" % 8.0
ValueError: incomplete format #错误信息
```

对于要格式化的数字，我们还能够指定它所占的位数。"%"后面的数字表明数字的位数，如果位数多于数字的实际位数，且该数为正，则在要格式化的数字的前面添加空格；如果该数为负，空格添加在数字的后面：

```python
>>> "%5d" % 1
'     1'
>>> "%-5d" % 1
'1     '
>>> "%4f" % 9.1
'9.100000'
>>> "%3f" % 1234
'1234.000000'
>>> "%3d" % 1234
'1234'
```

对于浮点数，我们还可以指定小数的位数：

```python
>>> "%4.3f" % 1137.98
'1137.980'
```

下面的例子是按照一定的格式打印姓名和工资。姓名是字典的键，工资是字典的值。姓名左对齐，工资右对齐,同时对姓名进行了排序：

```python
>>> def printSalary(salary):
    name = salary.keys()
    name.sort()
    for n in name:
      print "%-12s : %12.2f" % (n,salary[n])
>>> salary = {'pidaqing':1137.9, 'zhangming':737.3, 'pitianjian':5.0}
>>> printSalary(salary)
pidaqing    : 1137.90
pitianjian  : 5.00
zhangming   : 737.30
```

从上述的内容可以看到，为了将不同类型的数据保存到文件，必须将其转换成字符串。结果导致从文件中读的一切内容都是字符串，数据的原始类型信息丢失了。解决的办法是输入pickle模块，用它提供的方法把各种类型的数据存入文件，数据结构的信息也同样被保存了。也就是说，你保存了什么，将来读出的还是什么。例如：

```python
>>> import pickle
>>> f = open("test.dat", "w")
>>> pickle.dump(100, f)
>>> pickle.dump(123.98, f)
>>> pickle.dump((1, 3, "abc"), f)
>>> pickle.dump([4, 5, 7], f)
>>> f.close()
```

在这个例子中，我们用dump方法分别向文件中写入了整数、浮点数、列表和数组。如果你用write方法写入，那是会出错的。

接下来就看能不能把这些数据“原封不动”的读出来：

```python
>>> f = open("test.dat", "r")
>>> a = pickle.load(f)
>>> print a
100
>>> type(a)
<type 'int'>
>>> b = pickle.load(f)
>>> print b
123.98
>>> type(b)
<type 'float'>
>>> c = pickle.load(f)
>>> print c
(1, 3, 'abc')
>>> type(c)
<type 'tuple'>
>>> d = pickle.load(f)
>>> print d
[4, 5, 7]
>>> type(d)
<type 'list'>
```

每调用一次load方法，就得到先前存入的一个变量，而且这个变量还保存着原始类型的信息。

## 异常

## 错误信息

程序出错了，就会产生异常。异常是不可避免的，关键是怎样处理。当然不能任其放任自流，不管不问。起码的要求是解释器终止程序的运行，指出错误类型，以及对错误进行简单描述。

例如，除数为零时，IDE产生一个异常：

```python
>>> print 2/0
ZeroDivisionError: integer division or modulo by zero #异常信息
```

异常信息分为两个部分，冒号前面的是异常类型，之后是对此的简单说明。其它的信息则指出在程序的什么地方出错了。当异常产生时，如果没有代码来处理它，Python对其进行缺省处理，输出一些异常信息并终止程序。

程序在执行的过程中产生异常，但不希望程序终止执行，这时就需要用 try 和 except 语句对异常进行处理。比如，提示用户输入文件名，然后打开文件。若文件不存在，我们也不想程序就此崩溃，处理异常处理就成了关键的部分。

```python
filename = ''
while 1:
  filename = raw_input("Input a file name: ")
  if filename == 'q':
    break
  try:
    f = open(filename, "r")
    print 'Opened a file.'
  except:
    print 'There is no file named', filename
```

try块的语句要求打开一个文件，如果没有异常发生，就忽略except块的内容；如果产生异常，就执行except块内的语句，之后是再一次的循环。

### 自定义异常信息

如果程序检测到错误，我们也可以用raise定义异常。

```python
def inputAge():
  age = input("Input your age:")
  if (age>100 or age<18):
    raise 'BadNumberError', 'out of range'
  return age
```

raise有两个参数，第一个是由我们自己定义的异常类型，第二个是关于此异常的少量说明信息。如果调用inputAge的函数有处理异常的程序，即使inputAge出错，整个程序也能正常运行；否则，程序退出，显示错误信息。

```python
>>> inputAge()
Input your age:31
31
>>> inputAge()
Input your age:109
BadNumberError: out of range #异常信息
```

***一个复杂的例子***

让我们看下面的脚本文件：

```python
while 1:
  try:
    x = int(raw_input("Input a number:"))
    y = int(raw_input("Input a number:"))
    z = x / y
  except ValueError, ev:
    print "That is no valid number.", ev
  except ZeroDivisionError, ez:
    print "divisor is zero:", ez
  except:
    print "Unexpected error."
    raise
  else:
    print "There is no error."
print x , "/" , y , "=" , x/y
```

在这个例子中有三个except语句。一个try语句可以和多个except配合使用，但只可能是其中的一个被执行。

前两个except语句，接受两个参数。第一个参数是异常的类型，第二个参数用于接收异常发生时生成的值，异常是否有这个参数及参数的类型如何，由异常的类型决定。

异常"ValueError"在这里表示：如果你输入的字符串包含非数字类型的字符，这个异常将被引发。

异常"ZeroDivisionError"表示除数为0引发的异常。

最后一个except语句表示当有异常发生，但不是前面定义的两种类型，就执行这条语句。用这样的 except 语句要小心，理由是你很可能把一个应该注意的的程序错误隐藏了。为了防止这种情况的发生，我们用了 raise 语句，将异常抛出。

当没有任何异常发生时，else语句的内容被执行。else语句一定放在所有except语句的后面。
