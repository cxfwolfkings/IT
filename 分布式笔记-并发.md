# 并发

## 目录

1. 异步编程
2. 多线程 & 线程安全
3. 一致性、事务
   - 事务ACID特性
   - 事务的隔离级别
   - MVCC
4. [锁](#锁)
   - [并发问题与解决](#并发问题与解决)
   - 公平锁 & 非公平锁
   - 乐观锁 & 悲观锁 & CAS
   - ABA问题
   - CopyOnWrite容器
   - RingBuffer
   - 可重入锁 & 不可重入锁
   - 互斥锁 & 共享锁
   - 死锁
   - 同步类 & 原子类

## 锁

在多线程并发场景下，为了保证共享资源在同一时刻只能被同一个线程操作，需要对共享资源进行互斥控制，即加锁。对单进程应用而言，部分编程语言内置的锁机制便足以保证并发安全，如 Java 语言可用 `synchronized` 和 `Lock` 来实现锁。然而，由于分布式系统多线程、多进程并且分布在不同节点，需要一种 **跨进程** 的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。

## 并发问题与解决

**原子性问题：**

所谓原子性，指的是一个操作不可中断，即在多线程并发的环境下，一个操作一旦开始，就会在同一个 CPU 时间片内执行完毕。如果同一个线程的多个操作在不同的 CPU 时间片上执行，由于中间出现停滞，后面的操作在执行时可能因某个共享数据被其它线程修改，而该修改并未同步到当前线程中，导致当前线程操作的数据与实际不符，这种由于执行不连贯导致的数据不一致问题被称作原子性问题。

**可见性问题：**

可见性问题的出现与线程访问共享数据的方式有关。线程访问堆（方法区）中的变量时，先在栈中建立一个变量的副本，修改后再同步到堆中。如果一个线程刚建立副本，这时另一线程修改了变量，尚未同步到堆中，这时就会出现两个线程操作同一变量的同一种状态的现象，比如 i=9，变量 i 的初始值为9，每一个线程的操作都是减1。两个线程 A 与 B 同时访问变量，B 先执行 i-1，在将结果 i=8 同步到堆中前，A 线程也执行 i-1，这时 i=9 的状态就被执行两次，出现线程安全问题。

>线程安全问题产生的原因在于一个线程对共享数据的修改不能立即为其它线程所见。

**有序性问题：**

为了提高执行效率，CPU 会对那些没有依赖关系的指令重新排序，重新排序后的执行结果与顺序执行结果相同。例如，在源代码中：

```java
int a=0;
int b=1;
```

CPU 在执行时可能先执行 `int b=1;`，接着执行 `int a=0;`，执行结果与顺序执行结果相同。指令重排在单线程环境下是安全的，在多线程环境下就可能出现问题。比如下面这个例子。

线程 A：

```java
String str = "hello world!";//指令1
boolean flag = false;//指令2
```

线程 B：

```java
while(flag)
{
    doSome();
}
str.toUpperCase();//指令3
```

如果线程 A 顺序执行，即执行指令1，再执行指令2，线程 B 的执行不会出现问题。指令重排后，假如线程 A 先执行指令2，这时 `flag=false`，切换到线程 B，终止循环，执行指令3，由于 str 对象尚未创建就会出现空指针异常。

上面 3 个问题都是多线程并发场景中的常见问题，其根源在于：**对共享资源的争夺**。

>为了解决这类问题，Java 提供了很多策略，如 `volatile` 关键字，可以 **禁止指令重排**，从而避免有序性的问题；对于原子性问题和可见性问题，在高并发场景下，为了保证共享资源在同一时刻只能被同一个线程执行，需要对公共资源进行 **互斥控制**，即 **加锁**。
>
>Java 提供了两种内置的锁的实现：由 JVM 实现的 `synchronized` 和 JDK 提供的 `Lock`，对于单进程应用来说，使用 `synchronized` 或 `Lock` 来实现锁，足以保证并发安全。
>
>`synchronized` 本质上是通过锁来实现的。对于同一个代码块，为了实现多个线程在一个时刻只能有一个线程执行，需要在某个地方做个标记，每个线程都必须能看到它。当标记不存在时，某个线程可以设置该标记，其余后续线程发现已经有标记了，则等待拥有标记的线程结束同步代码块取消标记后，再去尝试设置标记。这个标记可以理解为锁。
>
>不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可。如 Java 中 `synchronize` 是在对象头设置标记；`Lock` 接口的实现类的基本思想是，用一个 `volitile` 修饰的 int 型变量，保证每个线程都能拥有对该 int 的可见性和原子修改。

从上面的分析可以看出，Java 提供的两种锁机制有效的前提是：**同一个进程内有效**。但是，随着业务发展，原单机部署的系统被演化成分布式系统后，由于分布式系统多线程、多进程并且分布在不同物理机上，这将使原单机部署情况下的并发控制锁策略失效。为了解决这个问题，就需要一种 **跨进程的互斥机制** 来控制共享资源的访问，这就是分布式锁要解决的问题。

实现分布式锁需要依赖一个第三方系统，此系统需要满足高可用和较强的一致性，同时能应付高并发的请求。常见的分布式锁实现方式有三种：**数据库**、**缓存**、**分布式协调系统**。
