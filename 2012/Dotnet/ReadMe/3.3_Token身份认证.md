# Token身份认证

## OAuth2 和 JWT - 如何设计安全的API？

Moakap译，原文 OAuth 2 VS JSON Web Tokens: How to secure an API

本文会详细描述两种通用的保证API安全性的方法：OAuth2和JSON Web Token (JWT)

假设:

- 你已经或者正在实现API；
- 你正在考虑选择一个合适的方法保证API的安全性；

### JWT和OAuth2比较？

要比较JWT和OAuth2？首先要明白一点就是，这两个根本没有可比性，是两个完全不同的东西。

- JWT是一种认证协议

  > JWT提供了一种用于发布接入令牌（Access Token),并对发布的签名接入令牌进行验证的方法。 令牌（Token）本身包含了一系列声明，应用程序可以根据这些声明限制用户对资源的访问。

- OAuth2是一种授权框架

  > 另一方面，OAuth2是一种授权框架，提供了一套详细的授权机制（指导）。用户或应用可以通过公开的或私有的设置，授权第三方应用访问特定资源。既然JWT和OAuth2没有可比性，为什么还要把这两个放在一起说呢？实际中确实会有很多人拿JWT和OAuth2作比较。标题里把这两个放在一起，确实有误导的意思。很多情况下，在讨论OAuth2的实现时，会把JSON Web Token作为一种认证机制使用。这也是为什么他们会经常一起出现。

先来搞清楚JWT和OAuth2究竟是干什么的～

### JSON Web Token (JWT)

JWT在标准中是这么定义的：

> JSON Web Token (JWT) is a compact URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is digitally signed using JSON Web Signature (JWS).
-RFC7519 https://tools.ietf.org/html/rfc7519

JWT是一种安全标准。基本思路就是用户提供用户名和密码给认证服务器，服务器验证用户提交信息信息的合法性；如果验证成功，会产生并返回一个Token（令牌），用户可以使用这个token访问服务器上受保护的资源。

一个token的例子:

```token
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

一个token包含三部分：

```token
header.claims.signature
```

为了安全的在url中使用，所有部分都 base64 URL-safe 进行编码处理。

**Header头部分**

头部分简单声明了类型(JWT)以及产生签名所使用的算法。

```json
{
  "alg" : "AES256",
  "typ" : "JWT"
}
```

**Claims声明**

声明部分是整个token的核心，表示要发送的用户详细信息。有些情况下，我们很可能要在一个服务器上实现认证，然后访问另一台服务器上的资源；或者，通过单独的接口来生成token，token被保存在应用程序客户端（比如浏览器）使用。

一个简单的声明（claim）的例子：

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

**Signature签名**

签名的目的是为了保证上边两部分信息不被篡改。如果尝试使用Bas64对解码后的token进行修改，签名信息就会失效。一般使用一个私钥（private key）通过特定算法对Header和Claims进行混淆产生签名信息，所以只有原始的token才能于签名信息匹配。

这里有一个重要的实现细节。只有获取了私钥的应用程序（比如服务器端应用）才能完全认证token包含声明信息的合法性。所以，永远不要把私钥信息放在客户端（比如浏览器）。

### OAuth2是什么？

相反，OAuth2不是一个标准协议，而是一个安全的授权框架。它详细描述了系统中不同角色、用户、服务前端应用（比如API），以及客户端（比如网站或移动App）之间怎么实现相互认证。

> The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf.
-RFC6749 https://tools.ietf.org/html/rfc6749

这里简单说一下涉及到的基本概念。

**Roles角色**

应用程序或者用户都可以是下边的任何一种角色：

- 资源拥有者
- 资源服务器
- 客户端应用
- 认证服务器

**Client Types客户端类型**

这里的客户端主要指API的使用者。它可以是的类型：

- 私有的
- 公开的

**Client Profile客户端描述**

OAuth2框架也指定了集中客户端描述，用来表示应用程序的类型：

- Web应用
- 用户代理
- 原声应用

**Authorization Grants认证授权**

认证授权代表资源拥有者授权给客户端应用程序的一组权限，可以是下边几种形式：

- 授权码
- 隐式授权
- 资源拥有者密码证书
- 客户端证书
- Endpoints终端

**OAuth2框架需要下边几种终端：**

- 认证终端
- Token终端
- 重定向终端

从上边这些应该可以看出，OAuth2定义了一组相当复杂的规范。

### 使用HTTPS保护用户密码

在进一步讨论OAuth2和JWT的实现之前，有必要说一下，两种方案都需要SSL安全保护，也就是对要传输的数据进行加密编码。

安全地传输用户提供的私密信息，在任何一个安全的系统里都是必要的。否则任何人都可以通过侵入私人wifi，在用户登录的时候窃取用户的用户名和密码等信息。

**一些重要的实施考虑**

在做选择之前，参考一下下边提到的几点。

**时间投入**

OAuth2是一个安全框架，描述了在各种不同场景下，多个应用之间的授权问题。有海量的资料需要学习，要完全理解需要花费大量时间。甚至对于一些有经验的开发工程师来说，也会需要大概一个月的时间来深入理解OAuth2。 这是个很大的时间投入。

相反，JWT是一个相对轻量级的概念。可能花一天时间深入学习一下标准规范，就可以很容易地开始具体实施。

**出现错误的风险**

OAuth2不像JWT一样是一个严格的标准协议，因此在实施过程中更容易出错。尽管有很多现有的库，但是每个库的成熟度也不尽相同，同样很容易引入各种错误。在常用的库中也很容易发现一些安全漏洞。

当然，如果有相当成熟、强大的开发团队来持续OAuth2实施和维护，可以一定成都上避免这些风险。

**社交登录的好处**

在很多情况下,使用用户在大型社交网站的已有账户来认证会方便。

如果期望你的用户可以直接使用Facebook或者Gmail之类的账户,使用现有的库会方便得多。

### 结论

做结论前，我们先来列举一下 JWT 和 OAuth2 的主要使用场景。

**JWT使用场景**

***无状态的分布式API***

JWT的主要优势在于使用无状态、可扩展的方式处理应用中的用户会话。服务端可以通过内嵌的声明信息，很容易地获取用户的会话信息，而不需要去访问用户或会话的数据库。在一个分布式的面向服务的框架中，这一点非常有用。

但是，如果系统中需要使用黑名单实现长期有效的token刷新机制，这种无状态的优势就不明显了。

优势：

- 快速开发
- 不需要cookie
- JSON在移动端的广泛应用
- 不依赖于社交登录
- 相对简单的概念理解

限制：

- Token有长度限制
- Token不能撤销
- 需要token有失效时间限制(exp)

**OAuth2使用场景**

在作者看来两种比较有必要使用OAuth2的场景：

***外包认证服务器***

上边已经讨论过，如果不介意API的使用依赖于外部的第三方认证提供者，你可以简单地把认证工作留给认证服务商去做。

也就是常见的，去认证服务商（比如facebook）那里注册你的应用，然后设置需要访问的用户信息，比如电子邮箱、姓名等。当用户访问站点的注册页面时，会看到连接到第三方提供商的入口。用户点击以后被重定向到对应的认证服务商网站，获得用户的授权后就可以访问到需要的信息，然后重定向回来。

优势：

- 快速开发
- 实施代码量小
- 维护工作减少

***大型企业解决方案***

如果设计的API要被不同的App使用，并且每个App使用的方式也不一样，使用OAuth2是个不错的选择。

考虑到工作量，可能需要单独的团队，针对各种应用开发完善、灵活的安全策略。当然需要的工作量也比较大！这一点，OAuth2的作者也指出过：

> To be clear, OAuth 2.0 at the hand of a developer with deep understanding of web security will likely result is a secure implementation. However, at the hands of most developers – as has been the experience from the past two years – 2.0 is likely to produce insecure implementations.  
> hueniverse - [OAuth 2.0 and the Road to Hell](https://link.jianshu.com/?t=https%3A%2F%2Fhueniverse.com%2F2012%2F07%2F26%2Foauth-2-0-and-the-road-to-hell%2F)

优势：

- 灵活的实现方式
- 可以和JWT同时使用
- 可针对不同应用扩展

## 进一步

- [http://jwt.io](https://link.jianshu.com/?t=http%3A%2F%2Fjwt.io%2F) - JWT官方网站，也可以查看到使用不同语言实现的库的状态。
- [http://oauth.net/2/](https://link.jianshu.com/?t=http%3A%2F%2Foauth.net%2F2%2F) OAuth2官方网站, 也也可以查看到使用不同语言实现的库的状态。
- [OAuth 2 tutorials](https://link.jianshu.com/?t=http%3A%2F%2Ftutorials.jenkov.com%2Foauth2%2Foverview.html) - Useful overview of how OAuth 2 works
- [Oauth2 Spec issues](https://link.jianshu.com/?t=http%3A%2F%2Fhueniverse.com%2F2012%2F07%2F26%2Foauth-2-0-and-the-road-to-hell%2F) Eran Hammer’s (推进OAuth标准的作者) views on what went wrong with the OAuth 2 spec process. Whatever your own opinion, good to get some framing by someone who understand’s key aspects of what make a security standard successful.
- [Thoery and implemnetation](https://link.jianshu.com/?t=http%3A%2F%2Fwww.toptal.com%2Fweb%2Fcookie-free-authentication-with-json-web-tokens-an-example-in-laravel-and-angularjs): with Laravel and Angular Really informative guide to JWT in theory and in practice for Laravel and Angular.
- 博客原文地址：[OAuth2和JWT-如何设计安全的API？](https://link.jianshu.com/?t=http%3A%2F%2Fwww.leshalv.net%2Fposts%2F9005%2F)

## 为什么要使用JWT？

在.NET Core之前对于Web应用程序跟踪用户登录状态最普通的方式则是使用Cookie，当用户点击登录后将对其信息进行加密并响应写入到用户浏览器的Cookie里，当用户进行请求时，服务端将对Cookie进行解密，然后创建用户身份，整个过程都是那么顺其自然，但是这是客户端是基于浏览器的情况，如果是客户端是移动app或者桌面应用程序呢？

关于JWT原理可以参考系列文章https://www.cnblogs.com/RainingNight/p/jwtbearer-authentication-in-asp-net-core.html，当然这只是其中一种限制还有其他。

如果我们使用Json Web Token简称为JWT而不是使用Cookie，此时Token将代表用户，同时我们不再依赖浏览器的内置机制来处理Cookie，我们仅仅只需要请求一个Token就好。这个时候就涉及到Token认证，那么什么是Token认证呢？一言以蔽之：将令牌（我们有时称为AccessToken或者是Bearer Token）附加到HTTP请求中并对其进行身份认证的过程。Token认证被广泛应用于移动端或SPA。

## Json Web Token基础

JWT由三部分构成，Base64编码的Header，Base64编码的Payload，签名，三部分通过点隔开。

第一部分以Base64编码的Header主要包括Token的类型和所使用的算法，例如：

```json
{
    "alg": "HS265",
    "typ": "JWT"
}
```

标识加密方式为HS256，Token类型为JWT, 这段JSON通过Base64Url编码形成下例的第一个字符串

第二部分以Base64编码的Payload主要包含的是声明(Claims)，例如，如下：

```json
{
    "sub": "765032130654732",
    "name": "jeffcky"
}
```

Payload是JWT用于信息存储部分，其中包含了许多种的声明（claims）。可以自定义多个声明添加到Payload中，系统也提供了一些默认的类型

- iss (issuer)：签发人
- exp (expiration time)：过期时间
- sub (subject)：主题
- aud (audience)：受众
- nbf (Not Before)：生效时间
- iat (Issued At)：签发时间
- jti (JWT ID)：编号

这部分通过Base64Url编码生成第二个字符串。

第三部分则是将Key通过对应的加密算法生成签名。

它的值类似这样的表达式：`Signature = HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`，也就是说，它是通过将前两个字符串加密后生成的一个新字符串。

所以只有拥有同样加密密钥的人，才能通过前两个字符串获得同样的字符串，通过这种方式保证了Token的真实性。

最终三部分以点隔开，比如如下形式：

```sh
1 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
2 eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiSmVmZmNreSIsImVtYWlsIjoiMjc1MjE1NDg0NEBxcS5jb20iLCJleHAiOjE1NjU2MTUzOTgsIm5iZiI6MTU2MzE5NjE5OCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAwIiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAxIn0.
3 OJjlGJOnCCbpok05gOIgu5bwY8QYKfE2pOArtaZJbyI
```

到这里此时我们应该知道：JWT包含的信息并没有加密，比如为了获取Payload，我们大可通过比如谷歌控制台中的APi(atob)对其进行解码，如下：

![x](./Resource/53.png)

那如我所说既然JWT包含的信息并没有加密，只是进行了Base64编码，岂不是非常不安全呢？当然不是这样，还没说完，第三部分就是签名，虽然我们对Payload（姑且翻译为有效负载），未进行加密，但是若有蓄意更换Payload，此时签名将能充分保证Token无效，除非将签名的Key不小心暴露在光天化日之下，否则必须是安全的。好了，到了这里，我们稍稍讲解了下JWT构成，接下来我们进入如何在 .NET Core 中使用JWT。

## 认证流程

![x](./Resource/63.png)

1. 认证服务器：用于用户的登录验证和Token的发放。
2. 应用服务器：业务数据接口。被保护的API。
3. 客户端：一般为APP、小程序等。

认证流程：

1. 用户首先通过登录，到认证服务器获取一个Token。
2. 在访问应用服务器的API的时候，将获取到的Token放置在请求的Header中。
3. 应用服务器验证该Token，通过后返回对应的结果。

>说明：这只是示例方案，实际项目中可能有所不同。

- 对于小型项目，可能认证服务和应用服务在一起。本例通过分开的方式来实现，使我们能更好的了解二者之间的认证流程。
- 对于复杂一些的项目，可能存在多个应用服务，用户获取到的Token可以在多个分布式服务中被认证，这也是JWT的优势之一。

## .NET Core中使用JWT

在 .NET Core 中如何使用JWT，那么我们必须得知晓如何创建JWT，接下来我们首先创建一个端口号为5000的APi，创建JWT，然后我们需要安装 System.IdentityModel.Tokens.Jwt 包。

我们直接给出代码来创建Token，然后一一对其进行详细解释，代码如下：

```C#
var claims = new Claim[] {
    new Claim (ClaimTypes.Name, "Jeffcky"),
    new Claim (JwtRegisteredClaimNames.Email, "2752154844@qq.com"),
    new Claim (JwtRegisteredClaimNames.Sub, "D21D099B-B49B-4604-A247-71B0518A0B1C"),
};

var key = new SymmetricSecurityKey (Encoding.UTF8.GetBytes ("1234567890123456"));

var token = new JwtSecurityToken (
    issuer: "http://localhost:5000",
    audience: "http://localhost:5001",
    claims : claims,
    notBefore : DateTime.Now,
    expires : DateTime.Now.AddHours (1),
    signingCredentials : new SigningCredentials (key, SecurityAlgorithms.HmacSha256)
);

var jwtToken = new JwtSecurityTokenHandler ().WriteToken (token);
```

如上我们在声明集合中初始化声明时，我们使用了两种方式，一个是使用 ClaimTypes ，一个是 JwtRegisteredClaimNames ，那么这二者有什么区别？以及我们到底应该使用哪种方式更好？或者说两种方式都使用是否有问题呢？

ClaimTypes来自命名空间 System.Security.Claims ，而JwtRegisteredClaimNames来自命名空间 System.IdentityModel.Tokens.Jwt ，二者在获取声明方式上是不同的，ClaimTypes是沿袭微软提供获取声明的方式，比如我们要在控制器Action方法上获取上述ClaimTypes.Name的值，此时我们需要F12查看Name的常量定义值是多少，如下：

![x](./Resource/54.png)

接下来则是获取声明Name的值，如下：

```C#
var sub = User.FindFirst(d => d.Type == "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name")?.Value;
```

![x](./Resource/55.png)

那么如果我们想要获取声明JwtRegisterClaimNames.Sub的值，我们是不是应该如上同样去获取呢？我们来试试。

```C#
var sub = User.FindFirst(d => d.Type == JwtRegisteredClaimNames.Sub)?.Value;
```

![x](./Resource/56.png)

此时我们发现为空没有获取到，这是为何呢？这是因为获取声明的方式默认是走微软定义的一套映射方式，如果我们想要走JWT映射声明，那么我们需要将默认映射方式给移除掉，在对应客户端Startup构造函数中，添加如下代码：

```C#
JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
```

![x](./Resource/57.png)

如果用过并熟悉IdentityServer4的童鞋关于这点早已明了，因为在IdentityServer4中映射声明比如用户Id即（sub）是使用的JWT，也就是说使用的JwtRegisteredClaimNames，此时我们再来获取Sub看看。

![x](./Resource/58.png)

所以以上对于初始化声明两种方式的探讨并没有用哪个更好，因为对于使用ClaimTypes是沿袭以往声明映射的方式，如果要出于兼容性考虑，可以结合两种声明映射方式来使用。接下来我们来看生成签名代码，生成签名是如下代码：

```C#
var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("1234567890123456"));
```

如上我们给出签名的Key是1234567890123456，是不是给定Key的任意长度皆可呢，显然不是，关于Key的长度至少是16，否则会抛出如下错误

![x](./Resource/59.png)

接下来我们再来看实例化Token的参数，即如下代码：

```C#
var token = new JwtSecurityToken (
    issuer: "http://localhost:5000",
    audience: "http://localhost:5001",
    claims : claims,
    notBefore : DateTime.Now,
    expires : DateTime.Now.AddHours (1),
    signingCredentials : new SigningCredentials (key, SecurityAlgorithms.HmacSha256)
);
```

issuer代表颁发Token的Web应用程序，audience是Token的受理者，如果是依赖第三方来创建Token，这两个参数肯定必须要指定，因为第三方本就不受信任，如此设置这两个参数后，我们可验证这两个参数。要是我们完全不关心这两个参数，可直接使用JwtSecurityToken的构造函数来创建Token，如下：

```C#
var claims = new Claim[] {
    new Claim (ClaimTypes.Name, "Jeffcky"),
    new Claim (JwtRegisteredClaimNames.Email, "2752154844@qq.com"),
    new Claim (JwtRegisteredClaimNames.Sub, "D21D099B-B49B-4604-A247-71B0518A0B1C"),
    new Claim (JwtRegisteredClaimNames.Exp, $"{new DateTimeOffset(DateTime.Now.AddMilliseconds(1)).ToUnixTimeSeconds()}"),
    new Claim (JwtRegisteredClaimNames.Nbf, $"{new DateTimeOffset(DateTime.Now).ToUnixTimeSeconds()}")
};

var key = new SymmetricSecurityKey (Encoding.UTF8.GetBytes ("1234567890123456"));

var jwtToken = new JwtSecurityToken (new JwtHeader (new SigningCredentials (key, SecurityAlgorithms.HmacSha256)), new JwtPayload (claims));
```

这里需要注意的是Exp和Nbf是基于Unix时间的字符串，所以上述通过实例化DateTimeOffset来创建基于Unix的时间。到了这里，我们已经清楚的知道如何创建Token，接下来我们来使用Token获取数据。我们新建一个端口号为5001的Web应用程序，同时安装包 `Microsoft.AspNetCore.Authentication.JwtBearer` 接下来在Startup中ConfigureServices添加如下代码：

```C#
services.AddAuthentication (JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer (options => {
        options.TokenValidationParameters = new TokenValidationParameters {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey (Encoding.UTF8.GetBytes ("1234567890123456")),

            ValidateIssuer = true,
            ValidIssuer = "http://localhost:5000",

            ValidateAudience = true,
            ValidAudience = "http://localhost:5001",

            ValidateLifetime = true,

            ClockSkew = TimeSpan.FromMinutes (5)
        };
    });
```

如上述若Token依赖于第三方而创建，此时必然会配置issuer和audience，同时在我方也如上必须验证issuer和audience，上述我们也验证了签名，我们通过设置 ValidateLifetime  为true，说明验证过期时间而并非Token中的值，最后设置 ClockSkew  有效期为5分钟。对于设置 ClockSkew  除了如上方式外，还可如下设置默认也是5分钟。

```C#
ClockSkew = TimeSpan.Zero
```

如上对于认证方案我们使用的是 JwtBearerDefaults.AuthenticationScheme 即Bearer，除此之外我们也可以自定义认证方案名称，如下：

![x](./Resource/60.png)

最后别忘记添加认证中间件在Configure方法中，认证中间件必须放在使用MVC中间件之前，如下：

```C#
app.UseAuthentication ();

app.UseMvc (routes => {
    routes.MapRoute (
        name: "default",
        template: "{controller=Home}/{action=Index}/{id?}");
});
```

到了这里，我们通过端口为5000的Web Api创建了Token，并配置了端口号为5001的Web应用程序使用JWT认证，接下来最后一步则是调用端口号为5000的APi获取Token，并将Token设置到请求头中Authorization键的值，格式如下（注意Bearer后面有一个空格）：

```C#
('Authorization', 'Bearer ' + token);
```

我们在页面上放置一个按钮点击获取端口号为5000的Token后，接下来请求端口号为5001的应用程序，如下：

```js
$(function () {
    $('#btn').click(function () {
        $.get("http://localhost:5000/api/token").done(function (token) {
            $.ajax({
                type: 'get',
                contentType: 'application/json',
                url: 'http://localhost:5001/api/home',
                beforeSend: function (xhr) {
                    if (token !== null) {
                        xhr.setRequestHeader('Authorization', 'Bearer ' + token);
                    }
                },
                success: function (data) {
                    alert(data);
                },
                error: function (xhr) {
                    alert(xhr.status);
                }
            });
        });
    });
});
```

![x](./Resource/61.png)

![x](./Resource/62.png)

## 参考

1. 一篇不错的[教程](https://www.cnblogs.com/wyt007/p/11459547.html)和[示例代码](https://github.com/FlyLolo)
2. [JWT Token刷新方案](https://blog.csdn.net/m0_37809141/article/details/86572697)
3. [解决使用jwt刷新token带来的问题](https://segmentfault.com/a/1190000013151506)
4. [ASP.NET Core Web Api之JWT](https://www.cnblogs.com/CreateMyself/p/11123023.html)
5. [ASP.NET MVC使用Oauth2.0实现身份验证](https://blog.csdn.net/sD7O95O/article/details/78852449)
