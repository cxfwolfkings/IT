# ABP框架

一直想写一些技术文章，但是总觉得自己学的不甚满意，想等到钻研透彻之后再动笔。结果就是，到现在也没有拿起笔来。静下心来想想，任何成就（包括写一篇高质量的技术文）都不是一蹴而就的，总要经过反复审阅，修改。现在不着手练起，以后也不会有打通任督二脉的一天。那何不现在就动笔呢，即使写得不好，也可以多改改嘛。

最近在学习领域驱动设计，看了不少理论文章，虽然看的时候大意都懂，但是总是不能深入其思想，得其精髓。毕竟脱离了实践，就像纸上谈兵（好歹赵括还能根据兵书夸夸其谈，如果让我讲一下领域驱动，估计能讲满3分钟就不错了）。

鉴于自己现在是一个.NET程序猿（其实本人是一个想做科学家的工程师...），就想在.NET环境下寻找一个比较好的实现领域驱动的解决方案。不久，大名鼎鼎的ABP框架以不可阻挡之势闯进了我的猿生。

ABP的官方文档都是英文版，而英语是我现在亟需提高的技能，那么，理所当然地，先翻译几篇重要的教程练练手（当然，我不是逐字翻译，我会尽量使用简洁的语言将文档中的意思表述清楚）。

下面，开始！

## 目录

1. [简述](#简述)
   - [一个快速示例](#一个快速示例)
   - [入门](#入门)
   - [社区](#社区)
   - [使用ASP.NET Core和Entity Framework Core](#使用ASP.NET&nbsp;Core和EntityFramework&nbsp;Core)
     - [创建应用程序](#创建应用程序)
     - [开发应用程序](#开发应用程序)

## 简述

ASP.NET Boilerplate(ABP)是一个开源的应用框架，同时又不仅仅是一个框架，它提供一个基于领域驱动设计的强架构模型，包含了作者认为的最佳实践。

ABP既支持最新版的ASP.NET Core和EF Core，也支持ASP.NET MVC 5.x和EF 6.x。

### 一个快速示例

让我们研究一个简单的类来看看ABP框架的好处：

```C#
public class TaskAppService : ApplicationService, ITaskAppService
{
    private readonly IRepository<Task> _taskRepository;

    public TaskAppService(IRepository<Task> taskRepository)
    {
        _taskRepository = taskRepository;
    }

    [AbpAuthorize(MyPermissions.UpdateTasks)]
    public async Task UpdateTask(UpdateTaskInput input)
    {
        Logger.Info("Updating a task for input: " + input);

        var task = await _taskRepository.FirstOrDefaultAsync(input.TaskId);
        if (task == null)
        {
            throw new UserFriendlyException(L("CouldNotFindTheTaskMessage"));
        }

        input.MapTo(task);
    }
}
```

这是一个简单的应用服务方法，在领域驱动模式中，应用服务直接被展示层使用，来展现应用用例。UpdateTask可以想象为一个被js的ajax调用的方法。
让我们看一下ABP的一些好处：

- 依赖注入：ABP使用了传统的依赖注入。此示例是一个应用服务类，按惯例我们将它以transient（每次请求都创建一个新实例）方式注册进DI容器中，它能简单地注入任何依赖项（比如本例中`IRepository<Task>`，通过构造器注入）
- 仓储：ABP会给每个实体(entity)创建一个默认的仓储(repository)，例如本例中的`IRepository<Task>`。默认的repository类提供很多有用的方法（本例中的FirstOrDefault），当然，为了满足需求，我们也可以自定义类继承它。Repositories封装了DBMS（数据库管理服务）和ORMs（对相关系映射），从而简化了数据获取的逻辑。
- 权限认证：ABP可以使用“属性声明”验证权限，如果当前用户没有"update tasks"权限或者没有登录就无法访问UpdateTask方法。当然也有其它验证权限的方法
- 表单验证：ABP可以自动验证输入是否为null，也会验根据声明属性和自定义验证规则验证所有输入数据。如果验证不通过，会抛出一个对应的验证异常，并在客户端处理
- 审计日志：每次请求的用户，浏览器，IP地址，正在调用的服务，方法，参数，调用时间，执行过程，以及其它信息都会基于协议和配置自动保存
- 工作单元：在ABP中，每个应用服务方法都被默认设置为一个工作单元。它自动创建连接，开启事务，成功执行后提交事务，关闭连接。即使这个方法使用了不同的仓储和方法，它们都是原子性的（事务化）。事务提交时，实体上的所有变化都会自动保存，甚至不需要调用_repository.Update(task)方法
- 异常处理：在ABP框架搭建的Web应用中，我们几乎不需要手动处理异常！所有异常都默认会处理。当发生异常时，ABP框架会自动记录日志，然后返回合适的结果给客户端。举例来说，如果这是一个ajax请求，它会返回一个JSON对象到客户端指示发生了错误。对客户端它会隐藏真正的异常信息除非异常被声明为UserFriendlyException类型。它也能理解和处理客户端的错误，给客户显示友好的信息
- 日志：我们可以使用基类中定义的Logger对象写日志，默认使用Log4Net，当然也可以自行配置
- 本地化：注意我们写异常消息的时候用了'L'方法？这样就可以自动本地化用户的语言。
- 自动映射：在最后一行，我们使用ABP的MapTo扩展方法来映射输入属性到实体属性。它使用了AutoMapper 类库来实现映射。使用命名协议我们可以简单地从一个对象映射属性到另一个对象
- 动态API层：事实上，TaskAppService是一个简单的类。一般来说，我们必须写一个API Controller的包装类来暴露方法给js客户端，但是ABP框架在运行时自动做了这一步，这样我们就能从客户端直接使用应用服务方法。
- 动态JavaScript AJAX代理：ABP框架在客户端创建了代理方法，使得调用应用服务层方法和调用js方法一样简单。

我们可以从这个简单的类中看到ABP框架的优势。所有这些任务通常需要很长时间，但是由框架自动处理了。

除了这个简单的例子，ABP为模块化，多租户，缓存，后台作业，数据过滤器，设置管理，领域事件，单元和集成测试等提供了强大的基础架构和开发模型 ......您只需要专注于您的业务代码而不需要重复做这些事！

### 入门

从启动模板直接创建一个现代化的启动项目：[https://aspnetboilerplate.com/Templates](https://aspnetboilerplate.com/Templates)

### 社区

这是一个开源项目，对社区的贡献开放。

- 使用[GitHub存储库](https://github.com/aspnetboilerplate/aspnetboilerplate)访问最新的源代码，创建问题并发送拉取请求。
- 在stackoverflow上使用[aspnetboilerplate](https://stackoverflow.com/questions/tagged/aspnetboilerplate)标记来询问有关用法的问题。
- 在Twitter上关注[aspboilerplate](https://twitter.com/aspboilerplate)以了解发生的事情。

### 使用ASP.NET&nbsp;Core和EntityFramework&nbsp;Core

在本文中，我将展示使用以下工具创建一个简单的跨平台分层 Web应用程序：

- .Net Core作为基础跨平台应用程序开发框架。
- ASP.NET Boilerplate(ABP)作为启动模板和应用程序框架。
- ASP.NET Core作为Web框架。
- Entity Framework Core作为ORM框架。
- Twitter Bootstrap作为HTML和CSS框架。
- jQuery作为客户端AJAX/DOM库。
- xUnit和Shouldly 用于服务器端单元/集成测试。

我还将使用默认包含在ABP 启动模板中的Log4Net和AutoMapper。我们将使用以下技术：

- 分层架构
- 领域驱动设计（DDD）
- 依赖注入（DI）
- 集成测试

这里将开发的项目是一个简单的任务管理应用程序，可以将任务分配给人员。我不会逐层开发应用程序，而是随着应用程序的增长而转向垂直深入并更改层。随着应用程序的增长，我将根据需要介绍ABP和其他框架的一些功能。

#### 创建应用程序

我使用ABP的[启动模板](http://www.aspnetboilerplate.com/Templates)创建了一个名为"Acme.SimpleTaskApp"的新Web应用程序。创建模板时，公司名称（此处为"Acme"）是可选的。我还选择了多页面Web应用程序，因为我不想在本文中使用SPA，因为我想要最基本的启动模板，所以我禁用了身份验证：

它创建了一个分层解决方案，包括6个项目，以我作为项目名称输入的名称开头：

- .Core项目用于域/业务层（实体，域服务......）
- .Application项目适用于应用层（DTO，应用服务......）
- .EntityFramework项目用于EF Core集成（从其他层抽象EF Core）。
- .Web项目适用于ASP.NET MVC层。
- .Tests项目用于单元和集成测试（直到应用层，不包括web层）
- .Web.Tests项目用于ASP.NET Core集成测试（包括web层的完整集成测试）。

#### 开发应用程序

***创建任务实体***

我想从一个简单的Task实体开始。由于实体是域层的一部分，我将其添加到.Core项目中：

```C#
using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using Abp.Domain.Entities;
using Abp.Domain.Entities.Auditing;
using Abp.Timing;

namespace Acme.SimpleTaskApp.Tasks
{
    [Table("AppTasks")]
    public class Task : Entity, IHasCreationTime
    {
        public const int MaxTitleLength = 256;
        public const int MaxDescriptionLength = 64 * 1024; //64KB

        [Required]
        [StringLength(MaxTitleLength)]
        public string Title { get; set; }

        [StringLength(MaxDescriptionLength)]
        public string Description { get; set; }

        public DateTime CreationTime { get; set; }

        public TaskState State { get; set; }

        public Task()
        {
            CreationTime = Clock.Now;
            State = TaskState.Open;
        }

        public Task(string title, string description = null)
            : this()
        {
            Title = title;
            Description = description;
        }
    }

    public enum TaskState : byte
    {
        Open = 0,
        Completed = 1
    }
}
```

- 我派生自ABP的基本Entity类，默认情况下包括Id属性为int。我们可以使用通用版本 `Entity<TPrimaryKey>` 来选择不同的PK类型。
- IHasCreationTime是一个简单的接口，只定义CreationTime属性（最好使用CreationTime的标准名称）。
- 任务实体定义了必需的标题和可选的描述。
- TaskState是一个简单的枚举，用于定义任务的状态。
- Clock.Now默认返回DateTime.Now。但它提供了抽象，因此如果需要，我们可以轻松切换到功能中的DateTime.UtcNow。在使用ABP框架时，始终使用Clock.Now而不是DateTime.Now。
- 我想将Task实体存储到数据库中的AppTasks表中。
