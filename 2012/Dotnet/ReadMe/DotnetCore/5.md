# 项目总结

## 目录

1. [mvc](#mvc)
2. [前端](../../../../2015/Frontend/ReadMe/vue_2.md)

## mvc

### 过滤器

- 异常过滤器

```C#
public class LaboratoryAuthorizeFilter : IAuthorizationFilter
{
    /// <summary>
    /// 判断是否Ajax请求，jQuery有效，
    /// Vue、Angular等要手动在请求头中添加标识
    /// </summary>
    /// <param name="filterContext"></param>
    /// <returns></returns>
    private bool IsAjax(ActionExecutingContext filterContext)
    {
        if (filterContext == null)
        {
            throw new ArgumentNullException("filterContext");
        }
        return filterContext.HttpContext.Request.Headers["X-Requested-With"] == "XMLHttpRequest";
    }

    /// <summary>
    /// 判断是否不需要权限
    /// </summary>
    /// <param name="filers"></param>
    /// <returns></returns>
    private static bool IsHaveAllow(IList<IFilterMetadata> filers)
    {
        for (int i = 0; i < filers.Count; i++)
        {
            if (filers[i] is IAllowAnonymousFilter)
            {
                return true;
            }
        }
        return false;
    }

    /// <summary>
    ///  请求验证
    /// </summary>
    /// <param name="context">请求内容信息</param>
    public void OnAuthorization(AuthorizationFilterContext context)
    {
        if (IsHaveAllow(context.Filters))
        {
            return;
        }
        int status = context.HttpContext.Response.StatusCode;
        // 检测是否包含'Authorization'请求头
        if (!context.HttpContext.Request.Headers.ContainsKey("Authorization"))
        {
            throw new Exception("请先登录系统！");
        }
        // 通过ActionContext类的RouteData属性获取Controller的名称：Home
        string controllerName = context.RouteData.Values["Controller"].ToString();
        // 通过ActionContext类的RouteData属性获取Action的名称：Index
        string actionName = context.RouteData.Values["Action"].ToString();
        /**
         *  通过ActionContext类的ActionDescriptor属性，也可以获取Action的名称
         *  不过这样获取到的是Action的完全限定名：
         *  AspNetCoreFilterContext.Controllers.HomeController.Index (AspNetCoreFilterContext)，
         *  可以看到其中还包含Controller的类名、命名空间和程序集名称
         */
        string fullActionName = context.ActionDescriptor.DisplayName;

        // 解析url
        var url = context.HttpContext.Request.Path.Value;
        if (string.IsNullOrWhiteSpace(url))
        {
            return;
        }
        var list = url.Split("/");
        if (list.Length <= 0 || url == "/")
        {
            return;
        }
        controllerName = list[1].ToString().Trim();
        actionName = list[2].ToString().Trim();
    }
}
```

- 异常过滤器

```C#
public class LaboratoryExceptionFilter : IExceptionFilter
    {
        private LogHelper logger = new LogHelper();

        public void OnException(ExceptionContext context)
        {
            string message = string.Format("消息类型：{0}\t\n消息内容：{1}\t\n引发异常的方法：{2}\t\n引发异常源：{3}"
                , context.Exception.GetType().Name
                , context.Exception.Message
                 , context.Exception.TargetSite
                 , context.Exception.Source + context.Exception.StackTrace
                 );
            logger.Error(context.Exception.GetType(), message);

            // 分别处理common request和ajax request
            if (LabHelper.IsAjax(context.HttpContext))
            {
                // Because its a exception raised after ajax invocation, Lets return Json
                context.Result = new JsonResult(new ResultViewModel
                {
                    Msg = context.Exception.Message,
                    Code = (int)HttpStatusCode.InternalServerError
                });
                context.ExceptionHandled = true;
                context.HttpContext.Response.Clear();
            }
            else
            {
                // 重定向到错误页面
                context.ExceptionHandled = true;
                context.Result = new RedirectResult("~/Error/Error?msg=" + HttpUtility.UrlEncode("系统发生未知错误，请稍后重试。如果错误持续发生，请联系IT Service Desk:  +86-21-28922999转1。"));
            }
        }
    }
```

### 登录

- 生成token码（待验证）

```C#
// push the user's name into a claim, so we can identify the user later on.
var claims = new[] { new Claim(ClaimTypes.Name, username) };
// sign the token using a secret key.This secret will be shared between your API and anything that needs to check that the token is legit.
var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["JWT:Key"]));
var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
// .NET Core's JwtSecurityToken class takes on the heavy lifting and actually creates the token.
var token = new JwtSecurityToken(
    issuer: _configuration["JWT:Issuer"],
    audience: _configuration["JWT:Audience"],
    claims: claims,
    expires: DateTime.Now.AddSeconds(5),
    signingCredentials: creds);
string jwtStr = new JwtSecurityTokenHandler().WriteToken(token);
```

- 生成token码

```C#
public class JwtHelper
    {
        /// <summary>
        /// 颁发JWT字符串
        /// </summary>
        /// <param name="tokenModel"></param>
        /// <returns></returns>
        public static string IssueJwt(TokenModelJwt tokenModel)
        {
            string iss = Appsettings.app(new string[] { "JWT", "Issuer" });
            string aud = Appsettings.app(new string[] { "JWT", "Audience" });
            string secret = Appsettings.app(new string[] { "JWT", "Key" });
            // var claims = new Claim[] //old
            var claims = new List<Claim>
            {
                /*
                 * 特别重要：
                 *   1、这里将用户的部分信息，比如 uid 存到了Claim 中，如果你想知道如何在其他地方将这个 uid从 Token 中取出来，
                 *      请看下边的SerializeJwt() 方法，或者在整个解决方案，搜索这个方法，看哪里使用了！
                 *   2、你也可以研究下 HttpContext.User.Claims，具体的你可以看看 Policys/PermissionHandler.cs 类中是如何使用的。
                 */
                new Claim(JwtRegisteredClaimNames.Jti, tokenModel.Uid.ToString()),
                new Claim(JwtRegisteredClaimNames.Iat, $"{new DateTimeOffset(DateTime.Now).ToUnixTimeSeconds()}"),
                new Claim(JwtRegisteredClaimNames.Nbf, $"{new DateTimeOffset(DateTime.Now).ToUnixTimeSeconds()}") ,
                // 这个就是过期时间，目前是过期10秒，可自定义，注意JWT有自己的缓冲过期时间
                new Claim (JwtRegisteredClaimNames.Exp, $"{new DateTimeOffset(DateTime.Now.AddSeconds(10)).ToUnixTimeSeconds()}"),
                new Claim(JwtRegisteredClaimNames.Iss, iss),
                new Claim(JwtRegisteredClaimNames.Aud, aud),
                // 这个Role是官方UseAuthentication要要验证的Role，我们就不用手动设置Role这个属性了
                new Claim(ClaimTypes.Role, tokenModel.Role), // 为了解决一个用户多个角色（比如：Admin,System），用下边的方法
            };

            // 可以将一个用户的多个角色全部赋予；
            // 作者：DX 提供技术支持；
            // claims.AddRange(tokenModel.Role.Split(',').Select(s => new Claim(ClaimTypes.Role, s)));

            // 秘钥（SymmetricSecurityKey 对安全性的要求，密钥的长度太短会报出异常）
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            var jwt = new JwtSecurityToken(
                issuer: iss,
                claims: claims,
                signingCredentials: creds);

            var jwtHandler = new JwtSecurityTokenHandler();
            var encodedJwt = jwtHandler.WriteToken(jwt);

            return encodedJwt;
        }

        /// <summary>
        /// 解析
        /// </summary>
        /// <param name="jwtStr"></param>
        /// <returns></returns>
        public static TokenModelJwt SerializeJwt(string jwtStr)
        {
            var jwtHandler = new JwtSecurityTokenHandler();
            JwtSecurityToken jwtToken = jwtHandler.ReadJwtToken(jwtStr);
            object role;
            try
            {
                jwtToken.Payload.TryGetValue(ClaimTypes.Role, out role);
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                throw;
            }
            var tm = new TokenModelJwt
            {
                Uid = (jwtToken.Id).ObjToInt(),
                Role = role != null ? role.ObjToString() : "",
            };
            return tm;
        }
    }

    /// <summary>
    /// 令牌
    /// </summary>
    public class TokenModelJwt
    {
        /// <summary>
        /// Id
        /// </summary>
        public long Uid { get; set; }

        /// <summary>
        /// 角色
        /// </summary>
        public string Role { get; set; }
    }
```

- 登录方法

```C#
[Route("Login")]
[HttpPost]
[AllowAnonymous]
public ActionResult Login([FromForm]string username, [FromForm]string password)
{
    if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(password))
    {
        throw new Exception("用户名或密码不能为空！");
    }
    AccountViewModel accountViewModel = _accountService.GetAcount(username, password);

    // 将用户id和角色名，作为单独的自定义变量封装进 token 字符串中。
    TokenModelJwt tokenModel = new TokenModelJwt { Uid = accountViewModel.Id, Role = accountViewModel.Role.RoleName };
    string jwtStr = JwtHelper.IssueJwt(tokenModel);//登录，获取到一定规则的 Token 令牌

    // 将登录信息保存到session中
    // HttpContext.Session.SetString("Account", JsonHelper.GetJSON<AccountViewModel>(accountViewModel));
    return Ok(new ResultViewModel
    {
        Code = 200,
        Data = new
        {
            token = jwtStr,
            profile = accountViewModel
        }
    });
}
```

- 权限控制示例

```C#
[Route("AddAssetModel")]
[HttpPost]
[Authorize(Roles = "系统管理员,实验室管理员")]
public ActionResult AddAssetModel([FromForm]AssetModelInputDto input)
{
    _assetService.AddAssetModel(input);
    return Ok(new ResultViewModel
    {
        Code = (int)HttpStatusCode.OK
    });
}
```

### 公用方法

```C#
public static bool IsAjax(HttpContext context)
{
    return context.Request.Headers["X-Requested-With"] == "XMLHttpRequest";
}
```
