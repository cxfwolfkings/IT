# 目录

1. 简介
   - [HTTPS原理](#HTTPS原理)
   - [window和document](#window和document)
   - [object](#object)
     - [wbbrowser](#wbbrowser)
       - 打印示例
     - [地理位置](#地理位置)
     - [历史记录管理](#历史记录管理)
     - [跨域消息传递](#跨域消息传递)
     - [Web Worker](#WebWorker)
   - [伪元素](#伪元素)
   - [embed标签](#embed标签)
   - [Function.prototype.bind](#Function.prototype.bind)
   - [document.write](#document.write)
   - [document.execCommand](#document.execCommand)
   - [获取数组中最大值和最小值的方法汇总](#获取数组中最大值和最小值的方法汇总)
   - [with](#with)
   - [异步](#异步)
   - [跨域](#跨域)
   - [类型检测](#类型检测)
   - [正则表达式](#正则表达式)
   - [剪切板](#剪切板)
   - [动态加载JS和CSS](#动态加载JS和CSS)
   - [判断IE版本的HTML语句详解](#判断IE版本的HTML语句详解)
   - [让IE6/IE7/IE8支持CSS3属性的8种方法介绍](#让IE6/IE7/IE8支持CSS3属性的8种方法介绍)
2. 实战
   - [阻止冒泡和默认行为](#阻止冒泡和默认行为)
3. 参考
   - [流式编程](#流式编程)
     - 概念
       - [流式应用](#流式应用)
       - [瀑布流](#瀑布流)
       - [实时计算](#实时计算)
       - [流处理](#流处理)
     - 来源和结论
       - [页面结构](#页面结构)
       - [接口请求](#接口请求)
       - [优化顺序](#优化顺序)
     - 实例分析
       - [单接口情况](#单接口情况)
       - [多接口](#多接口)
       - [实时+触发](#实时+触发)
       - [复杂页面](#复杂页面)
   - [DOM操作成本到底高在哪儿](#DOM操作成本到底高在哪儿)
     - [什么是DOM？](#什么是DOM)
     - [浏览器渲染过程](#浏览器渲染过程)

## HTTPS原理

随着 HTTPS 建站的成本下降，现在大部分的网站都已经开始用上 HTTPS 协议。大家都知道 HTTPS 比 HTTP 安全，也听说过与 HTTPS 协议相关的概念有 SSL 、非对称加密、 CA证书等，但对于以下灵魂三拷问可能就答不上了：

1. 为什么用了 HTTPS 就是安全的？
2. HTTPS 的底层原理如何实现？
3. 用了 HTTPS 就一定安全吗？

本文将层层深入，从原理上把 HTTPS 的安全性讲透。

### HTTPS 的实现原理

大家可能都听说过 HTTPS 协议之所以是安全的是因为 HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现。但其实，HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。

HTTPS的整体过程分为 **证书验证** 和 **数据传输** 阶段，具体的交互过程如下：

![x](./Resource/https1.jpg)

#### 1、证书验证阶段

1. 浏览器发起 HTTPS 请求
2. 服务端返回 HTTPS 证书
3. 客户端验证证书是否合法，如果不合法则提示告警

#### 2、数据传输阶段

1. 当证书验证合法后，在本地生成随机数
2. 通过公钥加密随机数，并把加密后的随机数传输到服务端
3. 服务端通过私钥对随机数进行解密
4. 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输

**为什么数据传输是用对称加密？**

首先，非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；

另外，在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。

**为什么需要 CA 认证机构颁发证书？**

HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题。

首先我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的“中间人攻击”问题。

“中间人攻击”的具体过程如下：

![x](./Resource/https2.jpg)

过程原理：

1. 本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器
2. 中间人服务器返回中间人自己的证书
3. 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输
4. 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密
5. 中间人以客户端的请求内容再向正规网站发起请求
6. 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据
7. 中间人凭借与正规网站建立的对称加密算法对内容进行解密
8. 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
9. 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。

浏览器是如何确保 CA 证书的合法性？

**1、证书包含什么信息？**

- 颁发机构信息
- 公钥
- 公司信息
- 域名
- 有效期
- 指纹
- ......

**2、证书的合法性依据是什么？**

首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。

另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。

**3、浏览器如何验证证书的合法性？**

浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：

1. 验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；

2. 判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；

   ![x](./Resource/https3.jpg)

3. 判断证书是否被篡改。需要与 CA 服务器进行校验；

4. 判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率

以上任意一步都满足的情况下浏览器才认为证书是合法的。

这里插一个我想了很久的但其实答案很简单的问题：

既然证书是公开的，如果要发起中间人攻击，我在官网上下载一份证书作为我的服务器证书，那客户端肯定会认同这个证书是合法的，如何避免这种证书冒用的情况？

其实这就是非加密对称中公私钥的用处，虽然中间人可以得到证书，但私钥是无法获取的，一份公钥是不可能推算出其对应的私钥，中间人即使拿到证书也无法伪装成合法服务端，因为无法对客户端传入的加密数据进行解密。

**4、只有认证机构可以生成证书吗？**

如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但浏览器通常只是提示安全风险，并不限制网站不能访问，所以从技术上谁都可以生成证书，只要有证书就可以完成网站的 HTTPS 传输。例如早期的 12306 采用的便是手动安装私有证书的形式实现 HTTPS 访问。

**Q：本地随机数被窃取怎么办？**

证书验证是采用非对称加密实现，但是传输过程是采用对称加密，而其中对称加密算法中重要的随机数是由本地生成并且存储于本地的，HTTPS 如何保证随机数不会被窃取？

其实 HTTPS 并不包含对随机数的安全保证，HTTPS 保证的只是传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。

**Q：用了 HTTPS 会被抓包吗？**

HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。

但是，正如前文所说，浏览器只会提示安全风险，如果用户授权仍然可以继续访问网站，完成请求。因此，只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。

通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。

**Q：既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？**

A: 客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。

**Q: 为什么需要证书？**

A: 防止”中间人“攻击，同时可以为网站提供身份证明。

**Q: 使用 HTTPS 会被抓包吗？**

A: 会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。

## embed标签

一、基本语法：embed src=url

说明：embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等，
      Netscape及新版的IE 都支持。url为音频或视频文件及其路径，可以是相对路径或绝对路径。

示例：

```html
<embed src="your.mid">
```

二、属性设置：

1、自动播放：

语法：autostart=true、false

说明：该属性规定音频或视频文件是否在下载完之后就自动播放。

- true：音乐文件在下载完之后自动播放；
- false：音乐文件在下载完之后不自动播放。

示例：

```html
<embed src="your.mid" autostart=true>
<embed src="your.mid" autostart=false>
```

2、循环播放：

语法：loop=正整数、true、false

说明：该属性规定音频或视频文件是否循环及循环次数。

属性值为正整数值时，音频或视频文件的循环次数与正整数值相同；

- 属性值为true时，音频或视频文件循环；
- 属性值为false时，音频或视频文件不循环。

示例：

```html
<embed src="your.mid" autostart=true loop=2>
<embed src="your.mid" autostart=true loop=true>
<embed src="your.mid" autostart=true loop=false>
```

3、面板显示：

语法：hidden=ture、no

说明：该属性规定控制面板是否显示，默认值为no。

- ture：隐藏面板；
- no：显示面板。

示例：

```html
<embed src="your.mid" hidden=ture>
<embed src="your.mid" hidden=no>
```

4、开始时间：

语法：starttime=mm:ss（分：秒）

说明：该属性规定音频或视频文件开始播放的时间。未定义则从文件开头播放。

示例：

```html
<embed src="your.mid" starttime="00:10">
```

5、音量大小：

语法：volume=0-100之间的整数

说明：该属性规定音频或视频文件的音量大小。未定义则使用系统本身的设定。

示例：

```html
<embed src="your.mid" volume="10">
```

6、容器属性：

语法：height=# width=#

说明：取值为正整数或百分数，单位为像素。该属性规定控制面板的高度和宽度。

- height：控制面板的高度；
- width：控制面板的宽度。

示例：

```html
<embed src="your.mid" height=200 width=200>
```

7、容器单位：

语法：units=pixels、en

说明：该属性指定高和宽的单位为pixels或en。

示例：

```html
<embed src="your.mid" units="pixels" height=200 width=200>
<embed src="your.mid" units="en" height=200 width=200>
```

8、外观设置：

语法：controls=console、smallconsole、playbutton、pausebutton、stopbutton、
      volumelever 说明：该属性规定控制面板的外观。默认值是console。

- console：一般正常面板；
- smallconsole：较小的面板；
- playbutton：只显示播放按钮；
- pausebutton：只显示暂停按钮；
- stopbutton：只显示停止按钮；
- volumelever：只显示音量调节按钮。

示例：

```html
<embed src="your.mid" controls=smallconsole>
<embed src="your.mid" controls=volumelever>
```

9、对象名称：

语法：name=#

说明：#为对象的名称。该属性给对象取名，以便其他对象利用。

示例：

```html
<embed src="your.mid" >
```

10、说明文字：

语法：title=#

说明：#为说明的文字。该属性规定音频或视频文件的说明文字。

示例：

```html
<embed src="your.mid" title="第一首歌">
```

11、前景色和背景色：

语法：palette=color|color

说明：该属性表示嵌入的音频或视频文件的前景色和背景色，第一个值为前景色，第二个值为背景
      色，中间用 | 隔开。color可以是RGB色（RRGGBB）也可以是颜色名，还可以是transparent
     （透明）。 示例：<embed src="your.mid" palette="red|black">

12、对齐方式：

语法：align=top、bottom、center、baseline、 left、right、texttop、middle、
      absmiddle、absbottom

说明：该属性规定控制面板和当前行中的对象的对齐方式。

- center：控制面板居中；
- left：控制面板居左；
- right：控制面板居右；
- top：控制面板的顶部与当前行中的最高对象的顶部对齐；
- bottom：控制面板的底部与当前行中的对象的基线对齐；
- baseline：控制面板的底部与文本的基线对齐；
- texttop：控制面板的顶部与当前行中的最高的文字顶部对齐；
- middle：控制面板的中间与当前行的基线对齐；
- absmiddle：控制面板的中间与当前文本或对象的中间对齐；
- absbottom：控制面板的底部与文字的底部对齐。

示例：

```html
<embed src="your.mid" align=top>
<embed src="your.mid" align=center>
```

## with

**简要说明：**

with语句可以方便地用来引用某个特定对象中已有的属性，但是不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。  

**语法格式：**

```js
with(object instance) {
  //代码块  
}
```

有时候，我在一个程序代码中，多次需要使用某对象的属性或方法，照以前的写法，都是通过 `对象.属性` 或者 `对象.方法` 这样的方式来分别获得该对象的属性和方法，着实有点麻烦，学习了with语句后，可以通过类似如下的方式来实现：

```js
with(objInstance) {
  var str = 属性1;
  .....  
}
```

去除了多次写对象名的麻烦。

**举例：**

```html
<script language="javascript">  
<!--  
function Lakers() {  
  this.name = "kobe bryant";  
  this.age = "28";  
  this.gender = "boy";  
}  
var people=new Lakers();  
with(people) {  
  var str = "姓名: " + name + "<br>";  
  str += "年龄：" + age + "<br>";  
  str += "性别：" + gender;  
  document.write(str);  
}  
//-->  
</script>
```

代码执行效果如下:  

```sh
姓名: kobe bryant  
年龄：28  
性别：boy
```



## 跨域

1.什么是跨域

我们经常会在页面上使用ajax 请求访问其他服务器的数据，此时，客户端会出现跨域问题.跨域问题是由于javascript语言安全限制中的同源策略造成的。

简单来说，同源策略是指一段脚本只能读取来自同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合。

例如：

| URL                                                         | 说明                           | 是否允许通信                           |
| ----------------------------------------------------------- | ------------------------------ | -------------------------------------- |
| `http://www.a.com/a.js`, `http://www.a.com/b.js`            | 同一域名下                     | 允许                                   |
| `http://www.a.com/lab/a.js`, `http://www.a.com/script/b.js` | 同一域名下不同文件夹           | 允许                                   |
| `http://www.a.com:8000/a.js`, `http://www.a.com/b.js`       | 同一域名，不同端口             | 不允许                                 |
| `http://www.a.com/a.js`, `https://www.a.com/b.js`           | 同一域名，不同协议             | 不允许                                 |
| `http://www.a.com/a.js`, `http://70.32.92.74/b.js`          | 域名和域名对应ip               | 不允许                                 |
| `http://www.a.com/a.js`, `http://script.a.com/b.js`         | 主域相同，子域不同             | 不允许                                 |
| `http://www.a.com/a.js`, `http://a.com/b.js`                | 同一域名，不同二级域名（同上） | 不允许（cookie这种情况下也不允许访问） |
| `http://www.cnblogs.com/a.js`, `http://www.a.com/b.js`      | 不同域名                       | 不允许                                 |

2.实现原理

ajax通过XMLHttpRequest进行数据交互，浏览器出于安全考虑，不允许js代码进行跨域操作。

一般jQuery解决跨域是通过jsonp的方式，添加callback=xxx，服务器返回xxx(...)

通过CORS（跨域资源共享） Proxy对请求进行转发，就可以实现跨域访问。服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的

什么是JSONP

1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；

2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有"src"这个属性的标签都拥有跨域的能力，比如`<script>`、`<img>`、`<iframe>`）；

3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；

4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；

5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。

6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。

7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback 参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。

如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。

JSONP的客户端具体实现：

不管jQuery也好，ExtJs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现：

1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。

远程服务器remoteserver.com根目录下有个remote.js文件代码如下：

```js
alert('我是远程文件');
```

本地服务器localserver.com下有个jsonp.html页面代码如下：

```html
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>
</body>
</html>
```

毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。

2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。

jsonp.html页面代码如下：

```html
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <script type="text/javascript">
    var localHandler = function (data) {
      alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
  </script>
  <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>
</body>
</html>
```

remote.js文件代码如下：

```js
localHandler({"result":"我是远程js带来的数据"});
```

这里对返回的数据有个要求，即：服务器返回的数据不能是单纯的JSON。如果返回的是个json字符串，我们是没有办法引用这个字符串的，必须将它赋值给一个变量或者直接调用客户端JS方法。

运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。

3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。

看jsonp.html页面的代码：

```html
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <script type="text/javascript">
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function (data) {
      alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script);
  </script>
</head>
<body>
</body>
</html>
```

这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。

我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。

OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：

```js
flightHandler({
  "code": "CA1998",
  "price": 1780,
  "tickets": 5
});
```

我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！

4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。

什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：

```html
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <title>Untitled Page</title>
  <script type="text/javascript" src=jquery.min.js"></script>
  <script type="text/javascript">
    jQuery(document).ready(function () {
      $.ajax({
        type: "get",
        async: false,
        url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",
        dataType: "jsonp",
        jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
        jsonpCallback: "flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
        success: function (json) {
          alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
        },
        error: function () {
          alert('fail');
        }
      });
    });
  </script>
</head>
<body>
</body>
</html>
```

通过jquery的jsonp的方式。使用此方式，对服务器端有要求。

服务器端如下:

```C#
protected void Page_Load(object sender, EventArgs e)
{
    string callback = Request.QueryString["jsoncallback"];
    string result = callback + "({\"name\":\"zhangsan\",\"date\":\"2012-12-03\"})";
    Response.Clear();
    Response.Write(result);
    Response.End();
}
```

是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳 了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？

好啦，写到这里，我已经无力再写下去，又困又累，得赶紧睡觉。朋友们要是看这不错，觉得有启发，给点个“推荐”呗！由于实在比较简单，所以就不再提供demo源码下载了。

没想到上了博客园的头条推荐。看到大家对这篇文章的认可和评论，还是很开心的，这里针对ajax与jsonp的异同再做一些补充说明：

1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；

2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加`<script>`标签来调用服务器提供的js脚本。

3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。

4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。

总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！
说道这里很多人还不明白后台如何处理数据，这里稍微的说一下：

拿php来说吧 比如 $items_list 是一个数组

```php
$items_list=json_encode($items_list);
$callback=$_GET['callback'];
echo $callback."($items_list)";
exit;
```

服务端对于CORS的支持，主要通过设置Access-Control-Allow_Origin来进行

[http://www.phonegap100.com/portal.php?mod=view&aid=72](http://www.phonegap100.com/portal.php?mod=view&aid=72)

[http://www.cnblogs.com/oneword/archive/2012/12/03/2799443.html](http://www.cnblogs.com/oneword/archive/2012/12/03/2799443.html)

## 类型检测

### typeof

语法：

```js
typeof(表达式)
typeof 变量名
```

返回值：

```sh
1. 'undefined'  # 未定义的变量或值
2. 'boolean'    # 布尔类型的变量或值
3. 'string'     # 字符串类型的变量或值
4. 'number'     # 数字类型的变量或值
5. 'object'     # 对象类型的变量或值，或者null
6. 'function'   # 函数类型的变量或值
```

>将 `null` 作为 `object` 类型处理是 js 历史遗留问题。

## 正则表达式

```js
MatchCollection collection = Regex.Matches(html, "<(a|link|img|script|input|form).[^>]*(href|src|action)=(\\\"|'|)(.[^\\\"']*)(\\\"|'|)[^>]*>", RegexOptions.IgnoreCase);

foreach (Match match in collection) {
  if (match.Groups[match.Groups.Count - 2].Value.IndexOf("~") != -1) {
    string url = this.Page.ResolveUrl(match.Groups[match.Groups.Count - 2].Value);
    html = html.Replace(match.Groups[match.Groups.Count - 2].Value, url);
  }
}
```

## 剪切板

IE浏览器支持直接读写剪切板内容：

```js
window.clipboardData.clearData();  
window.clipboardData.setData('Text', 'abcd');
```

chrome/Firefox

```js
// 覆盖浏览器粘贴事件
document.addEventListener('paste', function (e) {
    var clipboardData = e.clipboardData;
    if (!(clipboardData && clipboardData.items)) {//是否有粘贴内容
        return;
    }
    for (var i = 0, len = clipboardData.items.length; i < len; i++) {
        var item = clipboardData.items[i];
        if (item.kind === "string" && item.type == "text/plain") {
            item.getAsString(function (str) {
                // str 是获取到的字符串,创建文本框
                //处理粘贴的文字内容
            })
        } else if (item.kind === "file") {//file 一般是各种截图base64数据
            var pasteFile = item.getAsFile();
            // pasteFile就是获取到的文件
            var reader = new FileReader();
            reader.onload = function (event) {
                var base64Img = event.target.result;
            }; // data url  
            reader.readAsDataURL(pasteFile);
        }
        var copy_content = e.clipboardData.getData('text/plain');
    }
})

// 写入系统剪切板，实测无效
e.clipboardData.setData('text/plain', defaultText);

// 1) 监听copy事件，触发copy命令
document.addEventListener("paste", function (e) {
    console.log(e.clipboardData.getData("text"));
});
document.onkeydown = function (e) {
    if (e.ctrlKey && e.keyCode == 67) {//ctrl+C
        function handler(event) {
            event.clipboardData.setData('text/plain', "自定义复制内容");
            document.removeEventListener('copy', handler, true);
            event.preventDefault();
        }
        document.addEventListener('copy', handler, true);
        document.execCommand('copy');
    }
}

// 2）通过将需要复制的内容赋值到文本中，将文本框内容选中，执行copy命令
// 复制  
document.onkeydown = function (e) {
    if (e.ctrlKey && e.keyCode == 86) {//ctrl+V
        var cloneActiveElement = "需要复制的内容";
        var copyText = document.getElementById("copy_text");
        copyText.innerHTML = cloneActiveElement;
        copyText.readOnly = false;
        copyText.select();
        copyText.setSelectionRange(0, copyText.value.length);
        document.execCommand("copy");
        copyText.readOnly = true;
    }
}

// 事件触发
if ("createEvent" in document) {
    var evt = document.createEvent("HTMLEvents");
    evt.initEvent("paste", false, true);
    element.dispatchEvent(evt);
} else {
    element.fireEvent("onchange");
}
```

## 伪元素

虽然标题里写的是伪元素,不过这篇文章主要是说::before和::after，其余几个伪元素（::first-letter、::first-line、::selection等)由于没有content属性，所以本文一笔带过，其实方法是一样的。

伪元素的重点在于一个**伪**，虽然它们可以被浏览器渲染引擎识别并正确渲染，然而<b style="color:red">伪元素本身并不是DOM元素</b>,所以无法被js直接操作——因此任何基于JS直接选取DOM元素的CSS更改方法对伪元素都不起作用。（JQ看似万能，这个问题上是直接就栽了。因为JQ的选择符都是基于DOM元素）关于JS和JQ选择器，可以参考这两篇文档：[Selectors API Level 1](http://www.w3.org/TR/selectors-api/)、[jQuery Selectors](http://api.jquery.com/category/selectors/)

### 获取伪元素的属性值

- `window.getComputedStyle`

  ```js
  var div=document.querySelector('div');
  var fontSize=window.getComputedStyle(div,'::before').getPropertyValue('font-size');//获取before伪元素的字号大小
  ```

  关于这个方法，详解可以参考这篇文章：[获取元素CSS值之getComputedStyle方法熟悉](http://www.zhangxinxu.com/wordpress/2012/05/getcomputedstyle-js-getpropertyvalue-currentstyle/)

### 更改伪元素的属性值

1. js更改data-*属性值来更改伪元素的content值
2. 创建多个class，通过切换class来达到改变样式的目的
3. 利用CSSStyleSheet的insertRule方法来添加样式
4. 利用内部css样式的高优先级来覆盖外部css

以上实现思路的推荐程度***依次递减***

data-*是HTML5新增的DOM元素属性，作用大致可以理解为标记。具体用法可以参考MDN的这篇文章.而伪元素的content属性值除了常规赋值外，还有一种特殊的attr()方法来获取。

html:

```html
<div class="test" data-text="TEXT" data-color="red"></div>
```

css:

```css
.test::before{
    content: attr(data-text);
}
```

结果：

```sh
TEXT
```

另外content其实可以多个attr连写，而且attr()内的可以是DOM元素的任意属性（比如class等，甚至非W3C标准属性也支持，不过不推荐这么做)所以很方便凑一些模版文字。像下面这种写法也是完全没问题的。***注意用空格连接，不要用"+"号***。

```css
.test::before {
  content: '我的类是' attr(class) '想要变成' attr(data-color);
}
```

虽然W3C给attr()赋予了[无限可能性](http://www.w3.org/TR/css3-values/#attr-notation)，包括color,width等属性在未来都有希望用这个方法更改，然而**目前只有`content`支持该方法**，其余的都还是草稿状态，尚未有浏览器支持。之所以把这个方法放在第一位只是因为相比别的实现手法来说，这个方法真的太简单太优雅。

### 更改class来实现伪元素样式的更改

class切换大法，不适合多状态的场景（比如实时改变伪元素文字大小等）

### 利用CSSStyleSheet的insertRule方法来添加样式

CSSStyleSheet是浏览器存放页面内所有css样式表的对象方法（不包括行内样式)，每个link和style标签都代表一个CSSStyleSheet对象，获取他们可以用document.styleSheets方法。(需要注意的是虽然styleSheets方法返回的结果把link标签引进的外部样式也算进去了，但是非IE浏览器没办法获取到他们的cssRules属性，只有内嵌的style标签内的元素可以被获取到)

```js
document.styleSheets[0].insertRule('.test::before{color:green}',0)//chrome,firefox等非IE浏览器使用
document.styleSheets[0].addRule('.test::before{color:green}',0)//IE系列浏览器使用
/* 虽然部分浏览器也可以通过id来指定,'document.styleSheets.id.insertRule()'这种写法在chrome和IE下都行得通，但是firefox会返回'undefined',所以建议还是使用index值来获取stylesheet */
```

.insertRule的语法是stylesheet.insertRule(rule, index),另一个参数是index，意思是在对应的styleSheets里的cssRules样式表中的位置，这个值越大则样式优先级越高，但是值不能超过当前样式表规则（cssRules）长度（CSS中先定义的样式总是会被后定义的覆盖就是这个缘故。），当值小于cssRules长度时，添加的样式规则会插入到index值定义的位置，之前其余的规则依次顺延。

>addrule和insertRule方法本质上没区别，只是后者不被IE浏览器识别，所以前者作为浏览器兼容方法存在。

上面的代码看似简单一行，然而却不是每次都有效的。原因有以下几点：

1. document.styleSheets虽然按照style和link的顺序返回对应的StyleSheetList，然而第一个如果是link而不是style,前面讲过此时无法获取对应的cssRules，则document.styleSheets[0].cssRules为null，insertRule方法不起作用。（此情况只针对非IE浏览器，IE浏览器正常，但是定义的早往往意味着被后面的样式覆盖，所以意义不大）
2. 同上，如果页面内没有内嵌样式的style标签，则insertRule方法也无法发挥作用。
3. index值不够大的话很有可能会早于css文件开始的定义位置，导致被覆盖。因此有个折衷办法就是给添加的样式增加!important，虽然我个人比较反感这么做。

由此可见此方法的局限性，但是这种方法的优雅之处在于避免了直接写内嵌样式，而是通过css api来做更改。相比下面的方法来说，稍微好点。

### HEAD中添加style标签强制覆盖初始属性

这个方法是利用内部css样式的高优先级来覆盖外部css，好处是简单易理解，实现简单。坏处就是吃相太难看，过于粗暴。

```js
var style=document.createElement('style');
style.innerHTML=".test::before{color:green}";//添加样式内容的话也可以用上面提到过的`insertRule`,相对例子里的硬编码会更优雅点。
document.head.appendChild(style);
```

看到这里可能有些人反应过来了，其实加style标签这种方法可以是insertRule实现方法的大前提——因为不是所有页面一开始都有内嵌的style样式的。这种方法虽然不是很好，但是有时候却又确确实实是必须的——比如“拖动滑块改变伪元素内文字大小”这个需求。

### 练习

功能需求：

1. 拖动滑块改变伪元素内的文字大小
2. 且伪元素内随时显示当前字号
3. 通过一个按钮可以改变伪元素内文字颜色

这个需求可以将本文前面提到的四种改变伪元素样式的方法都塞进去。具体实现参照[DEMO](http://codepen.io/chitanda/pen/OVBJEw/)，不再做具体分析。



## Function.prototype.bind

在初学Javascript时，我们也许不需要担心函数绑定的问题。但是当我们需要在另一个函数中保持上下文对象this时，就会遇到相应的问题了。

我见过很多人处理这种问题都是先将this赋值给一个变量（比如self、_this、that等），尤其是var that = this是我见的最多的。这样当你改变环境之后就可以使用它。这些都是可以的，但是还有一种更好的、更专有的方法，那就是使用`Function.prototype.bind`。下面进行详尽的讲解。

### 第一部分：需要解决的问题

首先看下面的代码：

```js
var myObj = {
  specialFunction: function () {},
  anotherSpecialFunction: function () {},
  getAsyncData: function (cb) {
    cb();
  },
  render: function () {
    this.getAsyncData(function () {
      this.specialFunction();
      this.anotherSpecialFunction();
    });
  }
};

myObj.render();
```

这里我希望创建一个对象。包含了前面两个普通的方法；第三个方法可以传递一个函数，传入的这个函数立即执行。最后一个方法会调用myObj对象的getAsyncData方法，这里使用了this。然后在getAsyncData方法中传入了一个函数，这个函数继续调用这个对象的前两个方法，仍使用了this。这时很多人实际上就可以看出问题所在了，将上述代码输入控制台，得到下面的结果：

```sh
TypeError: this.specialFunction is not a function
```

### 第二部分：问题剖析

- 在对象中render方法中的this的确是指向myObj对象的，所以我们可以通过this.getAsyncData来调用这个对象中的函数。
- 但是当我们给其传递函数作为参数时，这里的this就指向了全局环境window了，因为全局环境中没有对象中的前两个方法，所以才会报错。

### 第三部分：解决问题的几种方式

所以我们需要做的就是正确调用对象中的前两个方法 ，很多人使用的方法便是：

- 首先在对象的环境中获取this赋值给另一个变量，这时就可以在后面的环境中调用了，如下所示：

  ```js
  render: function () {
    var that = this;
    this.getAsyncData(function () {
      that.specialFunction();
      that.anotherSpecialFunction();
    });
  }
  ```

  虽然这种方法是可行的。但是使用Function.prototype.bind()会使代码更清晰、易懂，如下所示：

  ```js
  render: function () {
    this.getAsyncData(function () {
      this.specialFunction();
      this.anotherSpecialFunction();
    }.bind(this));
  }
  ```

  这里我们就成功地把this绑定到了环境中。下面是另外一个简单的例子：

  ```js
  var foo = { x: 3 }

  var bar = function () {
    console.log(this.x);
  }

  bar(); // undefined

  var boundFunc = bar.bind(foo);
  boundFunc(); // 3
  ```

  下面的例子也是常见的：

  ```js
  this.x = 9; // this refers to global "window" object here in the browser

  var module = {
    x: 81,
    getX: function() { return this.x; }
  };
  module.getX(); // 81

  var retrieveX = module.getX;
  retrieveX();
  // returns 9 - The function gets invoked at the global scope
  // Create a new function with 'this' bound to module
  // New programmers might confuse the
  // global var x with module's property x
  var boundGetX = retrieveX.bind(module);
  boundGetX(); // 81
  ```

  如果有兴趣想知道 `Function.prototype.bind()` 内部长什么样以及是如何工作的，这里有个非常简单的例子：

  ```js
  Function.prototype.bind = function (scope) {
    var fn = this;
    return function () {
      return fn.apply(scope);
    };
  }
  ```

### 第四部分：浏览器支持

但是这个方法在IE8及以下是不被支持的，所以我们可以使用MDN提供的方法来使得IE低版本支持.bind()方法：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
      fToBind = this,
      fNOP = function () { },
      fBound = function () {
        return fToBind.apply(this instanceof fNOP && oThis
          ? this
          : oThis,
          aArgs.concat(Array.prototype.slice.call(arguments)));
      };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
  };
}
```

## document.write

可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。该方法需要一个字符串参数，它是写到窗口或框架中的HTML内容。这些字符串参数可以是变量或值为字符串的表达式，写入的内容常常包括HTML标记语言。

记住，在载入页面后，浏览器输出流自动关闭。在此之后，任何一个对当前页面进行操作的document.write()方法将打开—个新的输出流，它将清除当前页面内容(包括源文档的任何变量或值)。因此，假如希望用脚本生成的HTML替换当前页面，就必须把HTML内容连接起来赋给一个变量，使用一个document.write()方法完成写操作。不必清除文档并打开一个新数据流，一个document.write()调用就可完成所有的操作。

关于document.write()方法还有一点要说明的是它的相关方法document.close()。脚本向窗口（不管是本窗口或其他窗口）写完内容后，必须关闭输出流。在延时脚本的最后一个document.write()方法后面，必须确保含有document.close()方法，不这样做就不能显示图像和表单。并且，任何后面调用的document.write()方法只会把内容追加到页面后，而不会清除现有内容来写入新值。为了演示document.write()方法，我们提供了同一个应用程序的两个版本。一个向包含脚本的文档中写内容，另—个向一个单独的窗口写内容。请在文本编辑器中键入每个文档，以.html文件扩展名保存，并在浏览器中打开文档。

示例1创建一个按钮，它为文档组合新的HTML内容，包括新文档标题的HTML标记和标记的颜色属性。示例中有一个读者所不熟悉的操作符+＝，它把其右侧的字符串加到其左侧的变量中，这个变量用来存放字符串，这个操作符能很方便地把几个单独的语句组合成—个长字符串。使用组合在newContent变量中的内容，document.write()语句可以把所有新内容写到文档中，完全清除示例1中的内容。然后需要调用document.close()语句关闭输出流。当载入该文档并单击按钮时，可以注意到浏览器标题栏中的文档标题因此而改变。当回到原始文档并再次单击该按钮时，可以看到动态写入的第二个页面的载入速度甚至比重载原始文档还要快。

示例1：在当前窗口使用document.write()。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Writing to Same Doc</title>
  <script language="JavaScript">
    function reWrite(){
      // assemble content for new window
      var newContent = "<html><head><title>A New Doc</title></head>"
      newContent += "<body bgcolor='aqua'><h1>This document is brand new.</h1>"
      newContent += "Click the Back button to see original document."
      newContent += "</body></html>"
      // write HTML to new window document
      document.write(newContent)
      document.close() // close layout stream
    }
  </script>
</head>
<body>
  <form>
    <input type="button" value="Replace Content" onClick="reWrite()">
  </form>
</body>
</html>
```

示例2中，情况有点复杂，因为脚本创建了一个子窗口，整个脚本生成的文档都将写入该窗口中。为了使新窗口的引用在两个函数中保持激活状态，我们将newWindow变量声明为全局变量。页面载入时，onLoad事件处理调用makeNewWindow()函数，该函数生成一个空的子窗口。另外，我们在window.open()方法的第三个参数中加入一个属性，使子窗口的状态栏可见。

页面上的按钮调用subWrite()方法，它执行的第一个任务是检查子窗口的closed属性。假如关闭了引用窗口，该属性（只在较新的浏览器版本中存在）返回true。如果是这种情况（假如用户手动关闭窗口），该函数再次调用makeNewWindow()函数来重新打开那个窗口。

窗口打开后，新的内容作为字符串变量组合在一起。与示例1一样，一次性写入内容（虽然对单独的窗口没有必要），接下来调用close()方法。但是注意一个重要的区别：write()和close()方法都明显地指定了子窗口。

示例2：在另一个窗口中使用document.write()

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Writing to Subwindow</title>
  <script language="JavaScript">
    var newWindow
    function makeNewWindow(){
      newWindow = window.open("","","status,height=200,width=300")
    }
    function subWrite(){
      // make new window if someone has closed it
      if(newWindow.closed){
        makeNewWindow()
      }
      // bring subwindow to front
      newWindow.focus()
      // assemble content for new window
      var newContent = "<html><head><title>A New Doc</title></head>"
      newContent += "<body bgcolor='coral'><h1>This document is brand new.</h1>"
      newContent += "</body></html>"
      // write HTML to new window document
      newWindow.document.write(newContent)
      newWindow.document.close()    // close layout stream
    }
  </script>
</head>
<body onLoad="makeNewWindow()">
  <form>
    <input type="button" value="Write to Subwindow" onClick="subWrite()">
  </form>
</body>
</html>
```

## document.execCommand

document.execCommand()方法处理Html数据时常用语法格式如下:

```js
document.execCommand(sCommand [, 交互方式, 动态参数])
```

其中：sCommand为指令参数（如下例中的"2D-Position"），交互方式参数如果是true的话将显示对话框，如果为false的话，则不显示对话框（下例中的"false"即表示不显示对话框），动态参数一般为一可用值或属性值（如下例中的"true"）。

```js
document.execCommand("2D-Position", "false", "true");
```

调用execCommand()可以实现浏览器菜单的很多功能。如保存文件、打开新文件、撤消、重做操作…等等。有了这个方法，就可以很容易的实现网页中的文本编辑器。使用的例子如下：

1、【全选】命令的实现

```js
格式：document.execCommand("selectAll")
说明：将选种网页中的全部内容！
```

2、【打开】命令的实现

```js
格式：document.execCommand("open")
说明：这跟VB等编程设计中的webbrowser控件中的命令有些相似，大家也可依此琢磨琢磨。
```

3、【另存为】命令的实现

```js
格式：document.execCommand("saveAs")
说明：将该网页保存到本地盘的其它目录！
```

4、【打印】命令的实现

```js
格式：document.execCommand("print")
说明：当然，你必须装了打印机！
```

**下面列出的是指令参数及意义：**

```js
//相当于单击文件中的打开按钮
document.execCommand("Open");
//将当前页面另存为
document.execCommand("SaveAs");
//剪贴选中的文字到剪贴板;
document.execCommand("Cut", "false" ,null);
//删除选中的文字;
document.execCommand("Delete", "false", null);
//改变选中区域的字体;
document.execCommand("FontName", "false", sFontName);
//改变选中区域的字体大小;
document.execCommand("FontSize", "false", sSize|iSize);
//设置前景颜色;
document.execCommand("ForeColor", "false", sColor);
//使绝对定位的对象可直接拖动;
document.execCommand("2D-Position", "false", "true");
//使对象定位变成绝对定位;
document.execCommand("AbsolutePosition", "false", "true");
//设置背景颜色;
document.execCommand("BackColor", "false", sColor);
//使选中区域的文字加粗;
document.execCommand("Bold", "false", null);
//复制选中的文字到剪贴板;
document.execCommand("Copy", "false", null);
//设置指定锚点为书签;
document.execCommand("CreateBookmark", "false", sAnchorName);
//将选中文本变成超连接,若第二个参数为true,会出现参数设置对话框;
document.execCommand("CreateLink", "false", sLinkURL);
//设置当前块的标签名;
document.execCommand("FormatBlock", "false", sTagName);
```

document对象execCommand通常在IE中在线处理Html数据时非常有用，它可以让你轻而易举实现文字的加粗、加颜色、加字体等一系列的命令。

- D-Position 允许通过拖曳移动绝对定位的对象。
- AbsolutePosition 设定元素的 position 属性为"absolute"（绝对）。
- BackColor 设置或获取当前选中区的背景颜色。
- BlockDirLTR 目前尚未支持。
- BlockDirRTL 目前尚未支持。
- Bold 切换当前选中区的粗体显示与否。
- BrowseMode 目前尚未支持。
- Copy 将当前选中区复制到剪贴板。
- CreateBookmark 创建一个书签锚或获取当前选中区或插入点的书签锚的名称。
- CreateLink 在当前选中区上插入超级链接，或显示一个对话框允许用户指定要为当前选中区插入的超级链接的 URL。
- Cut 将当前选中区复制到剪贴板并删除之。
- Delete 删除当前选中区。
- DirLTR 目前尚未支持。
- DirRTL 目前尚未支持。
- EditMode 目前尚未支持。
- FontName 设置或获取当前选中区的字体。
- FontSize 设置或获取当前选中区的字体大小。
- ForeColor 设置或获取当前选中区的前景（文本）颜色。
- FormatBlock 设置当前块格式化标签。
- Indent 增加选中文本的缩进。
- InlineDirLTR 目前尚未支持。
- InlineDirRTL 目前尚未支持。
- InsertButton 用按钮控件覆盖当前选中区。
- InsertFieldset 用方框覆盖当前选中区。
- InsertHorizontalRule 用水平线覆盖当前选中区。
- InsertIFrame 用内嵌框架覆盖当前选中区。
- InsertImage 用图像覆盖当前选中区。
- InsertInputButton 用按钮控件覆盖当前选中区。
- InsertInputCheckbox 用复选框控件覆盖当前选中区。
- InsertInputFileUpload 用文件上载控件覆盖当前选中区。
- InsertInputHidden 插入隐藏控件覆盖当前选中区。
- InsertInputImage 用图像控件覆盖当前选中区。
- InsertInputPassword 用密码控件覆盖当前选中区。
- InsertInputRadio 用单选钮控件覆盖当前选中区。
- InsertInputReset 用重置控件覆盖当前选中区。
- InsertInputSubmit 用提交控件覆盖当前选中区。
- InsertInputText 用文本控件覆盖当前选中区。
- InsertMarquee 用空字幕覆盖当前选中区。
- InsertOrderedList 切换当前选中区是编号列表还是常规格式化块。
- InsertParagraph 用换行覆盖当前选中区。
- InsertSelectDropdown 用下拉框控件覆盖当前选中区。
- InsertSelectListbox 用列表框控件覆盖当前选中区。
- InsertTextArea 用多行文本输入控件覆盖当前选中区。
- InsertUnorderedList 切换当前选中区是项目符号列表还是常规格式化块。
- Italic 切换当前选中区斜体显示与否。
- JustifyCenter 将当前选中区在所在格式化块置中。
- JustifyFull 目前尚未支持。
- JustifyLeft 将当前选中区所在格式化块左对齐。
- JustifyNone 目前尚未支持。
- JustifyRight 将当前选中区所在格式化块右对齐。
- LiveResize 迫使 MSHTML 编辑器在缩放或移动过程中持续更新元素外观，而不是只在移动或缩放完成后更新。
- MultipleSelection 允许当用户按住 Shift 或 Ctrl 键时一次选中多于一个站点可选元素。
- Open 目前尚未支持。
- Outdent 减少选中区所在格式化块的缩进。
- OverWrite 切换文本状态的插入和覆盖。
- Paste 用剪贴板内容覆盖当前选中区。
- PlayImage 目前尚未支持。
- Print 打开打印对话框以便用户可以打印当前页。
- Redo 目前尚未支持。
- Refresh 刷新当前文档。
- RemoveFormat 从当前选中区中删除格式化标签。
- RemoveParaFormat 目前尚未支持。
- SaveAs 将当前 Web 页面保存为文件。
- SelectAll 选中整个文档。
- SizeToControl 目前尚未支持。
- SizeToControlHeight 目前尚未支持。
- SizeToControlWidth 目前尚未支持。
- Stop 目前尚未支持。
- StopImage 目前尚未支持。
- StrikeThrough 目前尚未支持。
- Subscript 目前尚未支持。
- Superscript 目前尚未支持。
- UnBookmark 从当前选中区中删除全部书签。
- Underline 切换当前选中区的下划线显示与否。
- Undo 目前尚未支持。
- Unlink 从当前选中区中删除全部超级链接。
- Unselect 清除当前选中区的选中状态。

```html
// 最后更新时间
<script>document.lastModified</script>

// 2秒后载入指定网页
<meta http-equiv="refresh" content="2;URL=http://你的网址">

// 添加到收藏夹
<script Language="Javascript">
function bookmarkit() {
  window.external.addFavorite('http://你的网址', '你的网站名称');
}
if (document.all)
  document.write('<a href="#" onClick="bookmarkit()">加入收藏夹</a>');
</script>

// 禁止鼠标右键的动作
<script Language = "Javascript">
function click() {
  if (event.button==2 || event.button==3) {
　　alert('禁止鼠标右键');
　}
}
document.onmousedown=click
</script>
```

## 获取数组中最大值和最小值的方法汇总

```js
// 方法一：
// 最小值
if (typeof Array.prototype[min] == 'undefined') {
  Array.prototype.min = function() {
    var min = this[0];
    var len = this.length;
    for (var i = 1; i < len; i++){
      if (this[i] < min){
        min = this[i];
      }
    }
    return min;
  }
}
//最大值
if (typeof Array.prototype['max'] == 'undefined') {
  Array.prototype.max = function() {
    var max = this[0];
    var len = this.length;
    for (var i = 1; i < len; i++){
      if (this[i] > max) {
        max = this[i];
      }
    }
    return max;
  }
}

/*
方法二：
用Math.max和Math.min方法可以迅速得到结果。apply能让一个方法指定调用对象与传入参数，并且传入参数是以数组形式组织的。恰恰现在有一个方法叫Math.max，调用对象为Math，与多个参数
*/
Array.max = function(array){
  return Math.max.apply(Math, array);
};
Array.min = function(array){
  return Math.min.apply(Math, array);
};
// Math对象也是一个对象，我们用对象的字面量来写，又可以省几个比特了，直接使用null也可以
Array.max = function(array){
  return Math.max.apply({}, array);
};
Array.min = function(array){
  return Math.min.apply({}, array);
};
```

## 动态加载JS和CSS

1、直接document.write

```html
<script language="javascript">
  document.write("<script src='test.js'><\/script>");
</script>
```

2、动态改变已有script的src属性

```html
<script src='' id="s1"></script>
<script language="javascript">
  s1.src="test.js"
</script>
```

3、动态创建script元素

```html
<script>
  var oHead = document.getElementsByTagName('head').item(0);
  var oScript= document.createElement("script");
  oScript.type = "text/javascript";
  oScript.src="test.js";
  oHead.appendChild( oScript);
</script>
```

4、原理：用 `XMLHTTP` 取得脚本的内容，再创建 `Script` 对象。

>注意：a.js必须用UTF8编码保存，要不会出错。因为服务器与XML使用UTF8编码传送数据。

主页面代码：

```html
<script language="JavaScript">
function GetHttpRequest() {
  if (window.XMLHttpRequest) //Gecko
    return new XMLHttpRequest() ;
  else if (window.ActiveXObject) //IE
    return new ActiveXObject("MsXml2.XmlHttp") ;
}

function AjaxPage(sId, url){
  var oXmlHttp = GetHttpRequest();
  oXmlHttp.OnReadyStateChange = function() {
    if (oXmlHttp.readyState == 4) {
      if (oXmlHttp.status == 200 || oXmlHttp.status == 304) {
        IncludeJS(sId, url, oXmlHttp.responseText);
      } else {
        alert('XML request error: ' + oXmlHttp.statusText + ' (' + oXmlHttp.status + ')') ;
      }
    }
  }
  oXmlHttp.open('GET', url, true);
  oXmlHttp.send(null);
}

function IncludeJS(sId, fileUrl, source) {
  if (source != null && !document.getElementById(sId)){
    var oHead = document.getElementsByTagName('head').item(0);
    var oScript = document.createElement("script");
    oScript.language = "javascript";
    oScript.type = "text/javascript";
    oScript.id = sId;
    oScript.defer = true;
    oScript.text = source;
    oHead.appendChild(oScript);
  }
}

AjaxPage("srcA", "b.js");

// 动态加载css文件
function loadStyles(url) {
  var link = document.createElement("link");
  link.type = "text/css";
  link.rel = "stylesheet";
  link.href = url;
  document.getElementsByTagName("head")[0].appendChild(link);
}
// 测试
loadStyles("css/secondindex.css");

// 动态加载css脚本
function loadStyleString(cssText) {
  var style = document.createElement("style");
  style.type = "text/css";
  try{
    // firefox、safari、chrome和Opera
    style.appendChild(document.createTextNode(cssText));
  }catch(ex) {
    // IE早期的浏览器，需要使用style元素的stylesheet属性的cssText属性
    style.styleSheet.cssText = cssText;
  }
  document.getElementsByTagName("head")[0].appendChild(style);
}

// 测试
var css = "body{color:blue;}";
loadStyleString(css);
</script>
```

## 判断IE版本的HTML语句详解

我们常常会在网页的HTML里面看到形如 `[if lte IE 9]……[endif]` 的代码，表示的是限定某些浏览器版本才能执行的语句，那么这些判断语句的规则是什么呢？请看下文：

```html
<!--[if !IE]><!--> 除IE外都可识别 <!--<![endif]-->
<!--[if IE]> 所有的IE可识别 <![endif]-->
<!--[if IE 6]> 仅IE6可识别 <![endif]-->
<!--[if lt IE 6]> IE6以及IE6以下版本可识别 <![endif]-->
<!--[if gte IE 6]> IE6以及IE6以上版本可识别 <![endif]-->
<!--[if IE 7]> 仅IE7可识别 <![endif]-->
<!--[if lt IE 7]> IE7以及IE7以下版本可识别 <![endif]-->
<!--[if gte IE 7]> IE7以及IE7以上版本可识别 <![endif]-->
<!--[if IE 8]> 仅IE8可识别 <![endif]-->
<!--[if IE 9]> 仅IE9可识别 <![endif]-->
```

项目|范例|说明
-|-|-
!|[if !IE]|The NOT operator. This is placed immediately in front of the feature, operator, or subexpression to reverse the Boolean meaning of the expression.
lt|[if lt IE 5.5]|The less-than operator. Returns true if the first argument is less than the second argument.
lte|[if lte IE 6]|The less-than or equal operator. Returns true if the first argument is less than or equal to the second argument.
gt|[if gt IE 5]|The greater-than operator. Returns true if the first argument is greater than the second argument.
gte|[if gte IE 7]|The greater-than or equal operator. Returns true if the first argument is greater than or equal to the second argument.
( )|[if !(IE 7)]|Subexpression operators. Used in conjunction with boolean operators to create more complex expressions.
&|[if (gt IE 5)&(lt IE 7)]|The AND operator. Returns true if all subexpressions evaluate to true.
\||[if (IE 6)\|(IE 7)]|The OR operator. Returns true if any of the subexpressions evaluates to true.

```html
<!--[if lt IE 9]>
  加载CSS1
<!--[else]>
  加载CSS2
<![endif]-->
```

这样有效是有效，但是用HTML VALIDATOR，报错。因为这个不符合XHTML 1.1的规范。如果把ELSE语句去掉，则正确。

```html
加载CSS2
<!--[if lt IE 9]>
  加载CSS1(可以把要重写的写在这里).
<![endif]-->
```

用法：可使用如下代码检测当前IE浏览器的版本（注意：在非IE浏览器中是看不到效果的）

```html
<!––[if IE]>
  <h1>您正在使用IE浏览器</h1>
  <!––[if IE 5]>
    <h2>版本 5</h2>
  <![endif]––>
  <!––[if IE 5.0]>
    <h2>版本 5.0</h2>
  <![endif]––>
  <!––[if IE 5.5]>
    <h2>版本 5.5</h2>
  <![endif]––>
  <!––[if IE 6]>
    <h2>版本 6</h2>
  <![endif]––>
  <!––[if IE 7]>
    <h2>版本 7</h2>
  <![endif]––>
<![endif]––>
```

那如果当前的浏览器是IE，但版本比IE5还低，该怎么办呢，可以使用`<!–[if ls IE 5]>`，当然，根据条件注释只能在IE5+的环境之下，所以`<!–[if ls IE 5]>`根本不会被执行。

- lte：就是Less than or equal to的简写，也就是小于或等于的意思。
- lt：就是Less than的简写，也就是小于的意思。
- gte：就是Greater than or equal to的简写，也就是大于或等于的意思。
- gt：就是Greater than的简写，也就是大于的意思。
- !：就是不等于的意思，跟javascript里的不等于判断符相同

## 让IE6/IE7/IE8支持CSS3属性的8种方法介绍

我们都知道，IE浏览器暂不支持CSS3的一些属性。国外的工程师们，不安于此现状，他们总是尽量使用一些手段使IE浏览器也能支持CSS3属性，我觉得这些都是很有意义，很有价值的工作，可以推动整个技术领域的进步的。到目前为止，有不少可以让IE支持部分CSS3属性的工具。例如：

1. Dean Edwards的IE7.js (以及 IE8.js, IE9.js)

   这个玩意估计是试图让IE支持CSS3属性的鼻祖，还算蛮强大，就是性能开销较大，要解析很多文件脚本，给DOM添加大量的元素以及ClassName。

2. Aaron Gustafson的 eCSStender

   此方法支持@font-face, CSS3 选择器, 以及 CSS3 Backgrounds 和 Borders。

3. Drew Diller的 DD_roundies

   这是一个基于IE VML实现一些CSS3效果的。

4. Remiz Rahnas的border-radius.htc

   此方法使用htc文件，配合VML实现，缺点在于不能自动适应目标元素的位置和大小，所以不能适用于动态脚本环境。

5. Nick Fetchak的 ie-css3.htc

   关于此方法，我在前面的“让IE6/IE7/IE8浏览器支持CSS3属性”这篇文章中已经做过介绍。我是建议您看看这篇文章，倒不是ie-css3.htc这个玩意多么好，而是文中对htc文件以及VML预言做了些介绍，对于您了解IE下实现类似CSS3效果原理有所了解。

6. Keith Clark的ie-css3.js

   这是个与IE7.js类似的项目，其选择器可借助其他JavaScript库，所以其本身较小。

7. zoltandulac的cssSandpaper

   这是一个使用IE滤镜实现一些CSS3属性的方法。

8. css3pie的css3 PIE.htc

   支持：border-radius圆角 、 box-shadow 盒阴影 、 gradient渐变 、 multiple background images多背景 。

下面对第8种方法的做一下简单介绍：

- 官方网站：[http://css3pie.com/](http://css3pie.com/)

使用方法：

- 第一步：下载css3 PIE.htc 文件
- 第二步：将PIE.htc文件上传到你的网站目录中，上传到目录哪里都可以，只要你记住这个目录。
- 第三步：创建html文件，写一段css3代码，并引入PIE.htc，如下面这段：

  ```css
  #id {
       border: 1px solid #999;
       -webkit-border-radius: 10px;
       -moz-border-radius: 10px;
       border-radius: 10px;
       behavior: url(path/to/PIE.htc);
  }
  ```

>注意：.htc 文件路径是相对于html文件的路径，而不是相对于css文件。已知的一些问题：此方法并不是万能的，也有一些局限性和需要注意的地方。

1. z-index相关问题

   IE下这些CSS3效果实现是借助于VML，由VML绘制圆角或是投影效果的容器元素，然后这个容器元素作为目标元素的后兄弟节点插入，如果目标元素position:absolute 或是 position:relative，则这个css3-container元素将会设置与之一样的z-index值，在DOM tree中，同级的元素总是后面的覆盖前面的，所以这样就实现了覆盖，又避免了可能有其他元素正好插入其中。

   所以，问题来了，如果目前元素的position属性为static，也就是默认属性，则z-index属性是没有用的，无覆盖可言，所以此时IE浏览器下CSS3的渲染是不会成功的。要解决也很简单，设置目标元素position:relative或是设置祖先元素position:relative并赋予一个z-index值（不可为-1）。

2. 相当路径的问题

   IE浏览器的behavior 属性是相对于HTML文档而言的，与CSS其他的属性不一样，不是相对于CSS文档而言的。这使得使用pie.htc文件不怎么方便。如果绝对路径于根目录，则CSS文件不方便移动；如果相对路径与HTML文档，则pie.htc文件在不同HTML页面见的重用性大大降低。同时，诸如border-image后面的URL属性路径也不好处理。

3. 缩写的问题

   使用PIE实现IE下的CSS3渲染（其他方法也是一样），只能使用缩写的形式，例如圆角效果，我们可以设置border-top-left-radius表示左上圆角，但是PIE确实不支持这种写法的，只能是老老实实的缩写。

4. 提供正确的Content-Type

   要想让IE浏览器支持htc文件，需要一个有着"text/x-component" 字样的content-type 头部，否则，会忽视behavior。绝大数web服务器提供了正确的content-type，但是还有一部分则有问题。

   如果您发现在您的机子上PIE方法无效，也就是htc文件这里指pie.htc文件无效，检查您的服务器配置，可能其需要更新到最新的content-type。例如对于Apache，您可以在.htaccess文件中做如下处理：

   ```txt
   AddType text/x-component .htc
   ```

   但是，由于某种原因，您无法修改服务器配置（例如公用主机，或是空间服务商提供的服务器），您可以用一个PHP文件来间接调用htc文件。我只要给你看下这个PHP文件的代码您就知道什么意思了，如下：

   ```php
   <?php
     header( 'Content-type: text/x-component' );
     include( 'pie.htc' );
   ?>
   ```

   通过PHP文件来增加一个含有"text/x-component"字样的Content-type头，同时调用pie.htc文件。关于上面所示的php文件，您可以直接新建一个php文件，把上面的两行代码复制进去。如果您使用上述php文件，您需要将pie.php和pie.htc放在同一个文件夹目录下，同时CSS中的behavior写法应该是：`behavior: url(pie.php);`

>以上为一些常见的主要的问题，当然，在复杂的页面情况下，还会有其他意想不到的情况，这里，祝您好运了！

### window和document

The JavaScript Window object is the highest level JavaScript object which corresponds to the web browser window.

最外层的JavaScript对象其对应于web浏览器窗口

The document object is the container for all HTML HEAD and BODY objects associated within the HTML tags of an HTML document. This could correspond to the top-most window, or an iframe within the window.

文档对象是一个HTML文档的HTML标签中相关联的所有HTML头部和身体对象的容器。这可以对应于最上面的窗口，或在窗口内的iframe

After a quick test there really is no difference between the two. However, as others have said, window.onclick did not work when tested in IE8. So apparently the bottom line is that document.onclick is the preferred choice.

window.onclick 不能在IE8下工作，在低版本中 document.onclick 为首选

## object

### wbbrowser

今天用到了wbbrowser控件做页面打印，感觉非常强大。索性收集了html object标签的一些知识，整理于此供需要时查阅。

首先放出这个强大web页面打印[例子](../codes/5.1.1_print.html)。接下来我将收集到的html object控件标签罗列在此，具体应用的例子后续有时间补上。

### 地理位置

通过获取地理位置信息在地图上显示当前位置

### 历史记录管理

使用pushState()方法进行历史记录管理

### 跨域消息传递

Twitter搜索gadget，由postMessage()来控制

通过postMessage()来使用Twitter搜索gadget

### WebWorker

## 流式编程

>有时候也可以成为函数式编程。它的主要目的是在数据拉取的过程中渲染页面，即边处理数据边渲染页面。

类似概念：

- 流式应用：Rxjs
- 流式列表
- 流式处理：大数据、实时计算
- 文件处理、字节流、加密、网络

### 流式应用

![x](./Resource/流式应用.png)

RxJS本身一直试图将数据、dom等前端元素看做流处理。它的思想其实就是流式编程思想的一种。如果你使用过RxJS，你会非常快速的理解流式编程的核心理念。

但是RxJS更多的是将操作，包括http请求、dom操作等看做流的形式，在普通请求、操作的基础上封装出了一个流的上层对象。它只能算做流式编程思想的其中一部分。流式编程更加的靠前，它包含了页面结构设计、请求顺序等一些列的东西。

### 瀑布流

![x](./Resource/瀑布流.png)

开发前端的同学或多或少都会遇到瀑布流页面，哪怕没开发过也见过、研究过。

瀑布流完全是将页面（一部分）看过了一个流式页面，如果页面向下流动，页面能够自然达到的顺序就是瀑布流希望/想要达到的效果。

流式编程思想更多的是提出页面整体上的流式，而不仅仅是页面的某一部分。假如你做的瀑布流页面是完全靠`position`绝对定位实现的。很抱歉，这样的页面仅仅是实现了瀑布流，但它不属于流式编程。流式编程提倡使用正常的文档流去开发。让页面渲染能够一泻而下，通畅而不阻塞。不需要重新绘制dom树才是流式编程在页面开发上的核心要点。

### 实时计算

![x](./Resource/实时计算.png)

这里拿出实时计算就是为了让开发者能够从不同的方面去理解流式编程的思想。

不管是页面还是请求、甚至是各种操作等，将它们看做一个流，顺着网络请求的顺序，页面渲染逻辑的顺序向一点去前进。这个点就是流式编程。所有的东西都通过流式编程思想去处理，将它们混杂在一起，然后处理成一个一个单独块。这个块包含当时情况下最应该做的操作（dom、http、click等），然后打包出现在页面上。这个就是流式编程的核心思想。

### 流处理

![x](./Resource/流处理.png)

这里使用了流去举例是因为流的读写操作从概念上是非常贴合流式编程思想的。

从文件上开一个通道去获取数据，然后拿到的同时就做相应的处理，同时在处理完就将它们放出来。这个过程也就是流式编程思想在构思页面结构的时候想要做的。

### 页面结构

原始页面是嵌套的，但是去掉嵌套来看，整个页面是一个从上到下的渲染过程。在渲染的过程中如果触发页面重绘，或者是出现脱离文档流的样式，整个页面的性能就会下降。由此可见，前端结构是需要尽量流式的展示的。

从这个点出发就是流式编程中的dom结构流式编程。

![x](./Resource/liushi.png)

从页面结构设计上考虑，首屏渲染的时间把握其实就是在考验开发者的流式编程思想。让页面尽可能早的呈现第一屏的dom结构，同时尽量早的加载完成第一屏的图片等资源文件。其他会对页面渲染阻塞都要往后排。

如果使用流式编程思想重新设计页面结构，单从结构上来说，一个首屏的渲染了不起20ms就到顶了，再加上各种资源加载，这些综合下来首页的加载速度一般可以提到500ms以内。这个时间才是首页渲染应该有的时间。如果是手机上，不考虑网络差的情况甚至可以做到300ms内打开页面。

![x](./Resource/WX20190430-182707@2x.png)

从图中可以看到，一部分请求在蓝色线左边，也就是页面必须使用到的。后面的4个请求是页面加载之后用到的，这几个请求是可以后加载的。其中1个是接口，然后几个是渲染页面用到的js文件。他们的顺序就是先渲染页面框架，然后再填充下面的内容。

真正的让页面飞起来，从页面结构上开始考虑。

### 接口请求

![x](./Resource/接口请求.png)

打开页面甚至在页面什么也没有展示的时候，接口就会请求数据。从上面的截图可以看到一个页面首次打开可以请求多少接口，甚至截图中的接口请求个数都不是非常多的那种。

有的页面请求3、5个，有的请求10多个。从整体上看，大多数接口是一个顺序请求的过程。它受到页面结构的影响，过快的请求反而渲染的不是所需要的地方。

页面的请求顺序就可以看做是一个流式的过程。将需要同步渲染的接口放在一起，等待结果返回之后再展示页面。剩下的几个不需要优先渲染的往后推，通过事件触发等方式在页面渲染之后再继续执行。

>tips:有些接口可以同时异步执行，使用并行请求，将页面渲染分离，可以加速页面的呈现。tips:多次请求需要多次握手，使用http2.0可以加速这个时间。合并接口可以直接去掉多余时间。

### 优化顺序

通过上面的分析，我们可以对流式编程有一个大概的印象，一些想法思路可以总结下来：

1. 按照页面渲染顺序做开发。没必要呈现的后渲染，可以加速页面展示。避免在页面加载过程中不断重绘。
2. 多余接口后请求，优先渲染第一屏。接口请求往往意味着后面有一些逻辑需要执行，将不需要第一时间请求的接口往后放可以节省很多加载时间，就像分页加载一样加载页面，页面可以更快打开。
3. 从结构上优化。先加载的先请求，先呈现的先计算，后加载的排队来，后呈现的叠加计算。这里的排队可以类比分页加载来思考怎么实现。叠加计算更多的是在当前状态上更新新的页面。

### 单接口情况

![x](./Resource/单接口情况.png)

单接口的时候会遇到数据量大，结构复杂。页面结构也会相应的增长复杂度。面对这种一次性接收大量数据的情况下，最优先考虑是优化数据结构。将大的复杂的结构分化成合适的小的结构，这样分解之后再使用会减少很多开发过程中的麻烦。把问题前置，预先处理复杂的数据，后面用到的时候才会更合适。同时，如果数据结构还有变化，也能够及时的调整应对。

应对这种情况，我们可以从几个方面入口去优化。

1. 加速接口返回速度。这个往往比较容易。

   ![x](./Resource/WX20190430-184828@2x.png)

2. 分析页面结构，将页面分成不同侧重点的部分。比如商品详情这个页面，可以分成商品简略信息和详情2个部分。其中简略信息包含几个头图、价格、卖点等信息。详情包含规格、复杂的介绍内容。（如果有需要，价格也可以分开，将价格单独分成一个接口）

3. 数据适配。我们已经将页面分成了2个部分，这里就可以单独把第一个部分放在一个对象中做渲染。这里使用vue、react等框架会得到非常及时的渲染结果，省下了大量的dom操作时间。剩下的部分放在滑动事件中，滑动页面的时候再渲染。

   ![x](./Resource/WX20190430-185303@2x.png)

4. 异步加载。这里继续使用商品详情的例子。当用户点击或者下滑的时候需要展示商品的各种规格、宣传图等。我们可以先渲染容器，保证页面结构的统一化。然后再根据页面当前位置逐步加载需要显示的图片等资源。这里同时也会涉及到超长列表的优化。其实非常简单，就是保持容器不变，内部渲染内容在超出屏幕之后删除，保证页面上的dom数量不至于太多。

上面的几点初步展示了怎么样优化一个大数据块的页面。正在遇到这个问题的同学可以根据这个思路去思考解决方案了。

### 多接口

多接口的情况往往是需要并行的和需要并发的接口齐上阵，一不注意就造成接口阻塞。

![x](./Resource/WX20190430-185531@2x.png)

1. 首先分析出页面具有哪些不同的部分。这些不同的部分的结构要隔离开，方便做不同的逻辑处理。这里推荐组件化形式处理，可以更方便的隔离不同的逻辑结构。

   ![x](./Resource/WX20190430-185845@2x.png)

2. 接口处理。后端基于某些（不靠谱）考虑会出几种不同的接口。这个时候前端更多的是区分接口的优先级和功能域。相同功能依赖的接口同步等待。不同的功能域之间梳理加载顺序。如果发现功能域不是优先展示的，可以放在异步或者触发式功能域中。
3. 先返回的数据先渲染，后返回的数据后渲染。多种渲染使用组件分离。

>这里提到了一个功能域，这其实是一个领域的概念。一个功能域包含特定的页面结构、依赖的接口。这里可以看做一个组件，内部包含了页面结构接口请求。

### 实时+触发

这个场景更多的出现在交互比较频繁的地方。比如一个按钮可以无限次的点击，滚动的时候有一个出现隐藏的动画/结构等。

![x](./Resource/WX20190430-190818@2x.png)

1. 如果一个操作多次触发，为了保持反馈/动画的稳定性，这里是一定要做控制的。典型的解决方式就是节流函数控制。或者也可以考虑从展示逻辑上处理，实现更简单。上滑的时候出现滑动小动画，如果不懂上滑其实只需要做一次动画即可。只有上一次动画做完才会执行下一个动画。这其实也是最简单的流式思想。

   ![x](./Resource/WX20190430-190420@2x.png)

2. 如果一个页面可能会多次展示隐藏，同时内部的数据是异步获取的。这个场景下优先考虑缓存渲染结果，第一次的时候加载数据，后面在展示的时候其实一直在用一个缓存来渲染结果。从流程上看就简化为了data=>dom。

### 复杂页面

复杂的页面跟多的是上面几种的组合。只要能够识别到那些地方归属那种情况，再去优化就有一个清晰的目标了。

![x](./Resource/好东西流程.jpg)

1. 产品级分析。看到原型或者UI的时候基本就能够知道页面未来会长什么样子了。这个时候也就是一个复杂的页面最应该开始构思结构的时候。分析页面功能点，区分哪些是先展示，哪些是触发之后展示。然后设计页面结构，隔离不同展示区域。
2. 不同的结构使用不同的接口，接口之间也是分属不同的功能域。如果一个接口内容特别多，可以从逻辑上将一个接口分成好几个部门处理。尤其是要渲染很多内容的时候，分开渲染速度更快。
3. 有些结构完全可以设计到触发之后再加载。比如第二屏展示的内容，点击之后才能看到的地方等。

## 总结

流式编程将页面结构看做数据，多个数据并行展示看做一个整体。通过这样宏观的抽象整理，将页面变成了一个流动的对象。从根本上改变了开发的形态。

在实际开发中使用流式编程思想可以很容易的开发出高性能的页面。页面渲染更快，展示更合理。同时反过来加速了代码结构的进化，促进开发者思考和成长。

## DOM操作成本到底高在哪儿

作者：[palmerye](http://segmentfault.com/a/1190000014070240)

从我接触前端到现在，一直听到的一句话：操作DOM的成本很高，不要轻易去操作DOM。尤其是React、vue等MV*框架的出现，数据驱动视图的模式越发深入人心，jQuery时代提供的强大便利地操作DOM的API在前端工程里用的越来越少。刨根问底，这里说的成本，到底高在哪儿呢？

### 什么是DOM

**Document Object Model 文档对象模型：**

什么是DOM？可能很多人第一反应就是div、p、span等html标签（至少我是），但要知道，DOM是Model，是Object Model，对象模型，是为HTML(and XML)提供的API。HTML(Hyper Text Markup Language)是一种标记语言，HTML在DOM的模型标准中被视为对象，DOM只提供编程接口，却无法实际操作HTML里面的内容。但在浏览器端，前端们可以用脚本语言(JavaScript)通过DOM去操作HTML内容。

那么问题来了，只有JavaScript才能调用DOM这个API吗？答案是NO。

Python也可以访问DOM。所以DOM不是提供给Javascript的API，也不是Javascript里的API。

>PS: 实质上还存在CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构，与DOM是两个独立的数据结构。

### 浏览器渲染过程

讨论DOM操作成本，肯定要先了解该成本的来源，那么就离不开浏览器渲染。

这里暂只讨论浏览器拿到HTML之后开始解析、渲染。

1. 解析HTML，构建DOM树（这里遇到外链，此时会发起请求）
2. 解析CSS，生成CSS规则树
3. 合并DOM树和CSS规则，生成render树
4. 布局render树(Layout/reflow)，负责各元素尺寸、位置的计算
5. 绘制render树(paint)，绘制页面像素信息
6. 浏览器会将各层的信息发送给GPU，GPU将各层合成(composite)，显示在屏幕上

### 1.构建DOM树

```html
<html>
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="style.css" rel="stylesheet">
  <title>Critical Path</title>
</head>
<body>
  <p>Hello <span>web performance</span> students!</p>
  <div><img src="awesome-photo.jpg"></div>
</body>
</html>
```

无论是DOM还是CSSOM，都是要经过 Bytes → characters → tokens → nodes → objectmodel 这个过程。

![x](./Resource/80.png)

DOM树构建过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。

### 2.构建CSSOM树

上述也提到了CSSOM的构建过程，也是树的结构，在最终计算各个节点的样式时，浏览器都会先从该节点的普遍属性（比如body里设置的全局样式）开始，再去应用该节点的具体属性。还有要注意的是，每个浏览器都有自己默认的样式表，因此很多时候这棵CSSOM树只是对这张默认样式表的部分替换。

### 3.生成render树

DOM树和CSSOM树合并生成render树

![x](./Resource/81.png)

**简单描述这个过程：**

DOM树从根节点开始遍历可见节点，这里之所以强调了“可见”，是因为如果遇到设置了类似 `display:none;` 的不可见节点，在 render 过程中是会被跳过的（但 `visibility:hidden;` `opacity:0` 这种仍旧占据空间的节点不会被跳过render），保存各个节点的样式信息及其余节点的从属关系。

### 4.Layout 布局

有了各个节点的样式信息和属性，但不知道各个节点的确切位置和大小，所以要通过布局将样式信息和属性转换为实际可视窗口的相对大小和位置。

### 5.Paint 绘制

万事俱备，最后只要将确定好位置大小的各节点，通过GPU渲染到屏幕的实际像素。

Tips:

- 在上述渲染过程中，前3点可能要多次执行，比如js脚本去操作dom、更改css样式时，浏览器又要重新构建DOM、CSSOM树，重新render，重新layout、paint；
- Layout在Paint之前，因此每次Layout重新布局（reflow 回流）后都要重新触发Paint渲染，这时又要去消耗GPU；
- Paint不一定会触发Layout，比如改个颜色改个背景；（repaint 重绘）
- 图片下载完也会重新触发Layout和Paint；

![x](./Resource/82.png)

### 何时触发reflow和repaint

- reflow（回流）：根据Render Tree布局（几何属性），意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；
- repaint（重绘）：意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；
- reflow回流的成本开销要高于repaint重绘，一个节点的回流往往会导致子节点以及同级节点的回流；

GoogleChromeLabs 里面有一个csstriggers，列出了各个CSS属性对浏览器执行Layout、Paint、Composite的影响。

### 引起reflow回流

现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。

1. 页面第一次渲染（初始化）
2. DOM树变化（如：增删节点）
3. Render树变化（如：padding改变）
4. 浏览器窗口resize
5. 获取元素的某些属性：

浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括offsetLeft、offsetTop、offsetWidth、offsetHeight、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、调用了getComputedStyle()或者IE的currentStyle

### 引起repaint重绘

1. reflow回流必定引起repaint重绘，重绘可以单独触发
2. 背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）

### 优化reflow、repaint触发次数

- 避免逐个修改节点样式，尽量一次性修改
- 使用DocumentFragment将需要多次修改的DOM元素缓存，最后一次性append到真实DOM中渲染
- 可以将需要多次修改的DOM元素设置 display:none，操作完再显示。（因为隐藏元素不在render树内，因此修改隐藏元素不会触发回流重绘）
- 避免多次读取某些属性（见上）
- 将复杂的节点元素脱离文档流，降低回流成本

为什么一再强调将css放在头部，将js文件放在尾部？

### DOMContentLoaded 和 load

- DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片...
- load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成

### CSS 资源阻塞渲染

构建Render树需要DOM和CSSOM，所以HTML和CSS都会阻塞渲染。所以需要让CSS尽早加载（如：放在头部），以缩短首次渲染的时间。

### JS 资源

阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML。

这和之前文章提到的浏览器线程有关，浏览器中js引擎线程和渲染线程是互斥的，详见《从setTimeout-setInterval看JS线程》

普通的脚本会阻塞浏览器解析，加上defer或async属性，脚本就变成异步，可等到解析完毕再执行。

- async异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload前，但不确定在DOMContentLoaded事件的前后
- defer延迟执行，相对于放在body最后（理论上在DOMContentLoaded事件前）

举个栗子：

```html
<html>
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="style.css" rel="stylesheet">
</head>
<body>
  <p>Hello <span>web performance</span> students!</p>
  <div><img src="awesome-photo.jpg"></div>
  <script src="app.js"></script>
</body>
</html>
```

![x](./Resource/83.png)

- 浏览器拿到HTML后，从上到下顺序解析文档
- 此时遇到css、js外链，则同时发起请求
- 开始构建DOM树
- 这里要特别注意，由于有CSS资源，CSSOM还未构建前，会阻塞js（如果有的话）
- 无论JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒 JavaScript解析器，就会进行暂停 blocked 浏览器解析HTML，并等到 CSSOM 构建完毕，才执行js脚本
- 渲染首屏（DOMContentLoaded 触发，其实不一定是首屏，可能在js脚本执行前DOM树和CSSOM已经构建完render树，已经paint）

### 首屏优化Tips

说了这么多，其实可以总结几点浏览器首屏渲染优化的方向：

- 减少资源请求数量（内联亦或是延迟动态加载）
- 使CSS样式表尽早加载，减少@import的使用，因为需要解析完样式表中所有import的资源才会算CSS资源下载完
- 异步js：阻塞解析器的 JavaScript 会强制浏览器等待 CSSOM 并暂停 DOM 的构建，导致首次渲染的时间延迟
- so on...

知道操作DOM成本多高了吗？其实写了这么多，感觉偏题了，大量的资料参考的是chrome开发者文档。

操作DOM具体的成本，说到底是造成浏览器回流reflow和重绘reflow，从而消耗GPU资源。

参考文献：

- [谷歌开发者文档](https://developers.google.com/web/fundamentals/performance/critical-rendering-path)

## 常用功能

```txt
网页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;
网页可见区域宽： document.body.offsetWidth （包括边线的宽）
网页可见区域高： document.body.offsetHeight （包括边线的宽）
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight;
屏幕可用工作区宽度：window.screen.availWidth;

scrollHeight: 获取对象的滚动高度。  
scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离
scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离
scrollWidth:获取对象的滚动宽度
offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度
offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置
offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置  
event.clientX 相对文档的水平座标
event.clientY 相对文档的垂直座标

event.offsetX 相对容器的水平坐标
event.offsetY 相对容器的垂直坐标  
document.documentElement.scrollTop 垂直方向滚动的值
event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量
要获取当前页面的滚动条纵坐标位置，用：
document.documentElement.scrollTop;
而不是：
document.body.scrollTop;
documentElement 对应的是 html 标签，而 body 对应的是 body 标签

事件源对象
event.srcElement.tagName
event.srcElement.type

捕获释放
event.srcElement.setCapture();  
event.srcElement.releaseCapture();  

事件按键
event.keyCode
event.shiftKey
event.altKey
event.ctrlKey

事件返回值
event.returnValue

鼠标位置
event.x
event.y

窗体活动元素
document.activeElement

绑定事件
document.captureEvents(Event.KEYDOWN);

访问窗体元素
document.all("txt").focus();
document.all("txt").select();

窗体命令
document.execCommand

窗体COOKIE
document.cookie

菜单事件
document.oncontextmenu

创建元素
document.createElement("SPAN");  

根据鼠标获得元素：
document.elementFromPoint(event.x,event.y).tagName=="TD"
document.elementFromPoint(event.x,event.y).appendChild(ms)  

窗体图片
document.images[索引]

窗体事件绑定
document.onmousedown=scrollwindow;

元素
document.窗体.elements[索引]

对象绑定事件
document.all.xxx.detachEvent('onclick',a);

插件数目
navigator.plugins

取变量类型
typeof($js_libpath) == "undefined"

下拉框
下拉框.options[索引]
下拉框.options.length

查找对象
document.getElementsByName("r1");
document.getElementById(id);

定时
timer=setInterval('scrollwindow()',delay);
clearInterval(timer);

UNCODE编码
escape() ,unescape

父对象
obj.parentElement(dhtml)
obj.parentNode(dom)

交换表的行
TableID.moveRow(2,1)

替换CSS
document.all.csss.href = "a.css";

并排显示
display:inline

隐藏焦点
hidefocus=true

根据宽度换行
style="word-break:break-all"

自动刷新
<meta HTTP-EQUIV="refresh" C>

简单邮件
<a href="mailto:aaa@bbb.com?subject=ccc&body=xxxyyy">  

快速转到位置
obj.scrollIntoView(true)

锚
<a name="first">
<a href="#first">anchors</a>

网页传递参数
location.search();

可编辑
obj.contenteditable=true

执行菜单命令
obj.execCommand

双字节字符
/[^\x00-\xff]/

汉字
/[\u4e00-\u9fa5]/

让英文字符串超出表格宽度自动换行
word-wrap: break-word; word-break: break-all;

透明背景
<IFRAME src="1.htm" width=300 height=180 allowtransparency></iframe>

获得style内容
obj.style.cssText

HTML标签
document.documentElement.innerHTML

第一个style标签
document.styleSheets[0]

style标签里的第一个样式
document.styleSheets[0].rules[0]

防止点击空链接时，页面往往重置到页首端。
<a href="javascript unction()">word</a>

上一网页源
asp:
request.servervariables("HTTP_REFERER")
javascript:
document.referrer

释放内存
CollectGarbage();

禁止右键
document.oncontextmenu = function() { return false;}

禁止保存
<noscript><iframe src="*.htm"></iframe></noscript>

禁止选取
<body oncontextmenu="return false" ondragstart="return false" onselectstart ="return false" onselect="document.selection.empty()" oncopy="document.selection.empty()" onbeforecopy="return false"onmouseup="document.selection.empty()">

禁止粘贴
<input type=text>

地址栏图标
<link rel="Shortcut Icon" href="favicon.ico">
favicon.ico 名字最好不变16*16的16色,放虚拟目录根目录下

收藏栏图标
<link rel="Bookmark" href="favicon.ico">

查看源码
<input type=button value=查看网页源代码>

关闭输入法
<input style="ime-mode isabled">

自动全选
<input type=text name=text1 value="123">

ENTER键可以让光标移到下一个输入框
<input >

文本框的默认值
<input type=text value="123">

title换行
obj.title = "123 sdfs"

获得时间所代表的微秒
var n1 = new Date("2004-10-10".replace(/-/g, "\/")).getTime()

窗口是否关闭
win.closed

checkbox扁平
<input type=checkbox style="position: absolute; clip:rect(5px 15px 15px 5px)"><br>

获取选中内容
document.selection.createRange().duplicate().text

自动完成功能

<input  type=text  autocomplete=on>打开该功能  
<input  type=text  autocomplete=off>关闭该功能
窗口最大化
<body >

无关闭按钮IE
window.open("aa.htm", "meizz", "fullscreen=7");

统一编码/解码
alert(decodeURIComponent(encodeURIComponent("http://你好.com?as= hehe")))
encodeURIComponent对":"、"/"、";" 和 "?"也编码
```

### 阻止冒泡和默认行为

```js
function stopBubble(e) {
  // 如果提供了事件对象，则这是一个非IE浏览器
  if (e && e.stopPropagation)
    //因此它支持W3C的stopPropagation()方法
    e.stopPropagation();
  else
    //否则，我们需要使用IE的方式来取消事件冒泡
    window.event.cancelBubble = true;
}

// 阻止浏览器的默认行为
function stopDefault( e ) {
  //阻止默认浏览器动作(W3C)
    if (e && e.preventDefault)
      e.preventDefault();
      // IE中阻止函数器默认动作的方式
    else
      window.event.returnValue = false;
    return false;
}
```
