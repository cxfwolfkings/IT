# 微服务

## 目录

1. 理论

   - [微服务思想](#微服务思想)
   - [如何高效推进微服务架构演进](#如何高效推进微服务架构演进)

2. 实战

   - [微服务项目示例](#微服务项目示例)

     - [API网关](#API网关)

     - [服务注册中心](#服务注册中心)

     - [数据库集群](#数据库集群)

   - [.NET平台微服务项目汇集](#.NET平台微服务项目汇集)

   - [微服务化实战案例分析](#微服务化实战案例分析)

   - [基础设施服务的微服务化](#基础设施服务的微服务化)

3. 总结
4. 升华



## 理论

***\*微服务架构\****

  微服务是指开发一个单个小型的但有业务功能的服务，每个服务都有自己的处理和轻量通讯机制，可以部署在单个或多个服务器上。微服务也指一种种松耦合的、有一定的有界上下文的面向服务架构。也就是说，如果每个服务都要同时修改，那么它们就不是微服务，因为它们紧耦合在一起；如果你需要掌握一个服务太多的上下文场景使用条件，那么它就是一个有上下文边界的服务，这个定义来自DDD领域驱动设计。

  相对于单体架构和SOA，它的主要特点是组件化、松耦合、自治、去中心化，体现在以下几个方面：

· 一组小的服务 
服务粒度要小，而每个服务是针对一个单一职责的业务能力的封装，专注做好一件事情。

· 独立部署运行和扩展 
每个服务能够独立被部署并运行在一个进程内。这种运行和部署方式能够赋予系统灵活的代码组织方式和发布节奏，使得快速交付和应对变化成为可能。

· 独立开发和演化 
技术选型灵活，不受遗留系统技术约束。合适的业务问题选择合适的技术可以独立演化。服务与服务之间采取与语言无关的API进行集成。相对单体架构，微服务架构是更面向业务创新的一种架构模式。

· 独立团队和自治 
团队对服务的整个生命周期负责，工作在独立的上下文中，自己决策自己治理，而不需要统一的指挥中心。团队和团队之间通过松散的社区部落进行衔接。

  我们可以看到整个微服务的思想就如我们现在面对信息爆炸、知识爆炸是一样的：通过解耦我们所做的事情，分而治之以减少不必要的损耗，使得整个复杂的系统和组织能够快速的应对变化。

  我们为什么采用微服务呢？

  “让我们的系统尽可能快地响应变化” - Rebecca Parson 

  让我们的系统尽可能快地去响应变化。其实几十年来我们一直在尝试解决这个问题。如果一定要在前面加个限制的话，那就是低成本的快速响应变化。上世纪90年代Kent Beck提出要拥抱变化，在同期出现了诸多轻量级开发方法（诸如 XP、Scrum）；2001年敏捷宣言诞生，之后又出现了精益、看板等新的管理方式。如果说，这些是为了尽快的响应变化，在软件开发流程和实践方面提出的解决方案，那么微服务架构就是在软件技术和架构层面提出的应对之道。

***\*Autonomous\**** 
  A Microservice is a unit of functionality; it provides an API for a set of capabilities oriented around a business domain or common utility

***\*Isolated\**** 
  A Microservice is a unit of deployment; it can be modified, tested and deployed as a unit without impacting other areas of a solution

***\*Elastic\**** 
  A Microservice is stateless; it can be horizontally scaled up and down as needed

***\*Resilient\**** 
  A Microservice is designed for failure; it is fault tolerant and highly available

***\*Responsive\**** 
  A Microservice responds to requests in a reasonable amount of time

***\*Intelligent\**** 
  The intelligence in a system is found in the Microservice endpoints not ‘on the wire’

***\*Message Oriented\**** 
  Microservices rely on HTTP or a lightweight message bus to establish a boundary between components; this ensures loose coupling, isolation, location transparency, and provides the means to delegate errors as messages

***\*Programmable\**** 
  Microservices provide API's for access by developers and administrators

***\*Composable\**** 
  Applications are composed from multiple Microservices

***\*Automated\**** 
  The lifecycle of a Microservice is managed through automation that includes development, build, test, staging, production and distribution



## 微服务思想

## 微服务项目示例

- 微服务的注册和发现：集成诸如Zookeeper之类的服务
- 微服务的部署和弹性伸缩：docker + Kubernetes
- 微服务间的通讯：RPC
- 微服务间通讯的效率：高
- 微服务间的事务性（ACID）：CAP或异步通讯+人工处理
- 微服务的对外网关、限流熔断：nginx/Kubernetes/IIS/自己轻量包装
- 微服务的全局配置：Apollo等类似相关配置中心
- 微服务的认证授权（OAuth2）：IdentityServer
- 微服务间的异步通讯、消息：RabbitMq等类似组件
- 微服务的日志：三方组件/自研
- 微服务的监控：CAT、 KariosDB三方集成

### 数据库集群

**MySQL Cluster VS MyCat：**

MYSQL集群方案有挺多的，主从读写分离是最容易实现的，但是会很快碰到主服务器写入瓶颈的问题，sharding方案才是未来可扩展的解决方案。目前我觉得有两个方案较为靠谱：

1. MYSQL CLUSTER，这个是MYSQL的官方集群方案，直接在数据库级别支持ndb网络节点，自动分片，自动join，单机故障不影响集群；
2. MYCAT，这个是基于阿里巴巴的Cobar方案优化而来，其支持团队也挺卖力的，支持半自动化分片、join。为什么叫“半自动化”呢？因为需要DBA对每个表的分片策略进行配置和干涉。个人感觉没有方案1的傻瓜式分片简单。

MySQL Cluster 是一个基于 NDB Cluster 存储引擎的完整的分布式数据库系统；不仅仅具有高可用性，而且可以自动切分数据，冗余数据等高级功能；MySQL Cluster 是一个 Share Nothing 的架构，各个 MySQLServer 之间并不共享任何数据。

**背景：**

各种宕机原因：

- 运行环境（35%）：磁盘空间耗尽 / 网络
- 性能问题（35%）：糟糕的SQL / 服务器bug
- 复制问题（20%）：主备数据不一致
- 数据丢失损坏（10%）：DROP TABLE / 缺少可用备份

实现高可用：

- 提升平均失效时间（MTBF）：做好管理，防止故障发生
- 降低平均恢复时间（MTTR）：建立冗余，避免单点失效，故障转移

**Cluster 组成：**

- **SQL服务节点**（SQL层）：MySQL Server，不需要提供任何存储引擎的MySQL服务器，实现一个数据库在存储层之上的所有事情
- **NDB数据节点**（Storage层）：实现底层数据存储功能，每一个 Cluster 节点保存完整数据的一个 fragment，NDB 节点被组织成一个一个的 NDB Group，一个 NDB Group 实际上就是一组存有完全相同的物理数据的 NDB 节点群
- **Manage节点**：管理整个 Cluster 集群中各个节点，包括集群配置、控制节点、维护、数据恢复

![x](./Resource/Cluster.png)

**Mysql-cluster的优缺点：**

优点：

1. 99.999 ％的高可用性
2. 快速的自动失效切换
3. 灵活的分布式体系结构，没有单点故障
4. 高吞吐量和低延迟
5. 可扩展性强，支持在线扩容

缺点：

1. 存在很多限制，比如：不支持外键，数据行不能超过8K（不包括BLOB和text中的数据）
2. 部署、管理、配置很复杂
3. 占用磁盘空间大，内存大
4. 备份和恢复不方便
5. 重启的时候，数据节点将数据load到内存需要很长时间

**Cluster 优化：**

- 节点之间的内部网络带宽要保证足够使用；
- SQL节点和NDB节点的主机性能配比要均衡，不能一方出现瓶颈，一方处于空闲；
- 优化SQL节点和NDB节点的软件配置；

**小结：**

MySQL Cluster 的核心在于 NDB Cluster 存储引擎，他不仅对数据进行了水平切分，还对数据进行了跨节点冗余。既解决了数据库的扩展问题，同时也在很大程度上提高了数据库整体可用性。

但是 CLUSTER 数据都是放在内存里的，硬件不便宜，而且实时同步依靠的是超大的网络带宽。生产环境没有听说过的案例。

### eShopOnContainers

开发环境的 eShopOnContainers 参考应用程序体系结构：

![x](./Resource/eshoponcontainers-reference-application-architecture.png)

一些可用于不同微服务的方法和技术（多体系结构模式和 polyglot 微服务体系）：

![x](./Resource/multi-architectural-patterns-polyglot-microservices.png)

## .NET平台微服务项目汇集

最近博客园出现了一篇文章[《微服务时代之2017年五军之战：Net PHP谁先死》](http://www.cnblogs.com/vesaa/p/7416866.html)，掀起了一波撕逼，作者只是从一个使用者的角度来指点江山，这个姿势是不对的。.NET Core 就是专门针对模块化的微服务架构而设计，在微服务架构这方面 Java 的 Spring Cloud 具有非常高的人气，这个正是这篇文章作者的立脚点。然后他没有看到蓬勃发展的 .NET 社区的微服务的相关框架,本文主要梳理下当前 .NET 社区微服务的相关项目的汇集。

1、Service Fabric

微软作为 .NET 的主战场，自然在当前的微服务框架上有着丰富的经验，这一领域的代表作就是 Azure Service Fabric，在 Azure 上的众多云服务都是基于 Servie Fabric 构建，而且微软已经明确表态了 Service Fabric 将开源，Runtime 还没开源，说有计划开源，但目前因为依赖于很多内部工具、组件，在逐步推进 runtime 的开源进程，具体可以看下我写的一篇博客《期待微软平台即服务技术 Service Fabric 开源》。如果你是基于 Azure 平台来开发，你完全可以使用 Service Fabric 做应用开发。当然你如果是在你私有云里用他，也是完全可以的，具体案例我举一个就是腾讯游戏：[https://customers.microsoft.com/en-us/story/tencent-telecommunications-azure-service-fabric-windows-server-en](https://customers.microsoft.com/en-us/story/tencent-telecommunications-azure-service-fabric-windows-server-en)

这里列出 1 个 Github 以 Service Fabric 开发微服务的项目：[https://github.com/danielmarbach/Microservices.ServiceFabric](https://github.com/danielmarbach/Microservices.ServiceFabric)

2、Steeltoe OSS

在微服务架构这方面 Spring Cloud 具有非常高的人气，如果你在使用 Spring Cloud，可以使用开源项目 [https://github.com/steeltoeoss](https://github.com/steeltoeoss) 开发 .NET Core 应用，具体可以参考这篇文章Enabling .NET Core Microservices with Steeltoe and Pivotal Cloud Foundry

3、Microdot Framework

[https://github.com/gigya/microdot](https://github.com/gigya/microdot)，这是一个 4 月份才开源的 .NET 微服务框架，让您专注于编写定义服务逻辑的代码，无需解决开发分布式系统的无数挑战，可以很好的 Microsoft Orleans 的集成。

4、.NET China Foundation

.NET China Foundation 也组织整合了系列国内社区开源项目，里面有多个项目都是以微服务为方向，欢迎大家加入一起来把 .NET Core 的微服务玩好。

- [https://github.com/dotnetcore/CAP](https://github.com/dotnetcore/CAP)
- [https://github.com/dotnetcore/surging](https://github.com/dotnetcore/surging)
- [https://github.com/dotnetcore/Util](https://github.com/dotnetcore/Util)

5、其他众多开源的微服务架构项目

.NET 社区里还有很多微服务的项目，下面我就简要列出他们在 Github 上的地址：

- Xigadee
  
  [https://github.com/xigadee/Microservice](https://github.com/xigadee/Microservice)

- Apworks framework

  [https://github.com/daxnet/apworks-core](https://github.com/daxnet/apworks-core)  
  [https://github.com/daxnet/apworks-examples](https://github.com/daxnet/apworks-examples)

- Cronus

  [https://github.com/Elders/Cronus](https://github.com/Elders/Cronus)

- NancyFx

  [https://github.com/Cimpress-MCP/Cimpress.Nancy](https://github.com/Cimpress-MCP/Cimpress.Nancy)

- GRPC

  [https://github.com/pchalamet/GrpcConsul](https://github.com/pchalamet/GrpcConsul)

6、API 网关 [Ocelot](https://github.com/TomPallister/Ocelot)

Ocelot 是一个使用 .NET Core 平台上的一个 API Gateway，这个项目的目标是在 .NET 上面运行微服务架构，我在年初基于 Ocelot 做了一个 POC 项目：[https://github.com/geffzhang/NanoFabric](https://github.com/geffzhang/NanoFabric)，目前已经上线运行。同时也在不断的丰富 Ocelot 的功能。

简要的列了一下 .NET 平台上的微服务开发的相关类库，欢迎大家推荐你用过的微服务的相关类库，在最后推荐一个 .NET 上归属与 .NET 基金会下面的开源项目：[https://dotnetfoundation.org/projects?type=project](https://dotnetfoundation.org/projects?type=project)，这里可以找到你想要的项目。

## 如何高效推进微服务架构演进

为什么微服务实施那么难？如何高效推进微服务架构演进？

原文：[https://gitbook.cn/books/59870d65d115e231bf3e3f5f/index.html](https://gitbook.cn/books/59870d65d115e231bf3e3f5f/index.html)

### 前言

笔者从 2013 年加入 ThoughtWorks 至今共 4年时间。在这 4 年的时间里，我分别以 开发人员，DevOps 工程师、DevOps 咨询师、微服务架构师以及微服务咨询师的角色参与了共计 7 个产品和项目的微服务咨询和实施。其中有成功，有失败，有反思，更多的是学习和总结。以下是我这些年来在微服务咨询上的经验总结，希望能给陷入微服务实施困境的人带来一些帮助。

**难点1**：“一步到位”的认知错觉

这些年微服务大红大紫，但是真正能够拿出来做为可实践的案例少之又少。大部分的微服务案例只能看到微服务架构的“演进结果”，但是看不到微服务架构的“演进过程”。这就像每个人看到一个架构的高峰，却没有看到攀登高峰的路径。

这就给很多架构师一个假象：微服务的架构是通过能力极高的架构师一步到位设计出来的。

这和很多团队自上而下的架构设计感受很相似。于是架构师们蜂拥而至，各种分析方法论层出不穷，讨论和分享络绎不绝。然而真正落地实施的却很少，使得微服务在网络上慢慢变成了一种“玄学”：微服务的实施在“理论研究”的阶段。

这违反了软件架构的最基本规律：架构是解决当前的需求和痛点演进的，而无法对没有出现的问题和痛点进行设计。因此，一步到位的整体的微服务架构设计完全没有必要。况且一个集中化的设计，很难体现微服务的轻量级优势。

我相信技术的发展一定是向不断降低成本的方向上发展的。如果新技术没有降低成本反而提升了成本，要么这个新技术有问题，要么一定是姿势不对，走错了路。

因此，准备实施微服务一定要有一个长期的思想准备。不过跨过了最初的门槛之后，剩下的工作可以被复制而且速度会越来越快。

**难点2**：“架构师精英主义”

很多产品对架构师的依赖很大，即“架构师精英主义”：认为产品架构只有这个组织的“技术精英”——架构师才可以完成，而团队其它成员只需要实现架构师的设计就可以。这是大型企业和大型系统的常见问题，这来源于长期的重量级企业级架构习惯。

而微服务则类似于一种“敏捷边际革命”：即由一个不超过2~8个人的小团队就可以完成的功能。而且这种规模的团队即使从整个产品团队移除也对整体产品的研发进度没有影响。因此，即使失败了不会带来太多的损失。不过，当第一个微服务改造成功，那么成功经验的复制带来的乘数效应却能带来很大的收益。

从架构改造投资的风险收益比来看，这是非常划算的。

因此，微服务团队完全没必要大张旗鼓，只需要两三个人就可以动工。但是，谁也没有微服务的实践经验啊，万一失败了怎么办？

这就带来了下一个难点。

**难点3**：缺乏一个信任并鼓励创新的环境

面对未知的领域，失败再所难免。而面对这个不确定性频发的世界，成功和失败往往不再重要：也许今天的失败，明天再看就是成功，反之亦然。

成功意味只是表明结果符合自己的假设预期，而失败仅仅意味着结果不符合自己的假设预期。但是无论成败，我们都能从行动的过程中有所学习和反思，而这样的经验才是研发活动中最有价值的。

然而，很多组织，尤其“精英主义”的产品团队，责任和压力往往从上至下分解。由于组织庞大，金字塔的结构往往会构建一种以“不信任”为基础的制度。这种制度往往营造了一种“宁可不作为，也不能犯错”的文化。由于上层则需要对失败负责，使得任何创新只是一个停留在组织上层的想法，难以落实推进。在这种情况下，组织的长期合作形成了稳定的工作习惯和思维定势，并形成了利益平衡，这会使得整个组织在面对创新的时候“卡壳”。

当微服务以一种政治任务从上而下派发的时候，为了避免失败，团队内部会相互推诿。通过不断的分析讨论和设计来论证这个事情的难度。在我看来，只要想搞，就一定能找到办法，而不是先设想出一堆还没有遇到的问题和责任。在行进中解决问题是比设计和讨论更加有效率的方法。

而组织解决“卡壳”的办法就是引入“背锅侠”：例如新聘请的架构师或外部咨询师，来完成这个事情。出了问题就不用自己来承担责任了。这样虽然是解决问题的一种折中办法，但可以让事情毫无风险的执行下去。但这是一种短期效应，无法解决组织本身的创新窘境，长期依赖外部力量来解决最有价值的问题不会让自己提升，反而形成了对外部力量的依赖。对于组织的凝聚力来说不是一件好事。

只有打破当前的工作习惯和思维定势，充分认识到创新的困难、风险以及价值的组织才可以占领创新的高点，吸引人才。

**难点4**：微服务技术栈的“选择困难症“

由于“精英主义”的架构师需要担负很大的责任并承担着很重的压力。他们必须要为微服务架构谨慎的选择技术栈。因此会在不同的技术栈之间不断尝试。对于习惯了在大型研发组织里“精心设计，加班生产”的架构师而言。“长设计，慢反馈”节奏似乎是理所应当的。

微服务开源社区的快速发展滋长了“架构师焦虑”：如果采用落后的技术会被同行鄙视，被不懂技术的老板鄙视，甚至被下属鄙视。因此架构师们疲于在各种新型的技术栈之间比较和学习。此外，不熟悉技术往往会增大风险，架构师就需要更多的时间研究。带着“一步到位”的架构幻想对微服务技术栈精挑细选。而不会采用现有低成本的方案快速迭代的解决问题。

微服务的核心在于采用“小规模，快反馈”的机制降低软件系统的复杂性并通过虚拟和自动化技术分散风险，从而可以快速面对市场变化带来的各种挑战，并能够快速销售创新，获得市场的反馈。而不仅仅是利用到了时下新兴的语言，编程框架或工具。

学习和实践是相辅相成的过程，在实践的时候学习，并把学习到的知识应用到实践中。而不是准备一场考试，先停下来学习，准备好了再全力以赴。

以上四点会让大型组织面对微服务实施的时候“卡壳”，而这往往会导致微服务实施容易忽略的最重要一点，我认为也是核心的一点：

**难点5**：对微服务的技术变革估计过高，而对微服务带来的组织变革估计严重不足

作为架构师，永远不要低估康威定理的威力：<b style="color:green">设计系统的组织，其产生的设计和架构等价于组织间的沟通结构。</b>

从制度经济学角度上讲，软件产品本身就是企业内部组织（员工）和外部组织（用户）沟通制度的计算机程序表达。这个制度的发展一定是在不断缩小内部组织之间以及内外部组织沟通成本的。

因此，系统的架构一定是和组织的架构相吻合的，如果不吻合，势必会带来问题阻碍组织的渐进。

这就引出了一个推论：<b style="color:green">如果企业组织的架构不是唯一的，那么微服务的架构方案也不是唯一的。</b>

当架构和组织结构相一致的时候，一切都会很顺畅。反之，就会出现各种问题。

这个关系就像鞋和脚的关系，只有穿上合适的鞋，走起路来才会舒服。过大过小的鞋都不会让你加快前进的步伐。当然，你可以选择买鞋（引入产品），虽然并不是很合脚，但还可以凑合穿。但是在换鞋的时候你不得不停下来试。你也可以花高价为自己定制一套，只不过，这个不会让你走得更快，只会越来越合脚。

如果所有人穿上了新鞋，都能跑得很快。那么这就不是鞋的问题，而是你脚的问题，这就不是换鞋能解决的了。你得先把脚的问题解决了，然后再看鞋的问题。当然，也可以通过鞋来矫正脚，只不过会花些功夫，但一定会比不停的换鞋更加有效。

很不幸，大多数的组织并没有准备好迎接微服务架构带来的组织变化。仍然把 “系统架构问题” 和 “组织问题” 割裂成两个不同领域的问题：微服务是技术问题，组织问题是管理问题。

有竞争力的组织，是一个通过融合优势达到 1 + 1 > 2 的组织。而不是把优势割裂开，得到 1 + 1 <= 2 的组织。因此，技术问题和管理问题并不是两个问题，而是同一个问题的两个侧面。

因此，如果你的组织结构是去中心化的小团队结构，那么不用担心，你的应用架构会朝组织架构的方向演进。反之，如果你不是一个去中心化的小团队结构，那么微服务的架构会和组织架构格格不入。

### 那么，如何高效的推动微服务架构演进呢？😄

如果以上 5 点都让你膝盖中箭。那么根据我个人的经验，综合解决微服务实施难点的第一步就是：

**步骤1**：以终为始，先构建一个独立的敏捷微服务团队

我们对微服务的期待就是：可以独立开发，独立部署，独立发布，并且去中心化管理。那么，我们就先构造一只“可以独立开发，独立部署，并且去中心化管理”的团队。

这个团队为了达到这个目标，会采取各种方法（例如：DevOps，全功能团队）解决阻碍独立开发，独立部署，独立发布 和 去中心化的问题。而根据康威定理，系统的架构会慢慢向去中心化方向发展。

一定要意识到，这个过程会打破大型系统自上而下的既有流程并采用更有生产力的方式构建新的组织结构。你所要做的就是要充分信任团队，把它看做是一个微型的技术管理创新。不要用老的方式控制团队的运作，这会打击团队的士气。

管理建议：

1. 让微服务团队完全脱离之前的工作，专心于微服务的工作中。如果分心同时做几件事，每件事都不会做到最好。
2. 给微服务团队一些特权，为了满足“全功能微服务团队的”诉求，特事特办。
3. 如果团队在执行的过程出现了依赖从而阻碍了进度。则需要把依赖标明出来。代码中的依赖容易看见，但组织中的流程依赖很难发现。
4. 为了避免团队对外部的“依赖惯性”，让团队自己想办法在内部解决依赖。
5. 组织流程的改变也是很重要的微服务架构产物，而不仅仅是微服务代码或基础设施。

技术建议：

1. 为微服务建立一个全新的代码库，而不要从原先的代码库上克隆或者复制，避免和原团队的开发依赖。
2. 建设一个独立的持续交付流水线，最好是通过“流水线即代码技术”（例如 Jenkinsfile）来自动生成流水线。

**步骤2**：构建微服务的“电梯演讲”

成立了微服务团队之后，接下来就是要选择第一个实现的微服务。但是这个微服务应该多大，边界在哪是个问题。这不需要进行严格的设计和反复的论证，只要发现当前的痛点或者想要完成一个假设就足够上路了。让整个过程变轻，而不是变重。

我的建议是通过“微服务电梯演讲”的方式来定义微服务。格式可以是：

```txt
（XX微服务）用来
在（出现痛点的场景）的情况下
解决了（解决现有的某个问题）
从而（达到什么样的效果）
提升了（微服务的价值）
```

例如：

```txt
（订单查询微服务）用来
在（订单查询数量快速）的情况下
解决了（访问数量迅速升高导致整体应用性能下降的问题）
从而（分离了订单查询请求）
提升了（提升了其他功能的性能）
```

当构造了微服务的电梯演讲，团队就可以以此为原则启动了。当碰到和现有系统冲突的问题，替换几个词比较有帮助你做决策。（语言一定程度上也是具有魔力的）

把 “拆分” 换成 “移除”。例如：“从现有系统中拆分出订单查询功能” 转变为 “从现有系统中移除订单查询功能”。思维方式就从一个团队负责两个系统变成了两个团队负责两个系统。

把 “集成” 换成 “调用”。例如：“用户注册和用户登录需要集成” 转变为 “用户登录服务需要调用用户注册服务的信息”。思维方式就把两个系统的关系更精确了，从而明确了微服务之间的关系和沟通方式。

管理建议：

1. 把微服务的电梯演讲打印出来挂到墙上，让团队成员铭记于心。这会强化组织对微服务的边界认识。
2. 随着团队的反思和学习，电梯演讲有可能会变更，但一定要让团队形成共识好和一致的意见。
3. 不要期望一次就能划分正确。划分是一个持续权衡取舍的过程。

技术建议：

1. 明确了微服务的职责和边界之后再去看代码，否则会被代码的复杂度影响。
2. 领域驱动设计（DDD）可以帮助你更好的划分微服务。领域驱动设计很好的遵循了 “关注点分离”（Separation of concerns，SOC）的原则，提出了更成熟、清晰的分层架构。
3. 不会领域驱动设计（DDD）也没有关系。简单的使用 “关注点分离原则” 也可以帮你达到这一点。例如：从接口中分离出流量较大的接口独立部署，把读数据库和写数据库的 API 分开独立部署，把静态和动态访问分离……等等。

**步骤3**：以最小的代价发布出第一个微服务

要注意两个关键点：一个是 “最小的代价”，另一个是 “发布”（Release）。

正如前文所述，微服务架构本身就决定了微服务一定是低成本低风险的渐进式演进。而最大的浪费在于：

1. 级别/职责分工明确的组织沟通结构。
2. “长时间，慢反馈” 的行动习惯。
3. 先进且学习成本较高的技术栈。

因此，“最小的代价” 包含了以下三个方面：

1. 最精简的独立敏捷全功能团队。
2. 最快的时间。
3. 代价最小的技术栈。

此外，很多微服务的 “爱好者” 由于害怕失败，因此将微服务技术始终放在 “实验室” 里。要勇于面对失败，在生产环境中面对真实的问题，但要采取一些规避风险的措施。

管理建议：

1. 尽量让现有微服务团队自己学习解决问题，成为全功能团队。如无必要，绝不增添新的人手。
2. “扯破嗓子不如甩开膀子”，先动起来，在前进中解决问题。
3. 先考虑最后如何发布，根据发布流程倒推。

技术建议：

1. 根据当前技术采用的情况选择代价较小的技术栈。
2. 采用动态特性开关（Feature Toggle），在发布后可以在生产环境动态的控制微服务的启用，降低失败风险。
3. 如果采用了特性开关，一定要设立删除特性开关和对应旧代码的时间，一般不超过两个月。否则后面大量的特性开关会带来管理成本的提升和代码的凌乱。
4. 由于团队比较小，功能比较单一，不建议采用分支来构建微服务，而应该采用单主干方式开发。

**步骤4**：取得快速胜利（Quick wins），演示（Showcase）驱动开发

刚开始进行微服务改造的时候一定会是一个试错的过程。如果目标定得太大，会让团队倍感压力，从而士气低落。而制定每日的短期目标，赢得快速胜利则会不断激励团队的士气。通过设定当天结束的产出来确定今天需要做什么是一个非常有效的办法。

每日演示（Daily Showcase）就是一种推进产出的做法。每天向团队分享今天的工作内容，使小组能够共同学习。并且以当天或者明天的 showcase 作为目标。每个人showcase 的内容一般不超过20分钟，一天的 showcase 时间不超过一小时。可以早上 showcase，也可以下班后 showcase。

常见的快速胜利目标如下：

1. 构造第一条微服务流水线。
2. 上线第一个微服务 HelloWorld。
3. 构造出第一个微服务自动化测试。

而以下的目标不适合作为快速胜利的目标：

1. 构造出微服务 DevOps 平台。
2. 完成整个产品的微服务架构拆分。
3. 构造微服务自动化运维体系。

管理建议：

1. 要防止团队画大饼，完成好每日和每周的工作目标即可。微服务开发本身就没有很长周期。
2. 强迫团队有所产出，这样才能用关键产出驱动开发。产出不一定是代码或者基础设施，一篇总结，或者学习的文章分享，甚至是踩过的坑和遇到的问题都可以展示，目的是要打造自治学习的团队。
3. 贵在坚持，不要计划太远。超过一个月，就要对目标是不是范围过大进行反思。
4. 以天为单位拆分任务，超过一天的必须要拆分。无法在一天完成的工作需要拆分出阶段性产出。
5. 如果能结对，并且能够每天交换结对，showcase 不必要。
6. 可视化所有任务，用敏捷看板来管理任务是了解现状的最好方式。

技术建议：

1. 除了让第一个 HelloWord 微服务尽快发布到生产环境，其它的不要想太多。
2. 完成了 HelloWord 的发布，然后要考虑如何对发布流程进行改进。而不是上线业务。

**步骤5**：代码未动，DevOps 先行

微服务解耦的本质是把代码内部的复杂性通过一些工具转化外部复杂性。把代码内部的复杂性分散到各个微服务中以降低整体复杂性和架构风险。在这个过程中会大量采用了 DevOps 技术和工具。也可以说，微服务是 DevOps 文化和技术在走到极致的必然结果。

以 J2EE 的应用为例，以前Web Server + App Server + MiddleWare + Database 的传统架构被代码更少，更多的基础设施工具所取代。因为基础设施相对于代码来说更加稳定，更加利于扩展。

我把微服务的技术架构问题比作 “搭台唱戏”：首先需要建立好微服务交付和运行的平台，然后让微服务上台 “唱戏”。

这个平台一开始不需要很完善，只需要满足生产上线的必要要求即可。而在很多企业里，这个部分是由 Ops 团队在交付流程的末尾把关的。因此，把最后一道关卡的确认工作放到最前面考虑可以减少后期的返工以及不必要的浪费。

以前，软件的开发和测试过程是分开的。然而，随着 DevOps 运动的兴起和各种自动化运维工具的兴起，这之间的必要性不如从前，只要有足够的自动化测试做质量保证，就可以很快的将微服务快速部署和发布到生产环境上。

最开始的时候，哪怕是发布一个 Hello World 程序，都表明微服务的持续交付和运行的平台已经搭建好，微服务交付流程已经打通，这一点是重中之重。

从技术交付产物来说，DevOps 主要交付两点：

1. 持续交付流水线。
2. 微服务运行平台。

为了保证微服务交付的高效，需要把这二者通过自动化的方式有机的结合起来，而不是各为其主。让开发和运维的矛盾变成“自动化的开发运维矛盾”

此外，DevOps 指的不光是一系列技术，更是一种工作方式。从团队工作方式来说，DevOps 要做到：

1. 要让 Dev 和 Ops 共同参与决策，设计，实现和维护。
2. 团队完全独立自主，打破对现有流程的依赖。
3. 不断的追求改进，让团队行程改进的团队文化。

管理建议：

1. 给团队继续前进最大的动力就是新程序快速投入生产。
2. 如果你的组织是 Dev 和 Ops 分离的组织，先咨询一下 Ops 工程师的意见。最好是能够给微服务团队里面配备一名 Ops 工程师。
3. 如果不具备实施 DevOps 的条件，微服务架构就要从运维侧，而不是开发侧开始进行。

技术建议：

1. 微服务的平台一开始可以很简单，可以以后慢慢增强和扩展。但是一定要部署到生产环境里使用。
2. 如果想使用现成的微服务平台可以参考 Spring Cloud。
3. 微服务运行平台可以通过反向代理和生产环境并行运行。
4. 采用灰度发布技术在生产环境中逐步提升微服务的使用占比。
5. 基础设施即代码是 DevOps 核心实践，可以帮助开发人员迅速在本机构建生产环境相似的开发环境，减少环境的不一致性。可以采用 Docker，Ansible，Vagrant 等工具来完成。
6. 基础设施对微服务应该是透明的。微服务不应该也没必要知道运行环境的细节。只要能够正常启动并执行业务就完成了它的任务。因此，基础设施代码要和微服务业务代码分开，且微服务不应该告诉平台自己如何部署。
7. 服务注册和发现是微服务架构的核心部分。consul 和 Eureka 是这方面的佼佼者。
8. 部署（Deploy）和发布（Release）要分开。

**步骤6**：除了提交代码和发布，微服务平台一切都应当自动化

在完成了微服务的基础设施和交付流程之后，就可以开始实现微服务的业务了。这时候需要依据电梯演讲划分出来的微服务进行业务逻辑的开发。在以 DevOps 的方式工作一段时间之后，团队应该养成了一些自动化的习惯，如果没有，就应该检查一下自己的自动化程度。最佳的自动糊理想的状态就是除了代码提交和发布。在这之间的每一个流程和环节都应当由自动化的手段来完成。

当然，也有不能自动化的部分。根据我的经验，不能自动化的原因主要来自于流程管理的制度要求，而非技术困难。这往往是组织没有依据微服务进行流程变革导致的。这时候需要检讨不能自动化的部分是不是有存在的必要。

另一方面，虽然自动化可以大量缩短微服务交付时间，提升微服务交付效率。但是自动化的同时需要考虑到安全因素和风险，不能顾此失彼。对于生产来说，可用性和安全性是最重要的部分。

关键的自动化：

- 自动化功能性测试（UI/集成/单元/回归）
- 自动化构建
- 自动化部署
- 自动化性能测试
- 自动化安全扫描

管理建议：

1. 鼓励团队成员自发的进行自动化的改进，这会给未来微服务批量开发带来很多裨益。
2. 不要一开始就追求全面的自动化，自动化需要花费一定时间。根据团队的进度视情况适度进行。

技术建议：

1. 采用 TDD 的方式开发不光可以提升质量，也完成了测试的自动化。
2. 注意自动化的安全隐患。机密信息需要独立管理。
3. 关键步骤需要准备自动手动两种方式，必要时可以干预自动过程。
4. 采用 git 的 hook 技术，在代码 push 之前就可以完成测试和静态检查，提升 CI 的成功率。

**步骤7**：总结并复制成功经验，建立起微服务交付的节奏

当完成了第一个微服务，不要着急开始进行下一个微服务的开发。而是需要进行一次关于可复制经验的总结，识别微服务开发中的经验教训并总结成可复制的经验和产出。

以下是一些需要总结出来的关键产出：

1. 微服务开发到发布的端到端流程规范。
2. 微服务开发的技术质量规范。
3. 团队合作中的坚持的最佳实践。
4. 常见技术问题总结。

有了以上的关键产出，就可以对微服务开发团队进行扩张。这时候有了微服务开发的老司机，带着刚加入的同事一起开发，风险会相对低很多。

管理建议：

1. 刚开始的时候可以每周进行一个回顾会议，团队需要快速的反馈和调整。
2. 不要急于扩张团队，要在成功经验稳定并形成模式之后再快速扩充。
3. 避免微服务良好的开发氛围被稀释，刚开始的时候扩充团队可以慢一点。新老成员的配比不要超过1:1。
4. 虽然微服务平台趋于稳定，但在微服务没有上规模之前，不要让团队里缺少 Ops 成员。
5. 注意知识的传递和人员的培养。

技术建议：

1. 不要急于在微服务应用规模不大的时候形成微服务模板，否则会限制未来微服务的开发和扩展。
2. 在微服务不成规模的时候不要放松对微服务平台的改进。

## 微服务化实战案例分析

原文：[https://gitbook.cn/books/58b4d65e5abc2fd65ea7d578/index.html](https://gitbook.cn/books/58b4d65e5abc2fd65ea7d578/index.html)

**一、背景介绍** by 庄表伟

1. 原始架构是 Gitlab，一个开源的 github clone。基于 rails 框架开发的 Web 项目，Rails + MySQL + Sidekiq + Redis + LocalFileSystem。如果不对 Gitlab 做架构改造，在负载与存储量不断上升之后，只能是在 Nginx 之后，运行多个 Rails Web 实例，通过 NFS mount 到后端的一个超大的 NAS 存储，然后 MySQL 与 Redis 部署成独立服务。最终这个方案，将难以为继。

2. 首先做的改造，是存储分片，将不同的 git 仓库，存储在多台不同的存储服务器上，形成 N*M 个 NFS mount 连接。再后来，我们将 gitlab_git（一个 gitlab 的 git 封装）改造成 rpc 模式，前端 Web 使用 gitlab_git_client，访问后端的 gitlab_git_server。中间的访问协议是 dRuby，访问路由存储在 redis 里。

3. 由于企业内部对于网络传输速度的要求很高，从 Github 下载代码，500K/s 已经非常理想，但是在公司内，8~10M/s这个水平才是可以被接受的。在跨地域读取的情况下，下载速度有 8~20 倍的差距，迫使我们必须做多数据中心的部署。考察过各种分布式文件系统，但是性能都无法保障，只能自己做：按项目路由、分布式存储、自建备份能力。

4. 目前建了 N 个数据中心，共计超过 100 台服务器。

5. 目前的数据库，主要是 MySQL，还有一些存在 MongoDB 里，总量超过200G，且增长迅猛。

6. 我们目前主要在用 Sidekiq 做任务队列，每天的任务数量大约1~2百万。之前有一个量非常大的邮件群发任务，目前已经分拆出去，基于 RabbitMQ，做了一个独立的邮件发送服务。

7. 在自动化部署方面，目前主要是通过 chef + ansible 来做的，chef 安装软件；ansible 是把依赖软件跟应用的安装流程串起来；曾经在 docker swarm 与 kubernetes 之间徘徊，后来决定不再考虑 docker swarm。
8. 在监控方面，购买了一个商业产品，自己也有一些简单的基于 grafana + influxdb 的监控。
9. 在日志搜集与分析方面，目前还是通过 Logstash + ElasticSearch 做了一个简单的架子。

**二、思考与选择** by 庄表伟

1. 经过各种比较分析，最终我还是选择了Kubernetes，主要是 2 个原因：

   - Services 与 RC 的概念划分，使得我们不必太多考虑伸缩性的问题。
   - POD 与 Container 的概念划分，使得我们的每一个镜像都是简洁的，不会搞成每个 image 里，都要加一个 nginx 的事情。
   - 肖德时注解：Kubernetes 是很优秀的分布式容器集群，解决的是应用纬度的问题，需要实践的地方很多。所以专门的运维平台组的建立是有必要的。另外，Rancher 这个项目也可以参考。镜像仓库可以考虑 Harbor。
   - 肖德时注解：还要[培训和自我学习](https://zhuanlan.zhihu.com/p/25325482)。

2. 在镜像制作方面，我现在在琢磨基于 alpine 3.4（4.8M），打造一组最小化的镜像。但是不确定是不是“邪道”。

   - 另外，也想请教一下，是否有一套成熟的镜像继承树的最佳实践？
   - 肖德时注解：开发测试集成环境，有一个开发用的 Base 作为基础。把需要的依赖都加入。使用 compose 启动本地依赖环境。
   - 肖德时注解：生产用镜像使用轻量级镜像入 alpine，对于 ruby 场景使用 phusion/baseimage。

3. 关于API，情况比较复杂，需要多说两句：原始的 Gitlab 项目中，自带了 grape 的 API 框架，API 的代码与 Web 的代码是放在一起的，共用一套 model 定义，因此，最初我做的拆分，是在 rails 之外，独立做了一个 API Server，是基于 sinatra + sequel 的。但是，因为数据库结构的不断变动，尤其是各种关联关系、触发条件的机制，使得另外维护一套 model 很不划算，再加上权限管理也很复杂。所以，我们现在的 API 还是和 Web 服务是放在一起的。

   - 因此，如何将 API 逐一拆分出来，我这边还感觉比较困惑。
   - 肖德时注解：使用 eBay/fabio 在 API Server 之前挡住真实的单体应用 API，然后把具体的一个模块重写。通过 Blue/Green 发布升级，保证数据可以回退。
   - 肖德时注解：微服务不是万能，先解决最需要扩展的 API。对于不是瓶颈的，建议陪着业务发展了之后在扩展。把精力放在监控报警，APM 等体系建设上更能产出价值。

4. 消息与任务队列，在 Rails 的项目中，都是由 Sidekiq 承载的。现在我想要区分消息队列与任务队列。数量级大的，不需要确保消息达到率的，可以走 Kafka。数量可以接受，必须确保完成的任务，走 sidekiq。但是，与 API 的情况类似，sidekiq 与 rails 的 ActiveRecord 也有强相关。（在 task 里，只有一个 order_id，在 sidekiq 的 worker 实际执行时，再去数据库里读取），使得独立拆分 worker，也比较麻烦。目前的想法是将任务信息完整的打包在 redis 里，然后用 go 语言重写 worker，独立执行。

   - 基于之前的讨论，如果将 models 抽取出来，做成 N 个 gem 包，然后 sidekiq 的 worker，直接引用其中的一个 gem 包，即可独立部署了。是否用 go 语言改写，可以延后在考虑。
   - 肖德时注解：对于 a 的做法，应该要考虑把 sidekiq 的服务抽象出来做成可以水平扩展的消息队列服务是可以深挖的。带来的价值会成为突破口。
   - 肖德时注解：RabbitMQ 与 Kafka 之间的选择，主要还考虑到咱们这个项目与其他几个系统之间的通讯，之前也是采用的 Kafka，所以打算收拢成一种为好。
   - 肖德时注解：对于 c 的选择，单一化技术栈是对的。支持。

5. 关于 Web 服务的拆分，实话实说，我都没想好要不要拆。主体 Rails 项目，关联到后台的 MySQL，有 190 多个表，如果粗暴分类的话，可以分为 7 大类。但是，想像中要把一个数据库，拆分成七个数据库，Web Server 也拆成 7 个 Rails 项目，总觉得脚下发软，心里没底。

   - 目前能够想明白的思路：首先抽取 models，做成 N 个 gem 包，原本的 Web 项目依然引用这些 gem 包，看起来没有变化。
   - 在 Web 应用之前，架 OpenResty + Lua 脚本的服务，做分流。在一开始的时候，OpenResty 后只有一个 Web 服务。后续拆成多个 Web 服务，依然对外保持一致。
   - API 拆分的方案，也与此类似：OpenResty 做 API Gateway，实现分流与限流，后面连接多个 API 服务。
   - 肖德时注解：微服务是为了解决业务扩展的问题，目前从实际案例中，目前还没有遇到瓶颈。从实践的角度来讲，过早的优化架构也是有技术债需要偿还的。目前可以考虑解决 CI/CD 的问题，加快交付流程。在过程中体会和抽取需要频繁更新的模块，然后做出服务，进行扩展使用。

**三、分析** by 王渊命

1. 容器平台选择

   我个人的建议是如果能搞定 kubernetes 则优先考虑，否则建议选 swarm。另外这个系统涉及的所有组件，比如 数据库，分布式存储，消息队列，都打算部署到 kubernetes 里么？还是只部署自己的微服务组件？

2. 镜像制作

   个人建议基于 alpine 构建一套内部的镜像树，然后推广使用。

   按照容器的发展趋势来说，容器内的操作系统其实相当于应用的依赖，主要作用是维护软件栈，而主机操作系统是用来管理硬件的，也就是说，慢慢会演化出两种操作系统。

   以后新的应用或者库发布，可能就只需要考虑容器内操作系统的兼容性，而不需要在主机操作系统中进行测试。不过 alpine 的一个问题是它的 libc 不是 glibc，而是 musl-libc，所以许多语言（c, golang）的程序发布的时候需要在 alpine 上编译才行，不能直接使用其他 linux 发行版编译出来的二进制。

   这个问题也有一个办法就是先在 alpine 中安装 glibc，不过这个方式不太推荐，因为 musl-libc 是一种更轻量、简单、高效的 libc 实现，可以参看[评测结果](http://www.etalabs.net/compare_libcs.html)。

3. 关于 API 以及 models 的拆分，这个我觉得是这个项目的大头，是关键点。其他的都是技术上的拆分方案，基本有通用的规则或者现成的工具，而这个是涉及业务的。鉴于我对 gitlab 本身的业务逻辑不是太熟悉，所以这里没办法给出具体的方案意见，但是可以给一些通用的建议。

   gitlab 这种系统是典型的企业应用，主要是面向数据库架构的，因为大多数企业应用所承载的用户规模有限，一般也没问题。但这种架构，如果要互联网化（变为 SaaS 模式），或者遇到规模比较大的企业（比如本案例中），为了应对用户规模的增长，需要伸缩其中的某些组件，要改造成微服务模式的时候，就会遇到问题。因为 RoR 本质上是一种面向数据库的架构框架，强依赖于其 ActiveRecord 的能力，所以拆解服务需要先从数据库入手。

   - 首先分析当前的数据库表和 models 之间的映射关系，粗略的按服务将数据库表归类。
   - 同一个服务下的数据库表之间可以保留 ActiveRecord 的关联以及映射关系。
   - 跨服务的数据库表的 ActiveRecord 的关联和映射需要解除定义，也就是说不能跨服务进行数据库查询。
   - 将跨服务的 models 组装的业务逻辑从 ActiveRecord 层提升到 service 层，通过微服务的远程接口进行组装。
   - 以上的拆解可以先在当前的单体应用中做，进行逻辑模块拆分，等拆分模块完毕之后，再尝试拆分项目进行独立部署。

4. 关于 API 网关的选择，一个是考虑 API 网关如何和服务注册中心交互，以实现动态分流，第二个是要考虑内部服务之间的通讯方式，也是通过 API 网关，还是通过 smart client 方式客户端路由，还是通过 kubernetes 这样的框架提供的 service vip 的方式。

5. 关于 web 的拆分，这个和 API 类似。不过这个关键点是要将 web 和后端的依赖关系完全 API 化，也就是说 web 只依赖后端的 API，而不能直接依赖数据库 或者 service。至于这样拆解后，web 是否需要再进一步拆分成更细的 service，这个可以看项目演进情况。

6. 消息和任务队列，这个本质上是应用的一种异步 API 的需求，量级不大的情况下，大多数应用都直接基于语言和框架内置的异步机制实现，但一旦规模上来就需要引入队列服务来实现了。至于是选择 RabbitMQ 或者 Kafka，我觉得本案例中选择一种就好，不建议引入多种队列。消息队列中的消息是 order_id 呢还是完整的消息，这个各有优劣。如果是 id 的话，worker 拿到 id 后，通过 task 服务的远程接口去查询 task 的详情也可以。

7. 微服务化会遇到的几个问题：

   - API 输出模型的选择，胖模型还是瘦模型？比如 commit 对象中有作者信息，作者只是一个 id 呢，还是包含作者的详细信息？这个也包含异步消息中的序列化模式。瘦模型适合内部服务间互相依赖的情况，胖模型适合最终对外输出。
   - 服务间的依赖关系如何界定，如何避免循环依赖？是否需要一个聚合层服务。如果服务之间都可以互相调用，很容易出现循环依赖。比如 commit 服务中由于需要输出作者信息，所以依赖 user 服务，而 user 服务输出用户信息的时候，希望也输出该用户最新的几条 commit 信息。如果出现线上的循环依赖可能会导致内网挂掉，相当于自己对自己发起了 DDOS。这种情况下，为了清晰的依赖关系，可以规定 service 之间不互相依赖，在外面再加一层聚合服务，专门做聚合输出。

8. 综述：

   面向数据库架构的应用，要重构成微服务，其实和重写差不多。我觉得这也是为什么 twitter 选择了直接放弃 RoR，用 java 重写（虽然这里面也有语言性能的原因，但我觉得语言的性能不是关键原因，关键是是否能支撑伸缩，如果放弃 Rails，用 ruby 重写理论上也可以搞定，但没有了 rails，选择 ruby 的理由更少了）。

   所以这里也建议一种方案，就是用其他语言重写。最外层的 web 和 API 聚合层可以沿用当前的 ruby，后面的微服务 API service 全部重写，逐渐替换，理论上成本并不会比基于当前的架构重构成本更高。

**四、分析** by 肖德时

1. GitLab因为业务流量增加，迫切需要一套水平扩展的解决方案。这是计划微服务改造探索的起因。在负载与存储量不断上升之后，第一步需要做的事情并不是着手设计一套优雅的可扩展的架构，反而最迫切的事情是容量规划，通过监控，日志系统迅速了解当前资源可以支撑的规模到底是什么样的容量规模。预期的服务能力是什么样子，按照现有的能力扩展，到底需要多少资源才能满足。这些基础数据的整理，对日后扩展提供了一个基准线。从研发投入产出比来讲，没有对业务做出贡献的架构改造都是不充分合理的，需要注意实施步骤。

   具体问题要解决，当流量上来后，通过多个 rails web 来分流未尝不可，但是底下的存储有状态，打破了水平扩展的规则。存储一般有容量限制，要想解决存储问题，Sharding 文件还是启用分布式文件系统都是具体的解决办法。

2. 梳理迫切需要解决问题清单，尝试梳理如下：

   - DevOps 最佳实践
   - 更新微服务架构设计，支持服务的水平扩展
   - 资源调度，节省成本

3. 启用容器和编排系统的目的，就是建立企业自己的 PaaS 平台。从 chef + ansible 到 PaaS 平台，原来都是需要专业厂商提供，现在通过开源的框架，小的研发团队就可以快速建立起来标准、可靠的应用发布平台。Kubernetes，Swarm，Mesos 都是很优秀的开源方案，选择一款开源方案作为业务支撑都可以。

4. 解决核心问题，业务改造。

   - rails web 和 api 是绑定的。内部 model 是复用。单体模式。
     - 抽离 rails web，去掉 db，在 service 层直接调用 API 获取资源。
     - 重写 web，使用 ag2、react 等前端框架取代 rails web。
     - rails api 按照业务分离，方便局部 API 可以水平扩展。通过容器部署，可以动态解决资源负载的分配。
   - 异步任务使用的消息队列采用一款就可以。深入积累知识作为支持储备。rabbitmq 和 Kafka 都没有问题。为了服务水平化，可以考虑建立一套独立的消息队列 cluster。

5. 因为 rails web 和 db 解耦之后，rails web 变成了 client 端访问后端。后端 API 变成微服务之后的服务质量保障可以通过引入 API 网关来解决。

6. Rails 就是为单体而生，上微服务意义不大。把单体的 rails web 通过容器封装水平扩展部署。只有当业务量达到一个非常巨大的请求量时才考虑分拆。
   - 强化监控报警和应用层 Tracing 是团队能力提升最关键的工具。
   - ELK的服务化改造也要重点关注。

7. 综述：
   - 微服务架构是云计算发展过程中产生的一种推荐架构，是为了分布式部署而生。系统架构改造的前提是了解当前容量和服务能力的水平，然后再做架构设计和扩展。我们很多时候最大的问题是没有设立基准线，等改造完成后，结果是否满意，并不能准确的回答。大量技术的资源投入，产出比不是想出来的，是通过数据展示来验证的。
   - 业务抽离可以从 web 层开始，而不是 API 层。从外往里面一层一层的拆解应该是最容易的。对外 API 和对内 API 可以分离的很清楚。一旦完成分离，通过 API 网关汇聚内部 API 服务，通过统一的指标来规约 API 服务的质量。
   - 启用微服务之后，管理复杂度提升，相关的监控报警日志系统比原来更为重要。给自己建立一套好用的监控服务工具比业务改造的任务还要重要。

## 基础设施服务的微服务化

原文：[https://gitbook.cn/gitchat/activity/58639d7595c29fc15b3abe1b](https://gitbook.cn/gitchat/activity/58639d7595c29fc15b3abe1b)

微服务架构可以视为面向组件架构和面向服务架构结合的产物。大多数和微服务相关的讨论都是分析业务应用如何微服务化，如何远程调用，如何服务治理，谈论基础设施服务的却很少，本文主要讨论基础设施服务的微服务化方案。

**多微的服务才叫微服务？**

微服务这一两年非常火，云、容器等技术的发展都是在给微服务铺路，因为用户本质上需要的是服务，不是资源。

但大多数和微服务相关的讨论都是分析业务应用如何微服务化，如何远程调用，如何服务治理，谈论基础设施服务的却很少，我们今天来聊聊这个。

讨论微服务，遇到的第一个问题就是多微的服务才能叫微服务呢？是否有个标准，比如多少行代码？多少个方法？多少个接口？

我们来看看微服务这个概念的最早定义：

```txt
In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery.
```

大家不用全部仔细看完，只需看看我标出来的几个关键词：

- Small Service 这个好理解，就是微服务就是小服务。
- Independently Deployable 可独立部署。微服务就是将原来的共享库的依赖方式，改为远程调用的依赖方式，每个微服务都是独立部署的服务。
- Fully AutoMated Deployment 完全的自动化部署。

最后一点往往被大家忽略，为什么微服务就要完全的自动化部署呢？

因为以前的几个服务，被拆分为成百上千的服务，如果没有完全的自动化部署，基本上是不可维护的。

当然，你可以说 “我就是不差钱，我就招上千个人来管这些服务” 就不叫微服务了？但这违背了我们搞微服务的目标。

再回归到微服务这个概念。我个人认为微服务化本身包含两层意思：

- 一层是拆。这个大家提到的多，将大的服务拆成小的服务粒度，通过远程调用解决依赖。
- 一层是合。就是整个系统的微服务的所有组件之间应该是一个整体的分布式系统，按集群化的方式来设计，服务之间能互相感知，进行自动化协作。

我们来看一个微服务的例子：

![x](./Resource/ms.jpg)

这里面有 A、B、C、D 四个服务，每个服务都依赖数据库以及缓存，对外的服务有负载均衡器，服务之间互相依赖，异步交互通过队列进行。上图这样一个简单的微服务例子，我们可以看出基础设施都包括：

- 负载均衡 (HAProxy, Nginx)
- 数据库 (MySQL)
- 缓存 (Memcached, Redis)
- 队列 (Kafka)
- NoSQL (Elasticsearch, MongoDB)
- 服务发现 (Zookeeper, Etcd, Consul)

**基础设施是否需要微服务化？**

要解答这个问题，我们先看看当前的基础设施服务的主要解决方案：

- 第一种是大的互联网公司普遍使用的一种方案。

  基础设施服务托管给基础设施部门，基础设施部门包含运维、DBA 等。比如开发人员需要一套 MySQL 服务的时候，提出申请，基础设施部门负责搭建和运维，开发人员只需要连接 MySQL 的 IP 进行使用即可。

- 第二种方式是托管给云厂商，是使用当前云的基础设施服务。

  比如 QingCloud、AWS 都提供基础设施服务，当你需要一套 MySQL，在控制台即可创建，然后获取到连接 IP，这样可以省去运维基础设施服务的成本。

但是这两种方式都有一些问题：

- 开发测试流程中的基础设施服务如何部署，如何自动化？

  这个没法委托给基础设施部门，需要开发人员自己动手搞。但开发人员一方面也没有精力搞一套完整的自动化工具，但即便是搞了，也解决不了开发环境和线上环境异构的问题。前面有位讲师的分享也说到了这个问题，异构问题总会导致故障，没出现故障也是时候没到。

- 基础设施服务迁移、伸缩、故障恢复时应用如何感知？

  比如有个 MySQL 集群，当前数据库请求量太大，扩容了从库，应用如何自动感知到这个变化，从而使用新的从库？

  我们再回顾下微服务的要求：集群化与自动化。当前的基础设施服务的解决方案，不能满足微服务的集群化，自动化这两点要求。我们可以得出结论：基础设施服务属于微服务系统中的一部分，需要和业务服务互相感知，需要被微服务化。

**基础设施服务如何微服务化？**

基础设施服务如何微服务化，有两个难点：

- 基础设施服务种类多样，配置异构。
- 基础设施服务集群机制多样。

比如前面那个简单的微服务系统，就用到了很多基础设施服务，各种服务的有各种不同的配置方式。同时，这些服务的集群机制也是多种多样的。

我们举几个例子来说明下：

![x](./Resource/ms1.jpg)

Zookeeper 的主要配置文件是 zoo.cfg，这个配置文件中需要列出整个集群中的所有节点，以及对应的 Server ID。

另外，每个节点还有一个独立的 MyID 配置文件，这个文件中写了当前节点的 Server ID 。比如要把这个集群扩展到 5 个节点，首先要算出新的节点的 Server ID 号，生成新的节点的 MyID 配置文件，同时需要变更每个节点的 zoo.cfg 配置文件，把新节点的 Server ID 和 IP 都写进去，然后重启服务。

![x](./Resource/ms2.jpg)

HAproxy 的配置文件中的每个 Backend 后会配置一个 Server 列表。如果后端服务伸缩，就需要变更这个 Server 列表。

![x](./Resource/ms3.jpg)

Redis Cluster 的这个例子我只是想说明下，Redis 并不是通过配置文件来维护集群信息的，而是通过动态命令。创建集群，增删节点，都需要调用命令进行。

![x](./Resource/ms4.jpg)

Kafka 是通过 Zookeeper 来做服务发现的，所以如果 Zookeeper 集群变更，就需要变更它的配置文件中的 zookeeper.connect 配置项。

粗略的看了以上的几个例子，大家对基础设施服务的配置和集群的多样性有了初步的体验。

既然要微服务化，就需要设计服务的注册发现以及配置变更方案。微服务理想中的方案是应用内部自发现，监听配置中心，自动进配置变更。但现实的状况前面的例子也看到了，我们不可能等待这么多的服务逐渐都改造升级了再用，所以唯一可行的办法就是通过非侵入的方式，进行第三方的服务注册，以及配置变更。

## 基于容器和微服务的架构

### 容器化单体应用

![x](./Resource/61.png)

- 原则：一个容器在一个进程中做一件事
- 缺点：不易伸缩

### 面向服务的架构

面向服务的架构(SOA)是一个被滥用的词汇，不同人有不同的理解。不过作为一个通用标准，SOA意味着需要从结构上将应用尽可能解耦成多个服务（通常为HTTP服务），这些服务要能区分成不同的类型，如子系统或分层。

这些服务也可作为Docker容器来部署，因为所有依赖都包含在容器镜像里，这就解决了部署方面的问题。然而在纵向扩展SOA应用时，如果部署在单个Docker主机中，或许会面临扩展性和可用性的挑战。这就需要Docker集群软件或编排引擎的帮助。

Docker容器对面向服务的传统架构以及更先进的微服务架构都能提供巨大价值（但并非必需）。

微服务是从SOA派生而来的，但SOA与微服务是不同的架构。例如大型中心代理、企业级中心编排引擎和[企业服务总线(ESB)](https://en.wikipedia.org/wiki/Enterprise_service_bus)都是典型的SOA功能。在微服务社区中，大多数情况下这都是SOA的反模式设计。实际上，有争议认为“微服务架构只是正确实现SOA之后的产物”。

相比微服务架构，SOA在要求和技术方面的规范更宽松一些。只要知道如何创建微服务应用，那么就会知道如何创建一个简单的SOA应用。

### 微服务架构

顾名思义，微服务架构是一种以小型服务集合来创建服务端应用的方法。

- 每个服务在独立进程中运行，通过通信协议（如HTTP/HTTPS、WebSockets或[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)）彼此通信。
- 每个微服务负责实现一个特定的端到端领域，或有着确定边界的业务逻辑，并且每个微服务必须能独立开发和部署。
- 最后，每个微服务应该拥有自己特定的领域数据模型和领域逻辑（自治和去中心化的数据管理），它们是基于不同数据存储技术（SQL、NoSQL）和不同编程语言实现的。

微服务到底能有多小？

在开发微服务时，大小不应该是重点，重点是要创建 **低耦合** 的服务，以便能独立地开发、部署和扩展每个服务。当然在确定和设计微服务时，只要它们之间没有太多直接依赖，就应该使它们尽可能地小。比大小更重要的还有必要的内部一致性和对其他服务的依赖。

微服务架构的优势：

- 提供长期的敏捷性：独立生命周期
- 独立横向扩展

![x](./Resource/62.png)

成功实施微服务架构注意点：

- 服务和基础架构的监测和监控状态
- 为服务扩展基础架构（云和编排引擎）
- 在多个层级设计并实现安全性：认证、授权、密文密码管理和安全通信等- 
- 快速应用发布，通常由不同的团队来实现不同微服务
- DevOps和CI/CD的实践和架构

## 参考

- 《使用微软平台和工具的容器化Docker应用的生命周期》
