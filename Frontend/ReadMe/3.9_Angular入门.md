# Angular入门

## 起步

AngularJS 是 Google 开源出来的一套 js 工具。下面简称其为 ng 。这里只说它是“工具”，没说它是完整的“框架”，是因为它并不是定位于去完成一套框架要做的事。更重要的，是它给我们揭示了一种新的应用组织与开发方式。

ng 最让我称奇的，是它的数据双向绑定。其实想想，我们一直在提数据与表现的分离，但是这里的“双向绑定”从某方面来说，是把数据与表现完全绑定在一起——数据变化，表现也变化。反之，表现变化了，内在的数据也变化。有过开发经验的人能体会到这种机制对于前端应用来说，是很有必要的，能带来维护上的巨大优势。当然，这里的绑定与提倡的分离并不是矛盾的。

ng 可以和 jQuery 集成工作，事实上，如果没有 jQuery，ng 自己也做了一个轻量级的jQuery，主要实现了元素操作部分的 API。

AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。

AngularJS的创新之处在于，通过数据绑定和依赖注入减少了大量代码，而这些都在浏览器端通过JavaScript实现，能够和任何服务器端技术完美结合。

Angular是为了扩展HTML在构建应用时本应具备的能力而设计的。对于静态文档，HTML是一门很好的声明式的语言，但对于构建动态WEB应用，它无能为力。所以，构建动态WEB应用往往需要一些技巧才能让浏览器配合我们的工作。

通常，我们通过以下手段来解决动态应用和静态文档之间不匹配的问题：

- 类库：一些在开发WEB应用时非常有用的函数的集合。你的代码起主导作用，并且决定何时调用类库的方法。例如：jQuery等。
- 框架：一种WEB应用的特殊实现，你的代码只需要填充一些具体信息。框架起主导作用，并且决定何时调用你的代码。例如：knockout、ember等。

## 什么是 AngularJS

AngularJS是一个为动态WEB应用设计的结构框架。它能让你使用HTML作为模板语言，通过扩展HTML的语法，让你能更清楚、简洁地构建你的应用组件。它的创新点在于，利用数据绑定和依赖注入，它使你不用再写大量的代码了。这些全都是通过浏览器端的Javascript实现，这也使得它能够完美地和任何服务器端技术结合。

AngularJS使用了不同的方法，它尝试去补足HTML本身在构建应用方面的缺陷。AngularJS通过使用我们称为标识符(directives)的结构，让浏览器能够识别新的语法。例如：

- 使用双大括号 {{}} 语法进行数据绑定；
- 使用DOM控制结构来实现迭代或者隐藏DOM片段；
- 支持表单和表单的验证；
- 能将逻辑代码关联到相关的DOM元素上；
- 能将HTML分组成可重用的组件。

## 端对端的解决方案

AngularJS试图成为成为WEB应用中的一种端对端的解决方案。这意味着它不只是你的WEB应用中的一个小部分，而是一个完整的端对端的解决方案。这会让AngularJS在构建一个CRUD（增加Create、查询Retrieve、更新Update、删除Delete）的应用时显得很“固执”（原文为opinionated，意指没有太多的其他方式）。但是，尽管它很“固执”，它仍然能确保它的“固执”只是在你构建应用的起点，并且你仍能灵活变动。

AngularJS的一些出众之处如下：

- 构建一个CRUD应用可能用到的全部内容包括：数据绑定、基本模板标识符、表单验证、路由、深度链接、组件重用、依赖注入。
- 测试方面包括：单元测试、端对端测试、模拟和自动化测试框架。
- 具有目录布局和测试脚本的种子应用作为起点。

## AngularJS的可爱之处

AngularJS通过为开发者呈现一个更高层次的抽象来简化应用的开发。如同其他的抽象技术一样，这也会损失一部分灵活性。换句话说，并不是所有的应用都适合用AngularJS来做。

AngularJS主要考虑的是构建CRUD应用。幸运的是，至少90%的WEB应用都是CRUD应用。但是要了解什么适合用AngularJS构建，就得了解什么不适合用AngularJS构建。如游戏，图形界面编辑器，这种DOM操作很频繁也很复杂的应用，和CRUD应用就有很大的不同，它们不适合用AngularJS来构建。像这种情况用一些更轻量、简单的技术如 jQuery 可能会更好。

## AngularJS的禅道（理念）

Angular信奉的是，当组建视图(UI)同时又要写软件逻辑时，声明式的代码会比命令式的代码好得多，尽管命令式的代码非常适合用来表述业务逻辑。

- 将DOM操作和应用逻辑解耦是一种非常好的思路，它能大大改善代码的可调性；
- 将测试和开发同等看待是一种非常非常好的思路，测试的难度在很大程度上取决于代码的结构；
- 将客户端和服务器端解耦是一种特别好的做法，它能使两边并行开发，并且使两边代码都能实现重用；
- 如果框架能够在整个开发流程里都引导着开发者：从设计UI，到编写业务逻辑，再到测试，那对开发者将是极大的帮助；
- “化繁为简，化简为零”总是好的。

AngularJS能将你从以下的噩梦中解脱出来：

- 使用回调：
  
  回调的使用会打乱你的代码的可读性，让你的代码变得支离破碎，很难看清本来的业务逻辑。
  
  移除一些常见的代码，例如回调，是件好事。大幅度地减少你因为JavaScript这门语言的设计而不得不写的代码，能让你把自己应用的逻辑看得更清楚。

- 手动编写操作DOM元素的代码
  
  操作DOM是AJAX应用很基础的一部分，但它也总是很“笨重”并且容易出错。
  
  用声明的方式描述的UI界面可随着应用状态的改变而变化，能让你从编写低级的DOM操作代码中解脱出来。绝大部分用AngularJS写的应用里，开发者都不用再自己去写操作DOM的代码，不过如果你想的话还是可以去写。

- 对UI界面读写数据：
  
  AJAX应用的很大一部是CRUD操作。
  
  一个经典的流程是把服务端的数据组建成内部对象，再把对象编成HTML表单，用户修改表单后再验证表单，如果有错再显示错误，然后将数据重新组建成内部对象，再返回给服务器。
  
  这个流程里有太多太多要重复写的代码，使得代码看起来总是在描述应用的全部执行流程，而不是具体的业务逻辑和业务细节。

- 开始前得写大量的基础性的代码：
  
  通常你需要写很多的基础性的代码才能实现一个"Hello World"的应用。
  
  用AngularJS的话，它会提供一些服务让你很容易地正式开始写你的应用，而这些服务都是以一种Guice-like dependency-injection式的依赖注入自动加入到你的应用中去的，这让你能很快的进入你应用的具体开发。特别的是，你还能全盘掌握自动化测试的初始化过程。

## 引导程序

这个示例展示了我们推荐的整合AngularJS的方法，它被称之为“自动初始化”。

```html
<!doctype html>
<html xmlns:ng="http://angularjs.org" ng-app>
<body>
  ...
  <script src="angular.js"></script>
</body>
</html>
```

将上面代码中的script标签放在页面的底部。将script标签放在底部缩短应用加载的时间，因为这样HTML的加载不会被angular.js脚本的加载阻塞。

你可以从http://code.angularjs.org获得最新的版本。请不要在你的代码里面引用这个URL，因为它会暴露你的站点的安全隐患。如果只是实验性质的开发，那链接到我们的站点没有什么问题。

- angular-[version].js 是具有可读性的版本，适合开发和调试。
- angular-[version].min.js 是压缩和混淆后的版本，适合部署到成型产品中。

请将ng-app指令放到你的应用的标签根节点中，如果你想要AngularJS自动执行整个 `<html>` 程序就把它放在 `<html>` 标签中。

## 自动初始化

AngularJS 会在 `DOMContentLoaded` 事件触发时执行，并通过 ng-app 指令寻找你的应用根作用。如果 ng-app 指令找到了，那么 AngularJS 将会：

- 载入和指令内容相关的模块。
- 创建一个应用的“注入器(injector)”。
- 已拥有ng-app指令的标签为根节点来编译其中的DOM。这使得你可以只指定DOM中的一部分作为你的AngularJS应用。

```html
<!doctype html>
<html ng-app="optionalModuleName">
  <body>
    I can add: {{ 1+2 }}.
    <script src="angular.js"></script>
  </body>
</html>
```

## 手动初始化

如果你需要主动控制一下初始化的过程，你可以使用手动执行引导程序的方法。比如当你使用“脚本加载器(script loader)”，或者需要在AngularJS编译页面之前做一些操作，你就会用到它了。

下面的例子演示了手动初始化AngularJS的方法。它的效果等同于使用 ng-app 指令。

```html
<!doctype html>
<html xmlns:ng="http://angularjs.org">
  <body>
    Hello {{'World'}}!
    <script src="http://code.angularjs.org/angular.js"></script>
    <script>
      angular.element(document).ready(function() {
        angular.bootstrap(document);
      });
    </script>
  </body>
</html>
```

下面是一些你的代码必须遵守的顺序：

1. 等页面和所有的脚本加载完之后，找到HTML模板的根节点——通常就是文档的根节点。
2. 调用 `api/angular.bootstrap` 将模板编译成可执行的、数据双向绑定的应用程序。

## 开始例子

从代码（01_Hello）中，我们看到在通常的HTML代码当中，引入了一些标记，这些就是ng的模板机制，它不光完成数据渲染的工作，还实现了数据绑定的功能。

同时，在 HTML中的本身的DOM层级结构，被ng利用起来，直接作为它的内部机制中，上下文结构的判断依据。比如例子中p是div的子节点，那么p中的那些模板标记就是在div的Ctrl的作用范围之内。 

其它的，也同样写一些js代码，里面重要的是作一些数据的操作，事件的绑定定义等。这样，数据的变化就会和页面中的DOM表现联系起来。一旦这种联系建立起来，也即完成了我们所说的“双向绑定”。

然后，这里说的“事件”，除了那些“点击”等通常的DOM事件之外，我们还更关注“数据变化”这个事件。

最后，可以使用： 

```js
angular.bootstrap(document.documentElement, ['app']);
```

来把整个页面驱动起来了。（你可以看到一个可被控制大小的红色方块） 

简单来说，就是定义一个 App，然后bootstrap时指定需要用哪些App。（App之间的依赖关系在定义时声明就好了） 

这里说的一个App就是ng概念中的一个Module。 

接下来描述AngularJS应用程序的三个组成部分，并解释它们如何映射到模型-视图-控制器设计模式：

## 模板（Templates）

模板是您用HTML和CSS编写的文件，展现应用的视图。 

您可给HTML添加新的元素、属性标记，作为AngularJS编译器的指令。AngularJS编译器是完全可扩展的，这意味着通过AngularJS您可以在HTML中构建您自己的HTML标记！

### 应用程序逻辑（Logic）和行为（Behavior）

应用程序逻辑和行为是您用JavaScript定义的控制器。

AngularJS与标准AJAX应用程序不同，您不需要另外编写侦听器或DOM控制器，因为它们已经内置到AngularJS中了。这些功能使您的应用程序逻辑很容易编写、测试、维护和理解。

### 模型数据（Data）

模型是从AngularJS作用域对象的属性引申的。模型中的数据可能是Javascript对象、数组或基本类型，这都不重要，重要的是，他们都属于AngularJS作用域对象。

AngularJS通过作用域来保持数据模型与视图界面UI的双向同步。一旦模型状态发生改变，AngularJS会立即刷新反映在视图界面中，反之亦然。

此外，AngularJS还提供了一些非常有用的服务特性

1. 底层服务包括依赖注入，XHR、缓存、URL路由和浏览器抽象服务。
2. 您还可以扩展和添加自己特定的应用服务。
3. 这些服务可以让您非常方便的编写WEB应用。

### 依赖注入

injector，我从 ng 的文档中得知这个概念，之后去翻看源码时了解了一下这个机制的工作原理。感觉就是虽然与自己的所想仅差那么一点点，但就是这么一点点，让我感慨想象力之神奇。

先看我们之前代码中的一处定义： 

```js
app.controller('BoxCtrl', function($scope, $element){});
```

在这个函数定义中，注意那两个参数：`$scope`、`$element`，这是两个很有意思的东西。总的来说，它们是参数，这没什么可说的。但又不仅仅是参数——你换个名字代码就不能正常运行了。 

事实上，这两个参数，除了完成“参数”的本身任务之外，还作为一种语法糖完成了“依赖声明”的任务。本来这个函数定义，完整的写法应该像 AMD 声明一样，写成： 

```js
app.controller('BoxCtrl', ['$scope', '$element', 
  function($scope,$element){
    // ...
  }
]);
```

这样就很明显，表示有一个函数，它依赖于两个东西，然后这两个东西会依次作为参数传入。

简单起见，就写成了一个函数定义原本的样子，然后在定义参数的名字上作文章，来起到依赖声明的作用。 

在处理时，通过函数对象的toString()方法可以知道这个函数定义代码的字符串表现形式，然后就知道它的参数是 `$scope` 和 `$element`。通过名字判断出这是两个外部依赖，然后就去获取资源，最后把资源作为参数，调用定义的函数。

所以，参数的名字是不能随便写的，这里也充分利用了 js 的特点来尽量做到“反省”了。 

### 作用域

这里提到的“作用域”的概念，是一个在范围上与 DOM 结构一致，数据上相对于某个 `$scope` 对象的属性的概念。我们还是从 HTML 代码上来入手： 

```html
<div ng-controller="BoxCtrl">
  <div style="width: 100px; height: 100px; background-color: red;" 
      ng-click="click()">
  </div>
  <p>{{ w }} x {{ h }}</p>
  <p>W: <input type="text" ng-model="w" /></p>
  <p>H: <input type="text" ng-model="h" /></p>
</div>
```

上面的代码中，我们给一个div元素指定了一个BoxCtrl，那么，div元素之内，就是BoxCtrl这个函数运行时，`$scope`这个注入资源的控制范围。

在代码中我们看到的click()，w，h这些东西，它们本来的位置对应于 `$scope.click`，`$scope.w`，`$scope.h`。
 
我们在后面的js代码中，也可以看到我们就是在操作这些变量。依赖于ng的数据绑定机制，操作变量的结果直接在页面上表现出来了。 

## 数据绑定与模板

我纠结了半天，“数据绑定”与“模板”这两个东西还真没办法分开来说。因为数据绑定需要以模板为载体，离开了模板，数据还绑个毛啊。

ng的一大特点，就是数据双向绑定。双向绑定是一体，为了描述方便，下面分别介绍。

### 数据->模板

数据到表现的绑定，主要是使用模板标记直接完成的： 

```html
<p>{{ w }} x {{ h }}</p>
```

使用 `{{ }}` 这个标记，就可以直接引用，并绑定一个作用域内的变量。在实现上，ng自动创建了一个 watcher。效果就是，不管因为什么，如果作用域的变量发生了改变，我们随时可以让相应的页面表现也随之改变。我们可以看一个更纯粹的例子： 

```html
<p id="test" ng-controller="TestCtrl">{{ a }}</p>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl', 
    function($scope){
      $scope.a = '123';
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

上面的例子在页面载入之后，我们可以在页面上看到123。这时，我们可以打开一个终端控制器，输入：

```js
$('#test').scope().a = '12345';
$('#test').scope().$digest();
```

上面的代码执行之后，就可以看到页面变化了。 

对于使用ng进行的事件绑定，在处理函数中就不需要去关心 `$digest()` 的调用了。因为ng会自己处理。源码中，对于ng的事件绑定，真正的处理函数不是指定名字的函数，而是经过 `$apply()` 包装过的一个函数。这个 `$apply()` 做的一件事，就是调用根作用域 `$rootScope` 的 `$digest()`，这样整个世界就清净了： 

```html
<p id="test" ng-controller="TestCtrl" ng-click="click()">{{ a }}</p>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl', 
    function($scope){
      $scope.a = '123';
      $scope.click = function(){
        $scope.a = '456';
      }
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

那个click函数的定义，绑定时变成了类似于： 

```js
function(){
  $scope.$apply(
    function(){
      $scope.click();
    }
  )
}
```

这里的 `$scope.$apply()` 中做的一件事：`$rootScope.$digest();`

### 模板->数据

模板到数据的绑定，主要是通过ng-model来完成的： 

```html
<input type="text" id="test" ng-controller="TestCtrl" ng-model="a" />
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl', 
    function($scope){
      $scope.a = '123';
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

这时修改input中的值，然后再在控制终端中使用： 

```js
$('#test').scope().a
```

查看，发现变量a的值已经更改了。 

实际上，ng-model是把两个方向的绑定都做了。它不光显示出变量的值，也把显示上的数值变化反映给了变量。这个在实现上就简单多了，只是绑定change事件，然后做一些赋值操作即可。不过ng里，还要区分对待不同的控件。 

### 数据->模板->数据->模板

现在要考虑的是一种在现实中很普遍的一个需求。比如就是我们可以输入数值，来控制一个矩形的长度。在这里，数据与表现的关系是：

- 长度数值保存在变量中 
- 变量显示于某个input中 
- 变量的值即是矩形的长度 
- input中的值变化时，变量也要变化 
- input中的值变化时，矩形的长度也要变化 

当然，要实现目的在这里可能就不止一种方案了。按照以前的做法，很自然地会想法，绑定input的change事件，然后去做一些事就好了。但是，我们前面提到过ng-model这个东西，利用它就可以在不手工处理change的条件下完成数据的展现需求，在此基础之上，我们还需要做的一点，就是把变化后的数据应用到矩形的长度之上。 

最开始，我们面对的应该是这样一个东西： 

```html
<div ng-controller="TestCtrl">
  <div style="width: 100px; height: 10px; background-color: red"></div>
  <input type="text" name="width" ng-model="width" />
</div>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl', 
    function($scope){
      $scope.width = 100;
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

我们从响应数据变化，但又不使用change事件的角度来看，可以这样处理宽度变化：

```js
angular.module('app', [], angular.noop).controller('TestCtrl', 
  function($scope){
    $scope.width = 100;
    $scope.$watch('width',
      function(to, from){
        $element.children(':first').width(to);
      }
    );
  }
);
```

使用$watch()来绑定数据变化。

当然，这种样式的问题，有更直接有效的手段，ng的数据绑定总是让人惊异：

```html
<div ng-controller="TestCtrl">
<div style="width: 10px; height: 10px; background-color: red" ng-style="style"></div>
  <input type="text" name="width" ng-model="style.width" />
</div>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl', 
    function($scope){
      $scope.style = {width: 100 + 'px'};
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

## 模板

前面讲了数据绑定之后，现在可以单独讲讲模板了。 

作为一套能称之谓“模板”的系统，除了能干一些模板的常规的事之外（好吧，即使是常规的逻辑判断现在它也做不了的），配合作用域$scope和ng的数据双向绑定机制，ng的模板系统就变得比较神奇了。 

### 定义模板内容

定义模板的内容现在有三种方式： 

- 在需要的地方直接写字符串 
- 外部文件 
- 使用script标签定义的“内部文件” 

第一种不需要多说。第二种和第三种都可以和ng-include一起工作，来引入一段模板。 
直接引入同域的外部文件作为模板的一部分： 

```html
<div ng-include src="'tpl.html'"></div>
<div ng-include="'tpl.html'"></div>
```

注意，src中的字符串会作为表达式处理（可以是$scope中的变量），所以，直接写名字的话需要使用引号。 

引入script定义的“内部文件”：

```html
<script type="text/ng-template" id="tpl">
  here, {{ 1 + 1 }}
</script>
<div ng-include src="'tpl'"></div>
```

配合变量使用： 

```html
<script type="text/ng-template" id="tpl">
  here, {{ 1 + 1 }}
</script>
<a ng-click="v='tpl'">Load</a>
<div ng-include src="v"></div>
```

### 内容渲染控制

#### 重复ng-repeat

这算是唯一的一个控制标签么……，它提供了几个变量可供使用： 

- $index 当前索引 
- $first 是否为头元素 
- $middle 是否为非头非尾元素 
- $last 是否为尾元素 

```html
<div ng-controller="NumCtrl">
  <ul ng-repeat="member in numList">
    <li>{{ member }}</li>
  </ul>
</div>
<div ng-controller="NameCtrl">
  <ul ng-repeat="member in nameList">
    <li>{{ $index }}, {{ member.name }}</li>
  </ul>
</div>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('NumCtrl', 
    function ($scope) {
      $scope.numList = [1, 2, 3, 4];
    }
  ).controller('NameCtrl', 
    function ($scope) {
      $scope.nameList = [{ name: 'A' }, { name: 'B' }, { name: 'C' }];
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

### 赋值 ng-init

这个指令可以在模板中直接赋值，它作用于angular.bootstrap之前，并且，定义的变量与$scope作用域无关。 

```html
<div ng-controller="TestCtrl" ng-init="a=[1,2,3,4];">
  <ul ng-repeat="member in a">
    <li>{{ member }}</li>
  </ul>
</div>
```

### 节点控制

#### 样式 ng-style

可以使用一个结构直接表示当前节点的样式： 

```html
<div ng-style="{width: 100 + 'px', height: 100 + 'px', backgroundColor: 'red'}">
</div>
```

同样地，绑定一个变量的话，威力大了。 

#### 类 ng-class

就是直接地设置当前节点的(css)类，同样，配合数据绑定作用就大了： 

```html
<div ng-controller="TestCtrl" ng-class="cls"></div>
```

ng-class-even和ng-class-odd是和ng-repeat配合使用的： 

```html
<ul ng-init="l=[1,2,3,4]">
  <li ng-class-odd="'odd'" ng-class-even="'even'" ng-repeat="m in l">
    {{ m }}
  </li>
</ul>
```

注意里面给的还是表示式，别少了引号。

#### 显示和隐藏ng-show ng-hide ng-switch

前两个是控制display的指令： 

```html
<div ng-show="true">1</div>
<div ng-show="false">2</div>
<div ng-hide="true">3</div>
<div ng-hide="false">4</div>
```

后一个ng-switch是根据一个值来决定哪个节点显示，其它节点移除： 

```html
<div ng-init="a=2">
  <ul ng-switch on="a">
    <li ng-switch-when="1">1</li>
    <li ng-switch-when="2">2</li>
    <li ng-switch-default>other</li>
  </ul>
</div>
```

#### 其它属性控制

ng-src控制src属性：

```html
<img ng-src="{{ 'h' + 'ead.png' }}" />
```

ng-href控制href属性： 

```html
<a ng-href="{{ '#' + '123' }}">here</a>
```

总的来说： 

- ng-src src属性 
- ng-href href属性 
- ng-checked 选中状态 
- ng-selected 被选择状态 
- ng-disabled 禁用状态 
- ng-multiple 多选状态 
- ng-readonly 只读状态 

>注意：上面的这些只是单向绑定，即只是从数据到展示，不能反作用于数据。要双向绑定，还是要使用ng-model 。 

## 参考

Angular Module声明和获取重载：https://www.cnblogs.com/whitewolf/p/angular-module-declare-and-get.html

模块加载---config：http://blog.csdn.net/u014737138/article/details/50011051

angular.run和angular.config有什么不同？

这个就要理解ng自己的运行机制

config阶段是给了ng上下文一个针对constant与provider修改其内部属性的一个阶段
而run阶段是在config之后的在运行独立的代码块，通常写法runBlock
简单的说一下就是ng启动阶段是 config-->run-->compile/link

angularJS constant和value：https://www.cnblogs.com/lyy-2016/p/5691499.html

AngularJS 模块中的run方法

AngularJS中的run方法初始化全局数据，只对全局作用域起作用，如$rootScope.多个控制器之间可以共享数据，如下代码所示：

```html
<script type="text/javascript">    
  var m1 = angular.module('myApp',[]);  
  m1.run(['$rootScope', function($rootScope){  
    $rootScope.name = 'hello';  
  }]);    
  console.log(m1);  
</script>
```

http://blog.csdn.net/qq_27080247/article/details/50838038

深究AngularJS——自定义服务详解(factory、service、provider)：http://blog.csdn.net/zcl_love_wx/article/details/51404390

Controller

http://blog.csdn.net/lastsweetop/article/details/51190079
http://blog.csdn.net/ft6302244/article/details/42387839

- [ngx-admin](https://github.com/akveo/ngx-admin)：基于 Angular 8+ 和 [Nebular](https://github.com/akveo/nebular) 的管理模板
- [angular2-rxjs-chat](https://github.com/ng-book/angular2-rxjs-chat)：基于 Angular 2 的聊天小程序（网页版）
