# js总结

## 目录

1. Dom结构
   - [object](#object)
     - [wbbrowser](#wbbrowser)
       - 打印示例
     - [地理位置](#地理位置)
     - [历史记录管理](#历史记录管理)
     - [跨域消息传递](#跨域消息传递)
     - [Web Worker](#WebWorker)
   - [伪元素](#伪元素)
2. 函数
   - [call及apply](#call及apply)
   - [Function.prototype.bind](#Function.prototype.bind)
   - [document.execCommand](#document.execCommand)
3. 功能
   - [with](#with)
   - [异步](#异步)
   - [剪切板](#剪切板)
   - [动态加载JS和CSS](#动态加载JS和CSS)
   - [判断IE版本的HTML语句详解](#判断IE版本的HTML语句详解)
   - [让IE6/IE7/IE8支持CSS3属性的8种方法介绍](#让IE6/IE7/IE8支持CSS3属性的8种方法介绍)
4. 前端编程法
   - [流式编程](#流式编程)
     - 概念
       - [流式应用](#流式应用)
       - [瀑布流](#瀑布流)
       - [实时计算](#实时计算)
       - [流处理](#流处理)
     - 来源和结论
       - [页面结构](#页面结构)
       - [接口请求](#接口请求)
       - [优化顺序](#优化顺序)
     - 实例分析
       - [单接口情况](#单接口情况)
       - [多接口](#多接口)
       - [实时+触发](#实时+触发)
       - [复杂页面](#复杂页面)
   - [DOM操作成本到底高在哪儿](#DOM操作成本到底高在哪儿)
     - [什么是DOM？](#什么是DOM)
     - [浏览器渲染过程](#浏览器渲染过程)

## with

**简要说明：**

with语句可以方便地用来引用某个特定对象中已有的属性，但是不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。  

**语法格式：**

```js
with(object instance) {
  //代码块  
}
```

有时候，我在一个程序代码中，多次需要使用某对象的属性或方法，照以前的写法，都是通过 `对象.属性` 或者 `对象.方法` 这样的方式来分别获得该对象的属性和方法，着实有点麻烦，学习了with语句后，可以通过类似如下的方式来实现：

```js
with(objInstance) {
  var str = 属性1;
  .....  
}
```

去除了多次写对象名的麻烦。

**举例：**

```html
<script language="javascript">  
<!--  
function Lakers() {  
  this.name = "kobe bryant";  
  this.age = "28";  
  this.gender = "boy";  
}  
var people=new Lakers();  
with(people) {  
  var str = "姓名: " + name + "<br>";  
  str += "年龄：" + age + "<br>";  
  str += "性别：" + gender;  
  document.write(str);  
}  
//-->  
</script>
```

代码执行效果如下:  

```sh
姓名: kobe bryant  
年龄：28  
性别：boy
```

## 异步

JavaScript是单线程执行的，无法同时执行多段代码。当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列。一旦当前任务执行完毕，再从队列中取出下一个任务，这也常被称为 “阻塞式执行”。

所以一次鼠标点击，或是计时器到达时间点，或是Ajax请求完成触发了回调函数，这些事件处理程序或回调函数都不会立即运行，而是立即排队，一旦线程有空闲就执行。

假如当前 JavaScript 线程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行。

如果代码中设定了一个 setTimeout，那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕。所以 setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。

1、回调函数

```js
function f1 (callback) {
  console.log('f1');
  setTimeout(function () {
    // f1的任务代码
    callback();
  }, 1000);
}
function f2 () {
  console.log('f2');
}
```

回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合(Coupling)，流程会很混乱，而且每个任务只能指定一个回调函数。

2、事件监听

```js
f1.on('done', f2);
function f1 () {
  setTimeout(function () {
    // f1的任务代码
    f1.trigger('done');
  }, 1000);
}
```

任务的执行不取决于代码的顺序，而取决于某个事件是否发生。还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。

`f1.trigger('done')`表示，执行完成后，立即触发done事件，从而开始执行f2。

这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”(Decoupling)，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。

3、发布/订阅

```js
jQuery.subscribe("done", f2);
function f1 () {
  setTimeout(function () {
    // f1的任务代码
    jQuery.publish("done");
  }, 1000);
}
jQuery.unsubscribe("done", f2); // f2完成后可以取消订阅
```

上一节的“事件”，完全可以理解成“信号”。

我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”(publish)一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执行。这就叫做“发布/订阅模式”(publish-subscribe pattern），又称“观察者模式”(observer pattern)。

这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件。

首先，f2向“信号中心”jQuery订阅"done"信号。

然后，改写f1，`jQuery.publish("done")` 的意思是，f1执行完成后，向“信号中心”jQuery发布 "done" 信号，从而引发f2的执行。

此外，f2完成执行后，也可以取消订阅(unsubscribe)。

这种方法的性质与“事件监听”类似，但是明显优于后者。因为我们可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

4、Promises对象

```js
function f1 () {
  var dfd = $.Deferred();
  setTimeout(function () {
    // f1的任务代码
    dfd.resolve();
  }, 500);
  return dfd.promise;
}
f1().then(f2);
f1().then(f2).then(f3); // 指定多个回调函数
f1().then(f2).fail(f3); // 指定发生错误时的回调函数
```

Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。

简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。

f1要进行改写（这里使用的是jQuery的实现）

这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。

而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。

## 剪切板

IE浏览器支持直接读写剪切板内容：

```js
window.clipboardData.clearData();  
window.clipboardData.setData('Text', 'abcd');
```

chrome/Firefox

```js
// 覆盖浏览器粘贴事件
document.addEventListener('paste', function (e) {
    var clipboardData = e.clipboardData;
    if (!(clipboardData && clipboardData.items)) {//是否有粘贴内容
        return;
    }
    for (var i = 0, len = clipboardData.items.length; i < len; i++) {
        var item = clipboardData.items[i];
        if (item.kind === "string" && item.type == "text/plain") {
            item.getAsString(function (str) {
                // str 是获取到的字符串,创建文本框
                //处理粘贴的文字内容
            })
        } else if (item.kind === "file") {//file 一般是各种截图base64数据
            var pasteFile = item.getAsFile();
            // pasteFile就是获取到的文件
            var reader = new FileReader();
            reader.onload = function (event) {
                var base64Img = event.target.result;
            }; // data url  
            reader.readAsDataURL(pasteFile);
        }
        var copy_content = e.clipboardData.getData('text/plain');
    }
})

// 写入系统剪切板，实测无效
e.clipboardData.setData('text/plain', defaultText);

// 1) 监听copy事件，触发copy命令
document.addEventListener("paste", function (e) {
    console.log(e.clipboardData.getData("text"));
});
document.onkeydown = function (e) {
    if (e.ctrlKey && e.keyCode == 67) {//ctrl+C
        function handler(event) {
            event.clipboardData.setData('text/plain', "自定义复制内容");
            document.removeEventListener('copy', handler, true);
            event.preventDefault();
        }
        document.addEventListener('copy', handler, true);
        document.execCommand('copy');
    }
}

// 2）通过将需要复制的内容赋值到文本中，将文本框内容选中，执行copy命令
// 复制  
document.onkeydown = function (e) {
    if (e.ctrlKey && e.keyCode == 86) {//ctrl+V
        var cloneActiveElement = "需要复制的内容";
        var copyText = document.getElementById("copy_text");
        copyText.innerHTML = cloneActiveElement;
        copyText.readOnly = false;
        copyText.select();
        copyText.setSelectionRange(0, copyText.value.length);
        document.execCommand("copy");
        copyText.readOnly = true;
    }
}

// 事件触发
if ("createEvent" in document) {
    var evt = document.createEvent("HTMLEvents");
    evt.initEvent("paste", false, true);
    element.dispatchEvent(evt);
} else {
    element.fireEvent("onchange");
}
```

## 伪元素

虽然标题里写的是伪元素,不过这篇文章主要是说::before和::after，其余几个伪元素（::first-letter、::first-line、::selection等)由于没有content属性，所以本文一笔带过，其实方法是一样的。

伪元素的重点在于一个**伪**，虽然它们可以被浏览器渲染引擎识别并正确渲染，然而<b style="color:red">伪元素本身并不是DOM元素</b>,所以无法被js直接操作——因此任何基于JS直接选取DOM元素的CSS更改方法对伪元素都不起作用。（JQ看似万能，这个问题上是直接就栽了。因为JQ的选择符都是基于DOM元素）关于JS和JQ选择器，可以参考这两篇文档：[Selectors API Level 1](http://www.w3.org/TR/selectors-api/)、[jQuery Selectors](http://api.jquery.com/category/selectors/)

### 获取伪元素的属性值

- `window.getComputedStyle`

  ```js
  var div=document.querySelector('div');
  var fontSize=window.getComputedStyle(div,'::before').getPropertyValue('font-size');//获取before伪元素的字号大小
  ```

  关于这个方法，详解可以参考这篇文章：[获取元素CSS值之getComputedStyle方法熟悉](http://www.zhangxinxu.com/wordpress/2012/05/getcomputedstyle-js-getpropertyvalue-currentstyle/)

### 更改伪元素的属性值

1. js更改data-*属性值来更改伪元素的content值
2. 创建多个class，通过切换class来达到改变样式的目的
3. 利用CSSStyleSheet的insertRule方法来添加样式
4. 利用内部css样式的高优先级来覆盖外部css
  
以上实现思路的推荐程度***依次递减***

data-*是HTML5新增的DOM元素属性，作用大致可以理解为标记。具体用法可以参考MDN的这篇文章.而伪元素的content属性值除了常规赋值外，还有一种特殊的attr()方法来获取。

html:

```html
<div class="test" data-text="TEXT" data-color="red"></div>
```

css:

```css
.test::before{
    content: attr(data-text);
}
```

结果：

```sh
TEXT
```

另外content其实可以多个attr连写，而且attr()内的可以是DOM元素的任意属性（比如class等，甚至非W3C标准属性也支持，不过不推荐这么做)所以很方便凑一些模版文字。像下面这种写法也是完全没问题的。***注意用空格连接，不要用"+"号***。

```css
.test::before {
  content: '我的类是' attr(class) '想要变成' attr(data-color);
}
```

虽然W3C给attr()赋予了[无限可能性](http://www.w3.org/TR/css3-values/#attr-notation)，包括color,width等属性在未来都有希望用这个方法更改，然而**目前只有`content`支持该方法**，其余的都还是草稿状态，尚未有浏览器支持。之所以把这个方法放在第一位只是因为相比别的实现手法来说，这个方法真的太简单太优雅。

### 更改class来实现伪元素样式的更改

class切换大法，不适合多状态的场景（比如实时改变伪元素文字大小等）

### 利用CSSStyleSheet的insertRule方法来添加样式

CSSStyleSheet是浏览器存放页面内所有css样式表的对象方法（不包括行内样式)，每个link和style标签都代表一个CSSStyleSheet对象，获取他们可以用document.styleSheets方法。(需要注意的是虽然styleSheets方法返回的结果把link标签引进的外部样式也算进去了，但是非IE浏览器没办法获取到他们的cssRules属性，只有内嵌的style标签内的元素可以被获取到)

```js
document.styleSheets[0].insertRule('.test::before{color:green}',0)//chrome,firefox等非IE浏览器使用
document.styleSheets[0].addRule('.test::before{color:green}',0)//IE系列浏览器使用
/* 虽然部分浏览器也可以通过id来指定,'document.styleSheets.id.insertRule()'这种写法在chrome和IE下都行得通，但是firefox会返回'undefined',所以建议还是使用index值来获取stylesheet */
```

.insertRule的语法是stylesheet.insertRule(rule, index),另一个参数是index，意思是在对应的styleSheets里的cssRules样式表中的位置，这个值越大则样式优先级越高，但是值不能超过当前样式表规则（cssRules）长度（CSS中先定义的样式总是会被后定义的覆盖就是这个缘故。），当值小于cssRules长度时，添加的样式规则会插入到index值定义的位置，之前其余的规则依次顺延。

>addrule和insertRule方法本质上没区别，只是后者不被IE浏览器识别，所以前者作为浏览器兼容方法存在。

上面的代码看似简单一行，然而却不是每次都有效的。原因有以下几点：

1. document.styleSheets虽然按照style和link的顺序返回对应的StyleSheetList，然而第一个如果是link而不是style,前面讲过此时无法获取对应的cssRules，则document.styleSheets[0].cssRules为null，insertRule方法不起作用。（此情况只针对非IE浏览器，IE浏览器正常，但是定义的早往往意味着被后面的样式覆盖，所以意义不大）
2. 同上，如果页面内没有内嵌样式的style标签，则insertRule方法也无法发挥作用。
3. index值不够大的话很有可能会早于css文件开始的定义位置，导致被覆盖。因此有个折衷办法就是给添加的样式增加!important，虽然我个人比较反感这么做。

由此可见此方法的局限性，但是这种方法的优雅之处在于避免了直接写内嵌样式，而是通过css api来做更改。相比下面的方法来说，稍微好点。

### HEAD中添加style标签强制覆盖初始属性

这个方法是利用内部css样式的高优先级来覆盖外部css，好处是简单易理解，实现简单。坏处就是吃相太难看，过于粗暴。

```js
var style=document.createElement('style');
style.innerHTML=".test::before{color:green}";//添加样式内容的话也可以用上面提到过的`insertRule`,相对例子里的硬编码会更优雅点。
document.head.appendChild(style);
```

看到这里可能有些人反应过来了，其实加style标签这种方法可以是insertRule实现方法的大前提——因为不是所有页面一开始都有内嵌的style样式的。这种方法虽然不是很好，但是有时候却又确确实实是必须的——比如“拖动滑块改变伪元素内文字大小”这个需求。

### 练习

功能需求：

1. 拖动滑块改变伪元素内的文字大小
2. 且伪元素内随时显示当前字号
3. 通过一个按钮可以改变伪元素内文字颜色

这个需求可以将本文前面提到的四种改变伪元素样式的方法都塞进去。具体实现参照[DEMO](http://codepen.io/chitanda/pen/OVBJEw/)，不再做具体分析。

## call及apply

call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在 `定义时上下文` 和 `运行时上下文` 以及 `上下文是可以改变的` 这样的概念。

二者的作用完全一样，只是接受参数的方式不太一样。例如，有一个函数 func1 定义如下：

```js
var func1 = function(arg1, arg2) {};
```

就可以通过 `func1.call(this, arg1, arg2);` 或者 `func1.apply(this, [arg1, arg2]);` 来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象（JavaScript 中一切皆对象），call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。

JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时，用 call；而不确定的时候，用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。

要先明白存在call和apply的原因，才能记得牢一点：

在javascript OOP中，我们经常会这样定义：

```js
function cat(){
}
cat.prototype={
  food:"fish",
  say: function(){
    alert("I love "+this.food);
  }
}
var blackCat = new cat;
blackCat.say();
```

但是如果我们有一个对象`whiteDog = {food:"bone"}`，我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 blackCat 的 say 方法：`blackCat.say.call(whiteDog);`

所以，可以看出call和apply是为了动态改变 `this` 而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。

用的比较多的，通过 `document.getElementsByTagName` 选择的 dom 节点是一种类似 array 的 array。它不能应用 Array 下的 `push`, `pop` 等方法。我们可以通过：

```js
var domNodes = Array.prototype.slice.call(document.getElementsByTagName("*"));

```

这样domNodes就可以应用Array下的所有方法了。

如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj

Global: 全局属性和函数可用于所有内建的 JavaScript 对象。

你需要明白 IIFE 的原理，我简单说一下：

```js
// 这是定义，Declaration；定义只是让解释器知道其存在，但是不会运行。
function foo() {...}
// 这是语句，Statement；解释器遇到语句是会运行它的。
foo();
```

IIFE 并非必须，那么为什么要 IIFE？

1. 传统的方法啰嗦，定义和执行分开写；
2. 传统的方法直接污染全局命名空间（浏览器里的 global 对象，如 window）

于是，开发者们想找一个可以解决以上问题的写法。那么像下面这么写行不行呢？

```js
function foo(...){}();
```

当然是不能，但是为什么呢？因为 `function foo(...){}` 这个部分只是一个声明，对于解释器来说，就好像你写了一个字符串 "function foo(...){}"，它需要使用解析函数，比如 eval() 来执行它才可以。所以把 () 直接放在声明后面是不会执行，这是错误的语法。

如何把它变得正确？说起来也简单，只要把 `声明` 变成 `表达式(Expression)` 就可以了。

实际上转变表达式的办法还是很多的，最常见的办法是把函数声明用一对 () 包裹起来，于是就变成了：

```js
(function foo() {...})();
```

这就等价于：

```js
var foo = function () {...}; // 这就不是定义，而是表达式了。
foo();
```

但是之前我们说不行的那个写法，其实也可以直接用括号包起来，这也是一种等价的表达式：

```js
(function foo(){...}());
```

所以你问有没有区别？很简单：木有～另外，刚才说过转变表达式的方式很多，的确还有很多别的写法，比如：

```js
!function foo() {...}();
```

或者

```js
+function foo() {...}();
```

这些都可以。我个人挺偏爱用 void 来转变表达式，因为此关键字不会有返回值。不过这一点真的没有什么要紧的……

```js
void function () {
  // 这里是真正需要的代码
}();
```

OK，所谓不去污染全局命名空间，是因为 IIFE 创建了一个新的`函数作用域`，你真正的业务代码被封装在其中，自然就不会触碰到全局对象了。如果你需要全局对象，那就 pass 给 IIFE：

```js
void function (global) {
  // 在这里，global 就是全局对象了
}(this) // 在浏览器里，this 就是 window 对象
```

## Function.prototype.bind

在初学Javascript时，我们也许不需要担心函数绑定的问题。但是当我们需要在另一个函数中保持上下文对象this时，就会遇到相应的问题了。

我见过很多人处理这种问题都是先将this赋值给一个变量（比如self、_this、that等），尤其是var that = this是我见的最多的。这样当你改变环境之后就可以使用它。这些都是可以的，但是还有一种更好的、更专有的方法，那就是使用`Function.prototype.bind`。下面进行详尽的讲解。

### 第一部分：需要解决的问题

首先看下面的代码：

```js
var myObj = {
  specialFunction: function () {},
  anotherSpecialFunction: function () {},
  getAsyncData: function (cb) {
    cb();
  },
  render: function () {
    this.getAsyncData(function () {
      this.specialFunction();
      this.anotherSpecialFunction();
    });
  }
};

myObj.render();
```

这里我希望创建一个对象。包含了前面两个普通的方法；第三个方法可以传递一个函数，传入的这个函数立即执行。最后一个方法会调用myObj对象的getAsyncData方法，这里使用了this。然后在getAsyncData方法中传入了一个函数，这个函数继续调用这个对象的前两个方法，仍使用了this。这时很多人实际上就可以看出问题所在了，将上述代码输入控制台，得到下面的结果：

```sh
TypeError: this.specialFunction is not a function
```

### 第二部分：问题剖析

- 在对象中render方法中的this的确是指向myObj对象的，所以我们可以通过this.getAsyncData来调用这个对象中的函数。
- 但是当我们给其传递函数作为参数时，这里的this就指向了全局环境window了，因为全局环境中没有对象中的前两个方法，所以才会报错。

### 第三部分：解决问题的几种方式

所以我们需要做的就是正确调用对象中的前两个方法 ，很多人使用的方法便是：

- 首先在对象的环境中获取this赋值给另一个变量，这时就可以在后面的环境中调用了，如下所示：

  ```js
  render: function () {
    var that = this;
    this.getAsyncData(function () {
      that.specialFunction();
      that.anotherSpecialFunction();
    });
  }
  ```

  虽然这种方法是可行的。但是使用Function.prototype.bind()会使代码更清晰、易懂，如下所示：

  ```js
  render: function () {
    this.getAsyncData(function () {
      this.specialFunction();
      this.anotherSpecialFunction();
    }.bind(this));
  }
  ```

  这里我们就成功地把this绑定到了环境中。下面是另外一个简单的例子：

  ```js
  var foo = { x: 3 }

  var bar = function () {
    console.log(this.x);
  }

  bar(); // undefined

  var boundFunc = bar.bind(foo);
  boundFunc(); // 3
  ```

  下面的例子也是常见的：

  ```js
  this.x = 9; // this refers to global "window" object here in the browser

  var module = {
    x: 81,
    getX: function() { return this.x; }
  };
  module.getX(); // 81

  var retrieveX = module.getX;
  retrieveX();
  // returns 9 - The function gets invoked at the global scope
  // Create a new function with 'this' bound to module
  // New programmers might confuse the
  // global var x with module's property x
  var boundGetX = retrieveX.bind(module);
  boundGetX(); // 81
  ```

  如果有兴趣想知道 `Function.prototype.bind()` 内部长什么样以及是如何工作的，这里有个非常简单的例子：

  ```js
  Function.prototype.bind = function (scope) {
    var fn = this;
    return function () {
      return fn.apply(scope);
    };
  }
  ```

### 第四部分：浏览器支持

但是这个方法在IE8及以下是不被支持的，所以我们可以使用MDN提供的方法来使得IE低版本支持.bind()方法：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
      fToBind = this,
      fNOP = function () { },
      fBound = function () {
        return fToBind.apply(this instanceof fNOP && oThis
          ? this
          : oThis,
          aArgs.concat(Array.prototype.slice.call(arguments)));
      };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
  };
}
```

## document.execCommand

document.execCommand()方法处理Html数据时常用语法格式如下:

```js
document.execCommand(sCommand [, 交互方式, 动态参数])
```

其中：sCommand为指令参数（如下例中的"2D-Position"），交互方式参数如果是true的话将显示对话框，如果为false的话，则不显示对话框（下例中的"false"即表示不显示对话框），动态参数一般为一可用值或属性值（如下例中的"true"）。

```js
document.execCommand("2D-Position", "false", "true");
```

调用execCommand()可以实现浏览器菜单的很多功能。如保存文件、打开新文件、撤消、重做操作…等等。有了这个方法，就可以很容易的实现网页中的文本编辑器。使用的例子如下：

1、【全选】命令的实现

```js
格式：document.execCommand("selectAll")
说明：将选种网页中的全部内容！
```

2、【打开】命令的实现

```js
格式：document.execCommand("open")
说明：这跟VB等编程设计中的webbrowser控件中的命令有些相似，大家也可依此琢磨琢磨。
```

3、【另存为】命令的实现

```js
格式：document.execCommand("saveAs")
说明：将该网页保存到本地盘的其它目录！
```

4、【打印】命令的实现

```js
格式：document.execCommand("print")
说明：当然，你必须装了打印机！
```

**下面列出的是指令参数及意义：**

```js
//相当于单击文件中的打开按钮
document.execCommand("Open");
//将当前页面另存为
document.execCommand("SaveAs");
//剪贴选中的文字到剪贴板;
document.execCommand("Cut", "false" ,null);
//删除选中的文字;
document.execCommand("Delete", "false", null);
//改变选中区域的字体;
document.execCommand("FontName", "false", sFontName);
//改变选中区域的字体大小;
document.execCommand("FontSize", "false", sSize|iSize);
//设置前景颜色;
document.execCommand("ForeColor", "false", sColor);
//使绝对定位的对象可直接拖动;
document.execCommand("2D-Position", "false", "true");
//使对象定位变成绝对定位;
document.execCommand("AbsolutePosition", "false", "true");
//设置背景颜色;
document.execCommand("BackColor", "false", sColor);
//使选中区域的文字加粗;
document.execCommand("Bold", "false", null);
//复制选中的文字到剪贴板;
document.execCommand("Copy", "false", null);
//设置指定锚点为书签;
document.execCommand("CreateBookmark", "false", sAnchorName);
//将选中文本变成超连接,若第二个参数为true,会出现参数设置对话框;
document.execCommand("CreateLink", "false", sLinkURL);
//设置当前块的标签名;
document.execCommand("FormatBlock", "false", sTagName);
```

document对象execCommand通常在IE中在线处理Html数据时非常有用，它可以让你轻而易举实现文字的加粗、加颜色、加字体等一系列的命令。

- D-Position 允许通过拖曳移动绝对定位的对象。
- AbsolutePosition 设定元素的 position 属性为"absolute"（绝对）。
- BackColor 设置或获取当前选中区的背景颜色。
- BlockDirLTR 目前尚未支持。
- BlockDirRTL 目前尚未支持。
- Bold 切换当前选中区的粗体显示与否。
- BrowseMode 目前尚未支持。
- Copy 将当前选中区复制到剪贴板。
- CreateBookmark 创建一个书签锚或获取当前选中区或插入点的书签锚的名称。
- CreateLink 在当前选中区上插入超级链接，或显示一个对话框允许用户指定要为当前选中区插入的超级链接的 URL。
- Cut 将当前选中区复制到剪贴板并删除之。
- Delete 删除当前选中区。
- DirLTR 目前尚未支持。
- DirRTL 目前尚未支持。
- EditMode 目前尚未支持。
- FontName 设置或获取当前选中区的字体。
- FontSize 设置或获取当前选中区的字体大小。
- ForeColor 设置或获取当前选中区的前景（文本）颜色。
- FormatBlock 设置当前块格式化标签。
- Indent 增加选中文本的缩进。
- InlineDirLTR 目前尚未支持。
- InlineDirRTL 目前尚未支持。
- InsertButton 用按钮控件覆盖当前选中区。
- InsertFieldset 用方框覆盖当前选中区。
- InsertHorizontalRule 用水平线覆盖当前选中区。
- InsertIFrame 用内嵌框架覆盖当前选中区。
- InsertImage 用图像覆盖当前选中区。
- InsertInputButton 用按钮控件覆盖当前选中区。
- InsertInputCheckbox 用复选框控件覆盖当前选中区。
- InsertInputFileUpload 用文件上载控件覆盖当前选中区。
- InsertInputHidden 插入隐藏控件覆盖当前选中区。
- InsertInputImage 用图像控件覆盖当前选中区。
- InsertInputPassword 用密码控件覆盖当前选中区。
- InsertInputRadio 用单选钮控件覆盖当前选中区。
- InsertInputReset 用重置控件覆盖当前选中区。
- InsertInputSubmit 用提交控件覆盖当前选中区。
- InsertInputText 用文本控件覆盖当前选中区。
- InsertMarquee 用空字幕覆盖当前选中区。
- InsertOrderedList 切换当前选中区是编号列表还是常规格式化块。
- InsertParagraph 用换行覆盖当前选中区。
- InsertSelectDropdown 用下拉框控件覆盖当前选中区。
- InsertSelectListbox 用列表框控件覆盖当前选中区。
- InsertTextArea 用多行文本输入控件覆盖当前选中区。
- InsertUnorderedList 切换当前选中区是项目符号列表还是常规格式化块。
- Italic 切换当前选中区斜体显示与否。
- JustifyCenter 将当前选中区在所在格式化块置中。
- JustifyFull 目前尚未支持。
- JustifyLeft 将当前选中区所在格式化块左对齐。
- JustifyNone 目前尚未支持。
- JustifyRight 将当前选中区所在格式化块右对齐。
- LiveResize 迫使 MSHTML 编辑器在缩放或移动过程中持续更新元素外观，而不是只在移动或缩放完成后更新。
- MultipleSelection 允许当用户按住 Shift 或 Ctrl 键时一次选中多于一个站点可选元素。
- Open 目前尚未支持。
- Outdent 减少选中区所在格式化块的缩进。
- OverWrite 切换文本状态的插入和覆盖。
- Paste 用剪贴板内容覆盖当前选中区。
- PlayImage 目前尚未支持。
- Print 打开打印对话框以便用户可以打印当前页。
- Redo 目前尚未支持。
- Refresh 刷新当前文档。
- RemoveFormat 从当前选中区中删除格式化标签。
- RemoveParaFormat 目前尚未支持。
- SaveAs 将当前 Web 页面保存为文件。
- SelectAll 选中整个文档。
- SizeToControl 目前尚未支持。
- SizeToControlHeight 目前尚未支持。
- SizeToControlWidth 目前尚未支持。
- Stop 目前尚未支持。
- StopImage 目前尚未支持。
- StrikeThrough 目前尚未支持。
- Subscript 目前尚未支持。
- Superscript 目前尚未支持。
- UnBookmark 从当前选中区中删除全部书签。
- Underline 切换当前选中区的下划线显示与否。
- Undo 目前尚未支持。
- Unlink 从当前选中区中删除全部超级链接。
- Unselect 清除当前选中区的选中状态。

```html
// 最后更新时间
<script>document.lastModified</script>

// 2秒后载入指定网页
<meta http-equiv="refresh" content="2;URL=http://你的网址">

// 添加到收藏夹
<script Language="Javascript">
function bookmarkit() {
  window.external.addFavorite('http://你的网址', '你的网站名称');
}
if (document.all)
  document.write('<a href="#" onClick="bookmarkit()">加入收藏夹</a>');
</script>

// 禁止鼠标右键的动作
<script Language = "Javascript">
function click() {
  if (event.button==2 || event.button==3) {
　　alert('禁止鼠标右键');
　}
}
document.onmousedown=click
</script>
```

## 动态加载JS和CSS

1、直接document.write

```html
<script language="javascript">
  document.write("<script src='test.js'><\/script>");
</script>
```

2、动态改变已有script的src属性

```html
<script src='' id="s1"></script>
<script language="javascript">
  s1.src="test.js"
</script>
```

3、动态创建script元素

```html
<script>
  var oHead = document.getElementsByTagName('head').item(0);
  var oScript= document.createElement("script");
  oScript.type = "text/javascript";
  oScript.src="test.js";
  oHead.appendChild( oScript);
</script>
```

4、原理：用 `XMLHTTP` 取得脚本的内容，再创建 `Script` 对象。

>注意：a.js必须用UTF8编码保存，要不会出错。因为服务器与XML使用UTF8编码传送数据。

主页面代码：

```html
<script language="JavaScript">
function GetHttpRequest() {
  if (window.XMLHttpRequest) //Gecko
    return new XMLHttpRequest() ;
  else if (window.ActiveXObject) //IE
    return new ActiveXObject("MsXml2.XmlHttp") ;
}

function AjaxPage(sId, url){
  var oXmlHttp = GetHttpRequest();
  oXmlHttp.OnReadyStateChange = function() {
    if (oXmlHttp.readyState == 4) {
      if (oXmlHttp.status == 200 || oXmlHttp.status == 304) {
        IncludeJS(sId, url, oXmlHttp.responseText);
      } else {
        alert('XML request error: ' + oXmlHttp.statusText + ' (' + oXmlHttp.status + ')') ;
      }
    }
  }
  oXmlHttp.open('GET', url, true);
  oXmlHttp.send(null);
}

function IncludeJS(sId, fileUrl, source) {
  if (source != null && !document.getElementById(sId)){
    var oHead = document.getElementsByTagName('head').item(0);
    var oScript = document.createElement("script");
    oScript.language = "javascript";
    oScript.type = "text/javascript";
    oScript.id = sId;
    oScript.defer = true;
    oScript.text = source;
    oHead.appendChild(oScript);
  }
}

AjaxPage("srcA", "b.js");

// 动态加载css文件
function loadStyles(url) {
  var link = document.createElement("link");
  link.type = "text/css";
  link.rel = "stylesheet";
  link.href = url;
  document.getElementsByTagName("head")[0].appendChild(link);
}
// 测试
loadStyles("css/secondindex.css");

// 动态加载css脚本
function loadStyleString(cssText) {
  var style = document.createElement("style");
  style.type = "text/css";
  try{
    // firefox、safari、chrome和Opera
    style.appendChild(document.createTextNode(cssText));
  }catch(ex) {
    // IE早期的浏览器，需要使用style元素的stylesheet属性的cssText属性
    style.styleSheet.cssText = cssText;
  }
  document.getElementsByTagName("head")[0].appendChild(style);
}

// 测试
var css = "body{color:blue;}";
loadStyleString(css);
</script>
```

## 判断IE版本的HTML语句详解

我们常常会在网页的HTML里面看到形如 `[if lte IE 9]……[endif]` 的代码，表示的是限定某些浏览器版本才能执行的语句，那么这些判断语句的规则是什么呢？请看下文：

```html
<!--[if !IE]><!--> 除IE外都可识别 <!--<![endif]-->
<!--[if IE]> 所有的IE可识别 <![endif]-->
<!--[if IE 6]> 仅IE6可识别 <![endif]-->
<!--[if lt IE 6]> IE6以及IE6以下版本可识别 <![endif]-->
<!--[if gte IE 6]> IE6以及IE6以上版本可识别 <![endif]-->
<!--[if IE 7]> 仅IE7可识别 <![endif]-->
<!--[if lt IE 7]> IE7以及IE7以下版本可识别 <![endif]-->
<!--[if gte IE 7]> IE7以及IE7以上版本可识别 <![endif]-->
<!--[if IE 8]> 仅IE8可识别 <![endif]-->
<!--[if IE 9]> 仅IE9可识别 <![endif]-->
```

项目|范例|说明
-|-|-
!|[if !IE]|The NOT operator. This is placed immediately in front of the feature, operator, or subexpression to reverse the Boolean meaning of the expression.
lt|[if lt IE 5.5]|The less-than operator. Returns true if the first argument is less than the second argument.
lte|[if lte IE 6]|The less-than or equal operator. Returns true if the first argument is less than or equal to the second argument.
gt|[if gt IE 5]|The greater-than operator. Returns true if the first argument is greater than the second argument.
gte|[if gte IE 7]|The greater-than or equal operator. Returns true if the first argument is greater than or equal to the second argument.
( )|[if !(IE 7)]|Subexpression operators. Used in conjunction with boolean operators to create more complex expressions.
&|[if (gt IE 5)&(lt IE 7)]|The AND operator. Returns true if all subexpressions evaluate to true.
\||[if (IE 6)\|(IE 7)]|The OR operator. Returns true if any of the subexpressions evaluates to true.

```html
<!--[if lt IE 9]>
  加载CSS1
<!--[else]>
  加载CSS2
<![endif]-->
```

这样有效是有效，但是用HTML VALIDATOR，报错。因为这个不符合XHTML 1.1的规范。如果把ELSE语句去掉，则正确。

```html
加载CSS2
<!--[if lt IE 9]>
  加载CSS1(可以把要重写的写在这里).
<![endif]-->
```

用法：可使用如下代码检测当前IE浏览器的版本（注意：在非IE浏览器中是看不到效果的）

```html
<!––[if IE]>
  <h1>您正在使用IE浏览器</h1>
  <!––[if IE 5]>
    <h2>版本 5</h2>
  <![endif]––>
  <!––[if IE 5.0]>
    <h2>版本 5.0</h2>
  <![endif]––>
  <!––[if IE 5.5]>
    <h2>版本 5.5</h2>
  <![endif]––>
  <!––[if IE 6]>
    <h2>版本 6</h2>
  <![endif]––>
  <!––[if IE 7]>
    <h2>版本 7</h2>
  <![endif]––>
<![endif]––>
```

那如果当前的浏览器是IE，但版本比IE5还低，该怎么办呢，可以使用`<!–[if ls IE 5]>`，当然，根据条件注释只能在IE5+的环境之下，所以`<!–[if ls IE 5]>`根本不会被执行。

- lte：就是Less than or equal to的简写，也就是小于或等于的意思。
- lt：就是Less than的简写，也就是小于的意思。
- gte：就是Greater than or equal to的简写，也就是大于或等于的意思。
- gt：就是Greater than的简写，也就是大于的意思。
- !：就是不等于的意思，跟javascript里的不等于判断符相同

## 让IE6/IE7/IE8支持CSS3属性的8种方法介绍

我们都知道，IE浏览器暂不支持CSS3的一些属性。国外的工程师们，不安于此现状，他们总是尽量使用一些手段使IE浏览器也能支持CSS3属性，我觉得这些都是很有意义，很有价值的工作，可以推动整个技术领域的进步的。到目前为止，有不少可以让IE支持部分CSS3属性的工具。例如：

1. Dean Edwards的IE7.js (以及 IE8.js, IE9.js)

   这个玩意估计是试图让IE支持CSS3属性的鼻祖，还算蛮强大，就是性能开销较大，要解析很多文件脚本，给DOM添加大量的元素以及ClassName。

2. Aaron Gustafson的 eCSStender

   此方法支持@font-face, CSS3 选择器, 以及 CSS3 Backgrounds 和 Borders。

3. Drew Diller的 DD_roundies

   这是一个基于IE VML实现一些CSS3效果的。

4. Remiz Rahnas的border-radius.htc

   此方法使用htc文件，配合VML实现，缺点在于不能自动适应目标元素的位置和大小，所以不能适用于动态脚本环境。

5. Nick Fetchak的 ie-css3.htc

   关于此方法，我在前面的“让IE6/IE7/IE8浏览器支持CSS3属性”这篇文章中已经做过介绍。我是建议您看看这篇文章，倒不是ie-css3.htc这个玩意多么好，而是文中对htc文件以及VML预言做了些介绍，对于您了解IE下实现类似CSS3效果原理有所了解。

6. Keith Clark的ie-css3.js

   这是个与IE7.js类似的项目，其选择器可借助其他JavaScript库，所以其本身较小。

7. zoltandulac的cssSandpaper

   这是一个使用IE滤镜实现一些CSS3属性的方法。

8. css3pie的css3 PIE.htc

   支持：border-radius圆角 、 box-shadow 盒阴影 、 gradient渐变 、 multiple background images多背景 。

下面对第8种方法的做一下简单介绍：

- 官方网站：[http://css3pie.com/](http://css3pie.com/)

使用方法：

- 第一步：下载css3 PIE.htc 文件
- 第二步：将PIE.htc文件上传到你的网站目录中，上传到目录哪里都可以，只要你记住这个目录。
- 第三步：创建html文件，写一段css3代码，并引入PIE.htc，如下面这段：

  ```css
  #id {
       border: 1px solid #999;
       -webkit-border-radius: 10px;
       -moz-border-radius: 10px;
       border-radius: 10px;
       behavior: url(path/to/PIE.htc);
  }
  ```

>注意：.htc 文件路径是相对于html文件的路径，而不是相对于css文件。已知的一些问题：此方法并不是万能的，也有一些局限性和需要注意的地方。

1. z-index相关问题

   IE下这些CSS3效果实现是借助于VML，由VML绘制圆角或是投影效果的容器元素，然后这个容器元素作为目标元素的后兄弟节点插入，如果目标元素position:absolute 或是 position:relative，则这个css3-container元素将会设置与之一样的z-index值，在DOM tree中，同级的元素总是后面的覆盖前面的，所以这样就实现了覆盖，又避免了可能有其他元素正好插入其中。

   所以，问题来了，如果目前元素的position属性为static，也就是默认属性，则z-index属性是没有用的，无覆盖可言，所以此时IE浏览器下CSS3的渲染是不会成功的。要解决也很简单，设置目标元素position:relative或是设置祖先元素position:relative并赋予一个z-index值（不可为-1）。

2. 相当路径的问题

   IE浏览器的behavior 属性是相对于HTML文档而言的，与CSS其他的属性不一样，不是相对于CSS文档而言的。这使得使用pie.htc文件不怎么方便。如果绝对路径于根目录，则CSS文件不方便移动；如果相对路径与HTML文档，则pie.htc文件在不同HTML页面见的重用性大大降低。同时，诸如border-image后面的URL属性路径也不好处理。

3. 缩写的问题

   使用PIE实现IE下的CSS3渲染（其他方法也是一样），只能使用缩写的形式，例如圆角效果，我们可以设置border-top-left-radius表示左上圆角，但是PIE确实不支持这种写法的，只能是老老实实的缩写。

4. 提供正确的Content-Type

   要想让IE浏览器支持htc文件，需要一个有着"text/x-component" 字样的content-type 头部，否则，会忽视behavior。绝大数web服务器提供了正确的content-type，但是还有一部分则有问题。

   如果您发现在您的机子上PIE方法无效，也就是htc文件这里指pie.htc文件无效，检查您的服务器配置，可能其需要更新到最新的content-type。例如对于Apache，您可以在.htaccess文件中做如下处理：

   ```txt
   AddType text/x-component .htc
   ```

   但是，由于某种原因，您无法修改服务器配置（例如公用主机，或是空间服务商提供的服务器），您可以用一个PHP文件来间接调用htc文件。我只要给你看下这个PHP文件的代码您就知道什么意思了，如下：

   ```php
   <?php
     header( 'Content-type: text/x-component' );
     include( 'pie.htc' );
   ?>
   ```

   通过PHP文件来增加一个含有"text/x-component"字样的Content-type头，同时调用pie.htc文件。关于上面所示的php文件，您可以直接新建一个php文件，把上面的两行代码复制进去。如果您使用上述php文件，您需要将pie.php和pie.htc放在同一个文件夹目录下，同时CSS中的behavior写法应该是：`behavior: url(pie.php);`

>以上为一些常见的主要的问题，当然，在复杂的页面情况下，还会有其他意想不到的情况，这里，祝您好运了！

## object

### wbbrowser

今天用到了wbbrowser控件做页面打印，感觉非常强大。索性收集了html object标签的一些知识，整理于此供需要时查阅。

首先放出这个强大web页面打印[例子](../codes/5.1.1_print.html)。接下来我将收集到的html object控件标签罗列在此，具体应用的例子后续有时间补上。

### 地理位置

通过获取地理位置信息在地图上显示当前位置

### 历史记录管理

使用pushState()方法进行历史记录管理

### 跨域消息传递

Twitter搜索gadget，由postMessage()来控制

通过postMessage()来使用Twitter搜索gadget

### WebWorker

## 流式编程

>有时候也可以成为函数式编程。它的主要目的是在数据拉取的过程中渲染页面，即边处理数据边渲染页面。

类似概念：

- 流式应用：Rxjs
- 流式列表
- 流式处理：大数据、实时计算
- 文件处理、字节流、加密、网络

### 流式应用

![x](./Resource/流式应用.png)

RxJS本身一直试图将数据、dom等前端元素看做流处理。它的思想其实就是流式编程思想的一种。如果你使用过RxJS，你会非常快速的理解流式编程的核心理念。

但是RxJS更多的是将操作，包括http请求、dom操作等看做流的形式，在普通请求、操作的基础上封装出了一个流的上层对象。它只能算做流式编程思想的其中一部分。流式编程更加的靠前，它包含了页面结构设计、请求顺序等一些列的东西。

### 瀑布流

![x](./Resource/瀑布流.png)

开发前端的同学或多或少都会遇到瀑布流页面，哪怕没开发过也见过、研究过。

瀑布流完全是将页面（一部分）看过了一个流式页面，如果页面向下流动，页面能够自然达到的顺序就是瀑布流希望/想要达到的效果。

流式编程思想更多的是提出页面整体上的流式，而不仅仅是页面的某一部分。假如你做的瀑布流页面是完全靠`position`绝对定位实现的。很抱歉，这样的页面仅仅是实现了瀑布流，但它不属于流式编程。流式编程提倡使用正常的文档流去开发。让页面渲染能够一泻而下，通畅而不阻塞。不需要重新绘制dom树才是流式编程在页面开发上的核心要点。

### 实时计算

![x](./Resource/实时计算.png)

这里拿出实时计算就是为了让开发者能够从不同的方面去理解流式编程的思想。

不管是页面还是请求、甚至是各种操作等，将它们看做一个流，顺着网络请求的顺序，页面渲染逻辑的顺序向一点去前进。这个点就是流式编程。所有的东西都通过流式编程思想去处理，将它们混杂在一起，然后处理成一个一个单独块。这个块包含当时情况下最应该做的操作（dom、http、click等），然后打包出现在页面上。这个就是流式编程的核心思想。

### 流处理

![x](./Resource/流处理.png)

这里使用了流去举例是因为流的读写操作从概念上是非常贴合流式编程思想的。

从文件上开一个通道去获取数据，然后拿到的同时就做相应的处理，同时在处理完就将它们放出来。这个过程也就是流式编程思想在构思页面结构的时候想要做的。

### 页面结构

原始页面是嵌套的，但是去掉嵌套来看，整个页面是一个从上到下的渲染过程。在渲染的过程中如果触发页面重绘，或者是出现脱离文档流的样式，整个页面的性能就会下降。由此可见，前端结构是需要尽量流式的展示的。

从这个点出发就是流式编程中的dom结构流式编程。

![x](./Resource/liushi.png)

从页面结构设计上考虑，首屏渲染的时间把握其实就是在考验开发者的流式编程思想。让页面尽可能早的呈现第一屏的dom结构，同时尽量早的加载完成第一屏的图片等资源文件。其他会对页面渲染阻塞都要往后排。

如果使用流式编程思想重新设计页面结构，单从结构上来说，一个首屏的渲染了不起20ms就到顶了，再加上各种资源加载，这些综合下来首页的加载速度一般可以提到500ms以内。这个时间才是首页渲染应该有的时间。如果是手机上，不考虑网络差的情况甚至可以做到300ms内打开页面。

![x](./Resource/WX20190430-182707@2x.png)

从图中可以看到，一部分请求在蓝色线左边，也就是页面必须使用到的。后面的4个请求是页面加载之后用到的，这几个请求是可以后加载的。其中1个是接口，然后几个是渲染页面用到的js文件。他们的顺序就是先渲染页面框架，然后再填充下面的内容。

真正的让页面飞起来，从页面结构上开始考虑。

### 接口请求

![x](./Resource/接口请求.png)

打开页面甚至在页面什么也没有展示的时候，接口就会请求数据。从上面的截图可以看到一个页面首次打开可以请求多少接口，甚至截图中的接口请求个数都不是非常多的那种。

有的页面请求3、5个，有的请求10多个。从整体上看，大多数接口是一个顺序请求的过程。它受到页面结构的影响，过快的请求反而渲染的不是所需要的地方。

页面的请求顺序就可以看做是一个流式的过程。将需要同步渲染的接口放在一起，等待结果返回之后再展示页面。剩下的几个不需要优先渲染的往后推，通过事件触发等方式在页面渲染之后再继续执行。

>tips:有些接口可以同时异步执行，使用并行请求，将页面渲染分离，可以加速页面的呈现。tips:多次请求需要多次握手，使用http2.0可以加速这个时间。合并接口可以直接去掉多余时间。

### 优化顺序

通过上面的分析，我们可以对流式编程有一个大概的印象，一些想法思路可以总结下来：

1. 按照页面渲染顺序做开发。没必要呈现的后渲染，可以加速页面展示。避免在页面加载过程中不断重绘。
2. 多余接口后请求，优先渲染第一屏。接口请求往往意味着后面有一些逻辑需要执行，将不需要第一时间请求的接口往后放可以节省很多加载时间，就像分页加载一样加载页面，页面可以更快打开。
3. 从结构上优化。先加载的先请求，先呈现的先计算，后加载的排队来，后呈现的叠加计算。这里的排队可以类比分页加载来思考怎么实现。叠加计算更多的是在当前状态上更新新的页面。

### 单接口情况

![x](./Resource/单接口情况.png)

单接口的时候会遇到数据量大，结构复杂。页面结构也会相应的增长复杂度。面对这种一次性接收大量数据的情况下，最优先考虑是优化数据结构。将大的复杂的结构分化成合适的小的结构，这样分解之后再使用会减少很多开发过程中的麻烦。把问题前置，预先处理复杂的数据，后面用到的时候才会更合适。同时，如果数据结构还有变化，也能够及时的调整应对。

应对这种情况，我们可以从几个方面入口去优化。

1. 加速接口返回速度。这个往往比较容易。

   ![x](./Resource/WX20190430-184828@2x.png)

2. 分析页面结构，将页面分成不同侧重点的部分。比如商品详情这个页面，可以分成商品简略信息和详情2个部分。其中简略信息包含几个头图、价格、卖点等信息。详情包含规格、复杂的介绍内容。（如果有需要，价格也可以分开，将价格单独分成一个接口）

3. 数据适配。我们已经将页面分成了2个部分，这里就可以单独把第一个部分放在一个对象中做渲染。这里使用vue、react等框架会得到非常及时的渲染结果，省下了大量的dom操作时间。剩下的部分放在滑动事件中，滑动页面的时候再渲染。

   ![x](./Resource/WX20190430-185303@2x.png)

4. 异步加载。这里继续使用商品详情的例子。当用户点击或者下滑的时候需要展示商品的各种规格、宣传图等。我们可以先渲染容器，保证页面结构的统一化。然后再根据页面当前位置逐步加载需要显示的图片等资源。这里同时也会涉及到超长列表的优化。其实非常简单，就是保持容器不变，内部渲染内容在超出屏幕之后删除，保证页面上的dom数量不至于太多。

上面的几点初步展示了怎么样优化一个大数据块的页面。正在遇到这个问题的同学可以根据这个思路去思考解决方案了。

### 多接口

多接口的情况往往是需要并行的和需要并发的接口齐上阵，一不注意就造成接口阻塞。

![x](./Resource/WX20190430-185531@2x.png)

1. 首先分析出页面具有哪些不同的部分。这些不同的部分的结构要隔离开，方便做不同的逻辑处理。这里推荐组件化形式处理，可以更方便的隔离不同的逻辑结构。

   ![x](./Resource/WX20190430-185845@2x.png)

2. 接口处理。后端基于某些（不靠谱）考虑会出几种不同的接口。这个时候前端更多的是区分接口的优先级和功能域。相同功能依赖的接口同步等待。不同的功能域之间梳理加载顺序。如果发现功能域不是优先展示的，可以放在异步或者触发式功能域中。
3. 先返回的数据先渲染，后返回的数据后渲染。多种渲染使用组件分离。

>这里提到了一个功能域，这其实是一个领域的概念。一个功能域包含特定的页面结构、依赖的接口。这里可以看做一个组件，内部包含了页面结构接口请求。

### 实时+触发

这个场景更多的出现在交互比较频繁的地方。比如一个按钮可以无限次的点击，滚动的时候有一个出现隐藏的动画/结构等。

![x](./Resource/WX20190430-190818@2x.png)

1. 如果一个操作多次触发，为了保持反馈/动画的稳定性，这里是一定要做控制的。典型的解决方式就是节流函数控制。或者也可以考虑从展示逻辑上处理，实现更简单。上滑的时候出现滑动小动画，如果不懂上滑其实只需要做一次动画即可。只有上一次动画做完才会执行下一个动画。这其实也是最简单的流式思想。

   ![x](./Resource/WX20190430-190420@2x.png)

2. 如果一个页面可能会多次展示隐藏，同时内部的数据是异步获取的。这个场景下优先考虑缓存渲染结果，第一次的时候加载数据，后面在展示的时候其实一直在用一个缓存来渲染结果。从流程上看就简化为了data=>dom。

### 复杂页面

复杂的页面跟多的是上面几种的组合。只要能够识别到那些地方归属那种情况，再去优化就有一个清晰的目标了。

![x](./Resource/好东西流程.jpg)

1. 产品级分析。看到原型或者UI的时候基本就能够知道页面未来会长什么样子了。这个时候也就是一个复杂的页面最应该开始构思结构的时候。分析页面功能点，区分哪些是先展示，哪些是触发之后展示。然后设计页面结构，隔离不同展示区域。
2. 不同的结构使用不同的接口，接口之间也是分属不同的功能域。如果一个接口内容特别多，可以从逻辑上将一个接口分成好几个部门处理。尤其是要渲染很多内容的时候，分开渲染速度更快。
3. 有些结构完全可以设计到触发之后再加载。比如第二屏展示的内容，点击之后才能看到的地方等。

## 总结

流式编程将页面结构看做数据，多个数据并行展示看做一个整体。通过这样宏观的抽象整理，将页面变成了一个流动的对象。从根本上改变了开发的形态。

在实际开发中使用流式编程思想可以很容易的开发出高性能的页面。页面渲染更快，展示更合理。同时反过来加速了代码结构的进化，促进开发者思考和成长。

## DOM操作成本到底高在哪儿

作者：[palmerye](http://segmentfault.com/a/1190000014070240)

从我接触前端到现在，一直听到的一句话：操作DOM的成本很高，不要轻易去操作DOM。尤其是React、vue等MV*框架的出现，数据驱动视图的模式越发深入人心，jQuery时代提供的强大便利地操作DOM的API在前端工程里用的越来越少。刨根问底，这里说的成本，到底高在哪儿呢？

### 什么是DOM

**Document Object Model 文档对象模型：**

什么是DOM？可能很多人第一反应就是div、p、span等html标签（至少我是），但要知道，DOM是Model，是Object Model，对象模型，是为HTML(and XML)提供的API。HTML(Hyper Text Markup Language)是一种标记语言，HTML在DOM的模型标准中被视为对象，DOM只提供编程接口，却无法实际操作HTML里面的内容。但在浏览器端，前端们可以用脚本语言(JavaScript)通过DOM去操作HTML内容。

那么问题来了，只有JavaScript才能调用DOM这个API吗？答案是NO。

Python也可以访问DOM。所以DOM不是提供给Javascript的API，也不是Javascript里的API。

>PS: 实质上还存在CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构，与DOM是两个独立的数据结构。

### 浏览器渲染过程

讨论DOM操作成本，肯定要先了解该成本的来源，那么就离不开浏览器渲染。

这里暂只讨论浏览器拿到HTML之后开始解析、渲染。

1. 解析HTML，构建DOM树（这里遇到外链，此时会发起请求）
2. 解析CSS，生成CSS规则树
3. 合并DOM树和CSS规则，生成render树
4. 布局render树(Layout/reflow)，负责各元素尺寸、位置的计算
5. 绘制render树(paint)，绘制页面像素信息
6. 浏览器会将各层的信息发送给GPU，GPU将各层合成(composite)，显示在屏幕上

### 1.构建DOM树

```html
<html>
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="style.css" rel="stylesheet">
  <title>Critical Path</title>
</head>
<body>
  <p>Hello <span>web performance</span> students!</p>
  <div><img src="awesome-photo.jpg"></div>
</body>
</html>
```

无论是DOM还是CSSOM，都是要经过 Bytes → characters → tokens → nodes → objectmodel 这个过程。

![x](./Resource/80.png)

DOM树构建过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。

### 2.构建CSSOM树

上述也提到了CSSOM的构建过程，也是树的结构，在最终计算各个节点的样式时，浏览器都会先从该节点的普遍属性（比如body里设置的全局样式）开始，再去应用该节点的具体属性。还有要注意的是，每个浏览器都有自己默认的样式表，因此很多时候这棵CSSOM树只是对这张默认样式表的部分替换。

### 3.生成render树

DOM树和CSSOM树合并生成render树

![x](./Resource/81.png)

**简单描述这个过程：**

DOM树从根节点开始遍历可见节点，这里之所以强调了“可见”，是因为如果遇到设置了类似 `display:none;` 的不可见节点，在 render 过程中是会被跳过的（但 `visibility:hidden;` `opacity:0` 这种仍旧占据空间的节点不会被跳过render），保存各个节点的样式信息及其余节点的从属关系。

### 4.Layout 布局

有了各个节点的样式信息和属性，但不知道各个节点的确切位置和大小，所以要通过布局将样式信息和属性转换为实际可视窗口的相对大小和位置。

### 5.Paint 绘制

万事俱备，最后只要将确定好位置大小的各节点，通过GPU渲染到屏幕的实际像素。

Tips:

- 在上述渲染过程中，前3点可能要多次执行，比如js脚本去操作dom、更改css样式时，浏览器又要重新构建DOM、CSSOM树，重新render，重新layout、paint；
- Layout在Paint之前，因此每次Layout重新布局（reflow 回流）后都要重新触发Paint渲染，这时又要去消耗GPU；
- Paint不一定会触发Layout，比如改个颜色改个背景；（repaint 重绘）
- 图片下载完也会重新触发Layout和Paint；

![x](./Resource/82.png)

### 何时触发reflow和repaint

- reflow（回流）：根据Render Tree布局（几何属性），意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；
- repaint（重绘）：意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；
- reflow回流的成本开销要高于repaint重绘，一个节点的回流往往会导致子节点以及同级节点的回流；

GoogleChromeLabs 里面有一个csstriggers，列出了各个CSS属性对浏览器执行Layout、Paint、Composite的影响。

### 引起reflow回流

现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。

1. 页面第一次渲染（初始化）
2. DOM树变化（如：增删节点）
3. Render树变化（如：padding改变）
4. 浏览器窗口resize
5. 获取元素的某些属性：

浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括offsetLeft、offsetTop、offsetWidth、offsetHeight、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、调用了getComputedStyle()或者IE的currentStyle

### 引起repaint重绘

1. reflow回流必定引起repaint重绘，重绘可以单独触发
2. 背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）

### 优化reflow、repaint触发次数

- 避免逐个修改节点样式，尽量一次性修改
- 使用DocumentFragment将需要多次修改的DOM元素缓存，最后一次性append到真实DOM中渲染
- 可以将需要多次修改的DOM元素设置 display:none，操作完再显示。（因为隐藏元素不在render树内，因此修改隐藏元素不会触发回流重绘）
- 避免多次读取某些属性（见上）
- 将复杂的节点元素脱离文档流，降低回流成本

为什么一再强调将css放在头部，将js文件放在尾部？

### DOMContentLoaded 和 load

- DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片...
- load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成

### CSS 资源阻塞渲染

构建Render树需要DOM和CSSOM，所以HTML和CSS都会阻塞渲染。所以需要让CSS尽早加载（如：放在头部），以缩短首次渲染的时间。

### JS 资源

阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML。

这和之前文章提到的浏览器线程有关，浏览器中js引擎线程和渲染线程是互斥的，详见《从setTimeout-setInterval看JS线程》

普通的脚本会阻塞浏览器解析，加上defer或async属性，脚本就变成异步，可等到解析完毕再执行。

- async异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload前，但不确定在DOMContentLoaded事件的前后
- defer延迟执行，相对于放在body最后（理论上在DOMContentLoaded事件前）

举个栗子：

```html
<html>
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="style.css" rel="stylesheet">
</head>
<body>
  <p>Hello <span>web performance</span> students!</p>
  <div><img src="awesome-photo.jpg"></div>
  <script src="app.js"></script>
</body>
</html>
```

![x](./Resource/83.png)

- 浏览器拿到HTML后，从上到下顺序解析文档
- 此时遇到css、js外链，则同时发起请求
- 开始构建DOM树
- 这里要特别注意，由于有CSS资源，CSSOM还未构建前，会阻塞js（如果有的话）
- 无论JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒 JavaScript解析器，就会进行暂停 blocked 浏览器解析HTML，并等到 CSSOM 构建完毕，才执行js脚本
- 渲染首屏（DOMContentLoaded 触发，其实不一定是首屏，可能在js脚本执行前DOM树和CSSOM已经构建完render树，已经paint）

### 首屏优化Tips

说了这么多，其实可以总结几点浏览器首屏渲染优化的方向：

- 减少资源请求数量（内联亦或是延迟动态加载）
- 使CSS样式表尽早加载，减少@import的使用，因为需要解析完样式表中所有import的资源才会算CSS资源下载完
- 异步js：阻塞解析器的 JavaScript 会强制浏览器等待 CSSOM 并暂停 DOM 的构建，导致首次渲染的时间延迟
- so on...

知道操作DOM成本多高了吗？其实写了这么多，感觉偏题了，大量的资料参考的是chrome开发者文档。

操作DOM具体的成本，说到底是造成浏览器回流reflow和重绘reflow，从而消耗GPU资源。

参考文献：

- [谷歌开发者文档](https://developers.google.com/web/fundamentals/performance/critical-rendering-path)
