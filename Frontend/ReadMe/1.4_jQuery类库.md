# jQuery类库

- 官方网站：[http://jquery.com/](http://jquery.com/)
- 参考网站：  
  [http://www.w3school.com.cn/index.html](http://www.w3school.com.cn/index.html)  
  [http://www.365mini.com/](http://www.365mini.com/)

## 目录

1. 简介
   - [jQuery函数](#jQuery函数)
   - [getter和setter](#getter和setter)
   - [修改文档结构](#修改文档结构)
   - [处理事件](#处理事件)
   - [动画效果](#动画效果)
   - [Ajax](#Ajax)
   - [工具函数](#工具函数)
   - [选择器](#选择器)
   - [插件扩展](#插件扩展)
   - [UI类库](#UI类库)
2. 总结
   - [问题](#问题)
   - [示例](#示例)

jQuery由美国人John Resig创建，是继prototype之后又一个优秀的Javascript框架。其宗旨是——WRITE LESS, DO MORE（写更少的代码，做更多的事情）。

它是轻量级的js库（压缩后只有21k），这是其它的js库所不及的，它兼容CSS3，还兼容各种浏览器。

jQuery 对象是通过jQuery包装DOM对象后产生的，是jQuery独有的对象。如果一个对象是 jQuery 对象，那么它就可以使用jQuery方法。

jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法。约定：如果获取的是jQuery对象，那么要在变量前面加上$。

```js
var $variable = jQuery对象
var variable = DOM对象
```

对于已经是一个DOM对象，只需要用 `$()` 把DOM对象包装起来，就可以获得一个jQuery对象了。`$(DOM对象)` 转换后就可以使用jQuery中的方法了

两种转换方式将一个jQuery对象转换成DOM对象：`[index]` 和 `.get(index)`;

(1) jQuery对象是一个数组对象，可以通过[index]的方法，来得到相应的DOM对象

(2) jQuery本身提供，通过.get(index)方法，得到相应的DOM对象

jQuery类库定义了一个全局函数: jQuery()。该函数使用频繁，因此在类库中还给它定义了一个快捷别名: `$`。这是jQuery在全局命名空间中定义的唯一两个变量。

jQuery有一个用来作为DOM快速载入javascript的得心应手的小函数，那就是ready，他在页面加载完成之前执行。（也许window.onload()能实现同样的功能，但是jQuery更加快速，灵活）。

`$(document).ready(fn)`: 当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。这是事件模块中最重要的一个函数，因为它可以极大地提高web应用程序的响应速度。简单地说，这个方法纯粹是对向window.load事件注册事件的替代方法。通过使用这个方法，可以在DOM载入就绪能够读取并操纵时立即调用你所绑定的函数，而99.99%的JavaScript函数都需要在那一刻执行。请确保在<body>元素的onload事件中没有注册函数，否则可能不会触发 `$(document).ready()` 事件。可以在同一个页面中无限次地使用 `$(document).ready()` 事件。其中注册的函数会按照（代码中的）先后顺序依次执行。

## jQuery函数

- 传递CSS选择器
- 传递Element、Document、Window
- 传递HTML文本（封装为jQuery对象，但不会自动插入到文档中）

  示例：`var img = $("<img/>", { src:url, css: { borderWidth: 5 }, click: handleClick });`

- 传入一个函数（文档加载完毕时调用）

  ```js
  // 还原$()为初始值
  jQuery.noConflict();
  jQuery(function($){ //让$()成为jQuery对象的局部别名
    //jQuery代码放在这里
  });
  ```

通过 `$()` 注册的函数将在DOMContentLoaded事件触发时由jQurey触发。当浏览器不支持该事件时，会在load事件触发时由jQurey触发。这意味着文档已经解析完毕，但图片等外部资源有可能还未加载。

jQuery对象是类数组，如果不想把数组标识用在jQuery对象上，可以使用 `size()` 方法来替代length属性，用 `get()` 方法来替代方括号索引。可以使用 `toArray()` 方法来将jQuery对象转化为真实数组。

除了length属性，jQuery对象还有三个挺有趣的属性。selector属性是创建jQuery对象时的选择器字符串（如果有的）。context属性是上下文对象，是传递给 `$()` 方法的第二参数，如果没有传递的话，默认是Document对象。最后，所有jQuery对象都有一个名为jquery的属性，检测该属性是否存在可以简单快捷地将jQuery对象与其他类数组对象区分开来。jquery属性值是字符串形式的jQuery版本号：

```js
// 获取 document body 中的所有 <script> 元素
var bodyscripts = $("script", document.body);
bodyscripts.selector // => "script"
bodyscripts.context // => document.body
bodyscripts.jquery // => "1.4.2"
```

想要遍历jQuery对象中的所有元素时，可以调用 `each()` 方法来代替 for 循环。jQuery 的 each() 方法和 forEach() 有一个显著区别：如果回调函数在任一个元素上返回false，遍历将在该元素后中止（这就像在普通循环中使用break关键字一样）。each() 返回调用自身的 jQuery 对象，因此它可以用于链式调用。

jQuery 的 `map()` 方法和 Array.prototype.map() 方法很相近。它接受回调函数作为参数，并为 jQuery 对象中的每一个元素都调用回调函数，同时将回调函数的返回值收集起来，并将这些返回值封装成一个新的 jQuery 对象返回。

jQuery 的另一个基础方法是 `index()`。该方法接受一个元素作为参数，返回值是该元素在此 jQuery 对象中的索引值，如果找不到的话，则返回-1。

jQuery 通用方法是 `is()`。它接受一个选择器作为参数，如果选中元素中至少有一个匹配该选择器时，则返回true。

## getter和setter

- attr()、removeAttr()
- css(): 不能获取复合样式，允许在CSS样式名中使用连字符或使用驼峰式JavaScript样式名
- addClass()、removeClass()、toggleClass()、hasClass()
- val(): 用来设置和获取HTML表单元素的value属性，还可用于获取和设置复选框、单选按钮以及 `<select>` 元素的选中状态。
- text()、html()：如果传人字符串给text() 或html()，该字符串会用做该元素的纯文本或格式化的HTML文本内容，它会替换掉所有存在的内容。和其他setter方法一样，我们还可以传人函数，该函数用来计算出表示新内容的字符串
- offset(): 获取或设置元素的位置。该方法相对文档来计算位置值，返回一个对象，带有left和top属性，用来表示X和Y坐标。如果传人带有这些属性的对象给该方法，它会给元素设置指定的位置。在有必要肘，会设置css 的position属性来使得元素可定位

  position()方法很像offset() 方法，但它只能用做getter，它返回的元素位置是相对于其偏移父元素的，而不是相对于文档的。

  用于获取元素宽度的getter有3个，获取高度的也有3 个。
  
  1. width() 和height() 方法返回基本的宽度和高度，不包含内边距、边框和外边距。
  2. innerWidth() 和innerHeight() 返回元素的宽度和高度，包含内边距的宽度和高度（“内”表示这些方法度量的是边框以内的尺寸）。
  3. outerWidth ()和outerHeight() 通常返回的是包含元素内边距和边框的尺寸。如果向两个方怯中的任意一个传入true值，它们还可以返回包含元素外边距的尺寸。

- scrollTop()和scrollLeft(): 可获取或设置元素的滚动条位置。
- data()、removeData()

## 修改文档结构

- append()、appendTo()
- prepend()、prependTo()
- before()、insertBefore()
- after()、insertAfter()
- replaceWith()、replaceAll()
- clone(): 传入true参数，复制事件处理程序和与元素关联的其他数据
- jQuery定义了3个包装函数。wrap()包装每一个选中元素。wrapInner()包装每一个选中元素的内容。wrapAll() 则将选中元素作为一组来包装。

  ```js
  // 用<i>元素包装所有<h1>元素
  $("h1").wrap(document.createElement("i")); // 产生<i><h1>…</h1></i>
  // 包装所有<h1>元素的内容，使用字符串参数更简单
  $("h1").wrapInner("<i/>"); // 产生<h1><i>...</i></h1>
  // 将第一个段落包装在一个锚点和div里
  $("body>p:first").wrap("<a name='lead'><div class='first'></div></a>");
  // 将所有其他段落包装在另一个div里
  $("body>p:not(:first)").wrapAll("<div class='rest'></div>");
  ```

- empty()、remove()
- detach()方法和remove()类似，但不会移除事件处理程序和数据。想临时从文档中移除元素以便后续再次插入时，detach()可能会更有用。
- unwrap()方法可以用来实现元素的移除，其方式是wrap()或wrapAll()方法的反操作：移除每一个选中元素的父元素，不影响选中元素及其兄弟节点。也就是说，对于每一个选中元素，它替换该元素的父节点为父节点的子节点。与remove()和detach()不同，unwrap()不接受可选的选择器参数。

## 处理事件

- blur()
- change()
- click()
- dbclick()
- error()
- focus()
- focusin()
- focusout()
- keydown()
- keypress()
- keyup()
- load()
- mousedown()
- mouseenter()
- mouseleave()
- mousemove()
- mouseout()
- mouseover()
- mouseup()
- resize()
- scroll()
- select()
- submit()
- unload()

focus和blur事件不支持冒泡，但focusin和focusout事件支持。相反地，mouseover和mouseout事件支持冒泡，但这经常不方便，因为很难知道鼠标是从自己感兴趣的元素中移开了，还只是从该元素的子孙元素中移开了。mouseenter和mouseleave是非冒泡事件，可以解决刚才的问题。

resize和unload事件类型只在Window对象中触发，scroll()方法经常也用于$(window)对象上，但它也可以用在有滚动条的任何元素上。

load()方法可在 `$(window)` 上调用，。当然，还可以在iframe和图片上使用 load() 方法。

error() 方法可用在 `<img>` 元素上，用来注册当图片加载失败时调用的处理程序。不应该用于设置窗口的onerror属性。

hover()方法用来给mouseenter和mouseleave事件注册处理程序。调用hover(f,g)就和调用mouseenter(f) 然后调用mouseleave(g)一样。如果仅传入一个参数给hover()，该参数函数会同时用做enter和leave事件的处理程序。

toggle()方法将事件处理程序函数绑定到单击事件。可指定两个或多个处理程序函数，当单击事件发生时，jQuery每次会调用一个处理程序函数。例如，如果调用toggle(f,g ,h)，第一次单击事件触发时，会调用函数f()，第二次会调用g()，第三次则调用h()，然后调用f()来处理第四次单击事件

jQuery事件处理程序函数的返回值始终有意义。如果处理程序返回false，与该事件相关联的默认行为，以及该事件接来下的冒泡都会被取消。也就是说，返回false等同于调用Event对象的preventDefault()和stopPropagation()方法。同样，当事件处理程序返回一个值（非undefined值）时，jQuery会将该值存储在Event对象的result属性中，该属性可以被后续调用的事件处理程序访问。

### bind(), unbind()

调用bind() 时还可以带有三个参数。在这种形式下，事件类型是第一个参数，处理程序函数是第三个参数。在这两个参数中间可以传入任何值，jQuery会在调用处理程序前，将指定的值设置为Event对象的data属性。通过这种方式传递额外的数据给处理程序，不需要使用闭包，有时很有用。

如果第一个参数是由空格分隔的事件类型列表，则处理程序函数会为每一个命名的事件类型注册。

另一个重要特性是允许为注册的事件处理程序指定命名空间。这使得可以定义处理程序组，能方便后续触发或卸载特定命名空间下的处理程序。处理程序的命名空间对于开发可复用jQuery代码的类库或模块的程序员来说特别有用。

```js
// 在命名空间"myMod"和"yourMod"中作为mouseout处理程序绑定f
$('a').bind('mouseout.myMod.yourMod', f);
```

bind()的最后一个特性是，第一个参数可以是对象，该对象把事件名映射到处理程序函数。

调用one()方法就和bind()一样，二者的工作原理也类似，除了在调用事件处理程序之后会自动注销它。这意味着，和该方法名字暗示的一样，使用one()注册的事件处理器永远只会触发一次。

unbind()只注销用bind()和相关jQuery方法注册的事件处理程序。

```js
$('*').unbind(); //从所有元素中移除所有jQuery事件处理程序
```

因为模块的使用者有可能使用其他模块，在其他模块中有可能在相同的元素上给相同的事件类型注册了其他处理程序。如果模块使用命名空间来注册事件处理程序，则可以使用unbind()传入一个参数，来做到只注销命名空间下的处理程序:

```js
//取消绑定在"myMod"命名空间下的所有mouseover 和mouseout 处理程序
$('a').unbind("mouseover.myMod mouseout.myMod");
//取消绑定在"myMod" 命名空间下的所有事件类型的处理程序
$('a').unbind(".myMod");
//取消绑定同时在"ns1"和"ns2"命名空间下的单击处理程序
$('a').unbind("click.ns1.ns2");
```

如果想小心地只取消绑定自己注册的事件处理程序，但没有使用命名空间，必须保留事件处理程序函数的一个引用，并使用unbind()带两个参数的版本。在这种形式下，第一个参数是事件类型字符串（不带命名空间）。第二个参数是处理程序函数:

```js
$('#mybutton').unbind('click', myClickHandler);
```

可以传递单一对象参数给unbind()。在这种情况下，unbind()会轮询为该对象的每一属性调用一次。属性名会用做事件类型字符串，属性值会用做处理程序函数。

最后，还有一种方式来调用unbind()。如果传递一个jQuery Event对象给unbind()，它会取消绑定传入事件的事件处理程序。

jQuery 的事件触发方法会触发所有使用jQuery事件注册方法注册的处理程序，也会触发通过onsubmit等HTML属性或Element属性定义的处理程序。但是，不能手动触发使用addEventListener() 或attachEvent() 注册的事件处理程序。

jQuery的事件触发机制是同步的一一不涉及事件队列。当触发一个事件时，在调用的触发方住返回之前，事件处理程序会立刻调用。如果触发了一个单击事件，被触发的处理程序又触发了一个submit事件，所有匹配的submit处理程序会在调用下一个单击处理器之前调用。

jQuery也定义了一个更通用的trigger()方法。通常，调用trigger()时会传入事件类型字符串作为第一个参数，trigger()会在jQuery对象中的所有元素上触发为该类型事件注册的所有处理程序。在传入的字符串中不能指定多个事件类型，但是可以指定事件命名空间来触发仅在该命名空间中定义的处理程序。如果只想触发没有命名空间的事件处理程序，在事件类型后添加一个感叹号就行。通过onclick等属性注册的处理程序被认为是没有命名空间的。

除了给trigger()传入事件类型字符串作为第一个参数，还可以传入Event对象（或任何有type属性的对象）。type属性会用来判断触发什么类型的处理程序。如果传入的是jQuery事件对象，该对象会传递给触发的处理程序。如果传入的是普通对象，会创建一个新的jQuery Event对象，普通对象的属性会添加到新对象中。这样，可以很容易传递额外数据给事件处理程序:

```js
// button1的单击处理程序触发button2上的相同事件
$('#button1').click(function(e) { $('#button2').trigger(e); });
//触发事件时，添加额外的属性给事件对象
$('#button1').trigger({type:'click', synthetic:true});
//该处理程序检测额外属性来区分是真实事件还是虚假事件
$('#button1').click(function(e) { if (e.synthetic) {...}; });
```

给事件处理程序传递额外数据的另一种方式是，在手动触发事件时，给trigger() 传入第二个参数。给trigger()传入的第二个参数会成为每个触发的事件处理程序的第二个参数。如果传入数组作为第二个参数，数组的每一项会作为独立参数传递给触发的处理程序。

有时，会想触发给定事件类型的所有处理程序，而不管这些处理程序是绑定到什么文档元素上的。这时可以使用$('*')来选中所有元素，然后对结果调用trigger()，可是这样做非常低效。更好的方式是，使用jQuery.event.trigger()工具函数，来全局触发事件。该函数接受的参数和trigger()方法一样，但在整个文档中触发指定事件类型的事件处理程序时更高效。注意，以这种方式触发的“全局事件”不会冒泡，并且只会触发使用jQuery方法注册的处理程序

trigger()（及调用它的便捷方法）在调用事件处理程序后，会执行与触发事件相关联的默认操作（假设事件处理程序没有返回false或调用事件对象的preventDefault()）。

如果想调用事件处理程序，但不执行默认操作，可以使用triggerHandler()替代trigger()。

jQuery不限于标准事件，你可以使用任何想用的字符串来作为事件类型名称。使用bind() 可以注册这种“自定义事件”的处理程序，使用trigger()可以调用这些处理程序。

对于书写模块化代码，实现发布/订阅模型或观察者模式时，这种自定义事件处理程序的间接调用被证明是非常有用的。使用自定义事件时，通常你会发现，使用jQuery.event.trigger()函数替代trigger()方法，来全局触发处理器会更有用。

如果使用 bind() 给文档中的所有 `<a>` 元素绑定了事件处理程序，接着又创建了带有 `<a>` 元素的新文档内容，这些新元素和老元素不会拥有相同的事件处理程序，其行为将不一样。

jQuery使用“实时事件”来解决这一问题。要使用实时事件，需要使用delegate()和undelegate()方法来替代bind()和unbind()。通常，在$(document)上调用delegate()，并传入一个jQuery选择器字符串、一个jQuery事件类型字符串以及一个jQuery事件处理程序函数。它会在document或window上（或jQuery对象中的任何元素上）注册一个内部处理程序。当指定类型的事件冒泡到该内部处理程序时，它会判断事件目标（该事件所发生在的元素）是否匹配选择器字符串。如果匹配，则调用指定的处理程序函数。因此，为了同时处理老的和新创建的 `<a>` 元素上的mouseover事件，可能需要像下面这样注册处理程序:

```js
$(document).delegate("a", "mouseover", linkHandler);
否则，需要使用bind() 来处理文档中的静态部分，然后使用delegate()来处理动态修改的部分:
//静态链接的静态事件处理程序
$("a").bind("mouseover", linkHandler);
//文档中动态更新的部分使用实时事件处理程序
$(".dynamic").delegate("a", "mouseover", linkHandler);
```

delegate()方法拥有4参数版本，使用这种版本时，将数据值作为第三参数传入，处理程序函数则作为第4参数。
实时事件依赖于事件冒泡。当事件冒泡到document对象时，它有可能已经传递给了很多静态事件处理程序。如果这些处理程序中有任何一个调用了Event对象的cancelBubble()方法，实时事件处理程序将永远不会调用。

jQuery定义了一个名为liveO 的方法，也可以用来注册实时事件。

在jQuery对象上调用live()方法时，该对象中的元素实际上并没有使用。真正有关系的是用来创建jQuery对象的选择器字符串和上下文对象。因此，对于jQuery对象x，下面两行代码做的事情是一样的：

```js
x.live(type, handler);
$(x.context).delegate(x.selector, type, handler);
```

要注销实时事件处理程序，使用die()或undelegate()。

```js
$('a').die('mouseover'); //移除<a>元素上mouseover事件的所有实时处理程序
$('a').die('mouseover' , linkHandler); //只移除一个指定的实时处理程序
$(document).undelegate('a'); //移除<a> 元素上的所有实时处理程序
$(document).undelegate('a' , 'mouseover'); //移除mouseover 的实时处理程序
$(document).undelegate('a' , 'mouseover' , linkHandler); //移除指定处理程序
```

## 动画效果

animate()

简单地设直jQuery.fx.off 为true会将每段动画的时长都变成0ms，这样动画看起来就像是没有动画效果的立刻切换了。

jQuery动画方法经常使用动画时长来作为可选的第一个参数。

jQuery动画是异步的。调用fadeIn()等动画方法时，它会立刻返回，动画则在“后台”执行。由于动画方法会在动画完成之前返回，因此可以向很多jQuery动画方法传入第二个参数（也是可选的），该参数是一个函数，会在动画完成时调用。该函数在调用时不会有任何参数传入，但this值会设置为发生动画的文档元素。

jQuery动画默认是队列化的。

jQuery动画方法可以接受可选的时长和回调参数。还可以传入一个对象来调用动画方法，该对象的属性指定动画选项。

jQuery定义了9个简单的动画方法来隐藏和显示元素

- fadeIn()
- fadeOut()
- fadeTo()
- show()
- hide()
- toggle()
- slideDown()
- slideUp()
- slideToggle()

animate()方法可以实现更多通用动画效果。

第一个参数是必需的：它必须是一个对象，该对象的属性指定要变化的CSS 属性和它们的目标值。animate()方法会将每个元素的这些CSS属性从初始值变化到指定的目标值。动画只支持数值属性，jQuery的实现方式不支持非数值动画。还可以指定相对值，用"+="前缀表示增加，或用"-="表示减少。

```js
$("p").animate({
    "margin-left": "+=.5in", // 增加段落缩进
    opacity: "-=.1" // 同时减少不透明度
});
```

除了数值，在jQuery动画属性对象中，还可以使用三个其他值。"hide" 值会保存属性的当前值，然后将该属性的值变化到0。"show"值会将css属性的值还原到之前保存的值。如果一段动画使用了"show"，jQuery会在动画完成时调用show()方法。如果一段动画使用了"hide"，jQuery会在动画完成时调用hide()方法。还可以使用"toggle" 来实现显示或隐藏，具体效果取决于该属性的当前设置。

```js
$("img").animate({
    width: "hide",
    borderLeft: "hide" ,
    borderRight: "hide",
    paddingLeft: "hide" ,
    paddingRight: "hide"
});
```

第二个参数是可选的，可以传入一个选项对象给animate() 方法。

duration属性指定动画持续的毫秒时间，该属性的值还可以是"fast"、"slow"或任何在jQuery.fx.speeds 中定义的名称。

complete属性:它指明在动画完成时的回调函数。

step属性指定在动画每一步或每一帧调用的回调函数。在回调函数中，this指向正在连续变化的元素，第一个参数则是正在变化的属性的当前值。

queue属性指定动画是否需要队列化

jQuery引入了“缓动函数”来将基于时间的完成百分比映射到动画效果的百分比。

选项对象的easing属性指定缓动函数名。jQuery默认使用的是命名为"swing" 的正弦函数。如果想让动画线性变化，可以使用"linear"

除了将选项对象作为第二个参数传入，animate()方法还允许将三个最常用的选项作为参数传入。可以将动画时长（数值或字符串）作为第二个参数传入。可以指定缓动函数名为第三个参数。最后可以将回调函数指定为第四个参数。

stop(): 用来停止选中元素上的当前正在执行的任何动画。

top()方法接受两个可选的布尔值参数。如果第一个参数是true，会清除该选中元素上的动画队列：除了停止当前动画，还会取消任何等待执行的动画。第一个参数的默认值是false：如果忽略该参数，等待执行的动画不会被取消。第二个参数用来指定正在连续变化的css属性是否保留当前值，还是应该变化到最终目标值。传入true可以让它们变化到最终值。传入false（或省略该参数）会让它们保持为当前值。

与动画相关的第二个方法是delay()。这会直接添加一个时间延迟到动画队列中：第一个参数是时长（以毫秒为单位的数值或字符串）。第二个参数是队列名，是可选的。

jQuery队列是按顺序执行的函数列表。每一个队列都与一个文档元素关联，每一个元素的队列都与其他元素的队列彼此独立。

可以使用queue()方法给队列添加一个新函数。当某个函数到达队列头部时，它会自动从队列中去除并被调用。

队列函数中的回调函数参数是jQuery 1.4 引入的新特性。对于jQuery类库之前的版本，需要调用dequeue() 方法“手动”取消队列中的下一个函数

clearQueue()方法用来清除队列。

queue()、dequeue()和clearQueue()方法都可以有一个可选的队列名来作为第一个参数。jQuery动画方法使用的队列名是"fx"。这是没有指定队列名时默认使用的队列。当想要顺序执行异步操作时，jQuery队列机制非常有用：原来需要给每一个异步操作传入回调函数来触发队列中的下一个函数，现在可以直接使用jQuery队列来管理异步序列。只须传入非"fx"的队列名，并记得队列中的函数不会自动执行。必须显式调用dequeue()方法来运行第一个函数，然后每一步操作在完成时必须把下一个操作从队列中移出。

## Ajax

load()：向它传入一个URL，它会异步加载该URL的内容，然后将内容插入每一个选中元素中，替换掉已经存在的任何内容。如果只想显示被加载文档的一部分，可以在URL后面添加一个空格和一个jQuery选择器。当URL加载完成后， jQuery会用指定的选择器来从加载好的HTML 中选取需要显示的部分。

load()方法还接受两个可选参数。第一个可选参数表示的数据，可以追加到URL后面，或者与请求一起发送。如果传入的是字符串，则会追加到URL后面，如果传入对象，该对象会被转化为一个用"&"分隔的名/值对后与请求一起发送。通常情况下，load()方法发送HTTP GET请求，但是如果传入数据对象，则它会发送POST请求。

load()方法的另一个可选参数是回调函数。当Ajax请求成功或未成功，以及URL加载完毕并插入选中元素时，会调用该回调函数。每次调用都会传入三个参数：被加载URL的完整文本内容、状态码字符串，以及用来加载该URL的XMLHttpRequest对象。

jQuery的Ajax状态码：

- success：表示请求成功完成。
- notmodified：该状态码表示请求已正常完成，但服务器返回的响应内容是HTTP 304 "Not Modified"，表示请求的URL 内容和上次请求的相同，没有变化。
- error：表示请求没有成功完成，原因是某些HTTP错误。
- timeout：如果Ajax请求没有在选定的超时区间内完成，会调用错误回调，并传入该状态码。
- parsererror：该状态码表示HTTP 请求已成功完成，但jQuery 无法按照期望的方式解析。

jQuery.getScript()加载并执行JavaScript代码文件。它会异步加载文件，加载完成后在全局作用域执行该代码。它能同时适用于同源和跨源脚本。可以传入回调函数作为第二个参数，在这种情况下，jQuery会在代码加载和执行完成后调用一次该回调函数。jQuery通常会使用XMLHttpRequest对象来获取要执行的脚本内容。但对于跨域请求会使用 `<script>` 元素来加载脚本。在同源情况下，回调函数的第一个参数是脚本的文本内容，第二个参数是"success" 状态码，第三个参数则是用来获取脚本内容的XMLHttpRequest对象。

jQuery.getJSON()加载URL，将其解析为JSON，并将解析结果传递到指定的回调函数中。jQuery.getJSON()接受一个可选的数据对象参数，就和传入load()方法中的一样。如果传入数据到jQuery.getJSON()中，该数据必须是第二个参数，回调函数则是第三个。如果不传入任何数据，则回调函数可以是第二个参数。

jQuery.get() 和jQuery.post() 获取指定URL的内容，如果有数据的话，还可传入指定数据，最后则将结果传递给指定的回调函数。这两个方法也接受相同的三个参数：必需的URL，可选的数据字符串或对象，以及一个技术上可选但实际上总会使用的回调函数。调用的回调函数会被传入三个参数：第一个参数是返回的数据，第二个是"success" 字符串，第三个则是XMLHttpRequest对象。除了上面描述的三个参数，还有两个方法接受可选的第4个参数（如果省略数据参数的话，则作为第三个参数传入），该参数指定被请求数据的类型。

jQuery的Ajax数据类型：

- text
- html
- xml
- script
- json
- jsonp

jQuery的所有Ajax工具最后都会调用jQuery.ajax()，jQuery.ajax()仅接受一个参数：一个选项对象，该对象的属性指定Ajax请求如何执行的很多细节。

jQuery.ajax()中最常用的选项如下：

- type: "GET", "POST"
- url
- data
- dataType: "text", "html", "script", "json", "jsonp", "xml"
- contentType: "application/x-www-form-urlencoded"
- timeout: 默认超时时间是0，表示除非请求完成，否则永远不会取消。
- cache: 对于GET请求，如果该选项设置为false, jQuery会添加一个"_="参数到URL中，或者替换已经存在的同名参数。该参数的值是当前时间(毫秒格式)。这可以禁用基于浏览器的缓存，因为每次请求的URL都不一样。
- ifModified: 当该选项设置为true时，jQuery会为请求的每一个URL记录Last-Modified和IfNone-
- Match响应头的值，并会在接下来的请求中为相同的URL设置这些头部信息。这可以使得，如果上次请求后URL的内容没有改变，则服务器会发送回HTTP 304 "Not Modified" 响应。默认情况下，该选项未设置，jQuery不会设置或记录这些头部信息。
- global: 该选项指定jQuery是否应该触发上面描述的Ajax请求过程中的事件。默认值是true; 设置该选项为false会禁用Ajax相关的所有事件。

下面的选项指定在Ajax请求的不同阶段调用的函数:

- context: 该选项指定回调函数在调用时的上下文对象
- beforeSend: 该选项指定Ajax请求发送到服务器之前激活的回调函数。
- success: 该选项指定Ajax请求成功完成时调用的回调函数。第一个参数是服务器发送的数据; 第二个参数是jQuery 状态码; 第三个参数是用来发送该请求的XMLHttpRequest对象。
- error: 该选项指定Ajax请求不成功时调用的回调函数。该回调的第一个参数是该请求的XMLHttpRequest对象(如果用到的话)。第二个参数是jQuery 的状态码。对于HTTP错误，该状态码可能是"error" ，对于超时，则是"timeout", "parsererror" 则表示解析服务器响应时出了问题。第三个参数是抛出的Error对象。注意dataType为"script" 的请求在返回无效JavaScript代码时不会触发错误。脚本中的任何错误都会直接忽略，调用的回调则是success而不是error 。
- complete：该选项指定Ajax请求完成时激活的固调函数。每一个Ajax请求或者成功时调用success回调，或者失败时调用error回调。在调用success或error后，jQuery会调用complete回调。传给complete 回掉的第一个参数是XMLHttpRequest对象，第二个参数则是状态码。

下述Ajax选项不经常使用。某些特定选项通常不可能设置，另一些选项则提供了自定义钩子，使得可以修改jQuery Ajax请求的默认处理方式。

- async
- dataFilter: 该选项指定一个函数，用来过滤或预处理服务器返回的数据。第一个参数是从服务器返回的原始数据（字符串或XML请求返回的Document对象），第二个参数是dataType选项的值。如果指定该函数，则它必须返回一个值，该值会用来替换掉服务器的响应。注意dataFilter()函数会在JSON解析和脚本执行前执行。同时注意对于跨域的"script" 和"jsonp" 请求不会调用dataFilter()。
- jsonp
- jsonpCallback
- processData：当设置data选项为对象，jQuery通常会将该对象转换成字符串，该字符串遵守标准的HTML "application/x-www-form-urlencoded" 格式。如果想省略掉该步骤，请设置该选项为false。
- scriptCharset：对于跨域的"script" 和"jsonp" 请求，会使用 `<script>` 元素，该选项用来指定 `<script>` 元素的charset属性值。
- tranditional：jQuery 1.4改变了数据对象序列化为"application/x-www-form-urlencoded" 字符串的方式。设置该选项为true，可以让jQuery 回复到原来的方式。
- username, password：如果请求需要密码验证，请使用这两个选项来指定用户名和密码。
- xhr：该选项指定一个工厂函数，用来获取XMLHttpRequest对象。该工厂函数在调用时不带参数，而且必须返回一个实现了XMLHttpRequest API的对象。这个非常底层的钩子可以创建自己对XMLHttpRequest的包装，可以给方法添加特性或测量。

## 工具函数

- $.browser: 用于客户端嗅探
- $.contains(): 该函数接受两个文档元素作为参数。如果第一个元素包含第二个元素，则返回true；否则返回false。
- $.each()：可以遍历数组元素或对象属性。第一个参数是要遍历的数组或对象自第二个参数是要在每个数组元素或对象属性上调用的函数。该函数在调用时会带有两个参数:数组元素的序号或对象的属性名，以及数组元素的值或对象的属性值。函数中的this值和第二个参数是一样的。如果该函数返回false，jQuery.each()会停止当前遍历并立刻返回。jQuery.each()总是返回第一个参数的值。jQuery.each()会使用普通的于or/in循环来遍历对象属性，所以会遍历所有可枚举的属性，包括继承的属性。jQuery.each()在遍历数组元素时，会以序号从小到大来遍历，不会跳过稀疏数组中的undefined属性。
- $.extend(): 该函数接受对象作为参数。它会将第二个及其以后参数对象的属性复制到第一个参数对象中，如果同名的属性在第一个参数对象中已经存在，则会覆盖它。该函数会忽略任何值为undefined或null的属性。如果仅传入了一个对象，该对象的属性会被复制到jQuery对象自身中。该对象的返回值是属性被复制到的对象。如果一个参数的值为true ，会执行深拷贝：第三个(及其以后)对象的属性会被复制到第二个对象上。
- $.globalEval()：该函数会在全局上下文中执行JavaScript代码字符串，就像它是 `<script>` 元素的内容一样。
- $.grep()：该函数和ES5 中Array对象的filter()方法类似。它接受数组作为第一个参数，以及一个判断函数作为第二个参数，该判断函数会在数组的每一个元素上调用，调用时会传入元素值和元素序号作为参数。jQuery.grep()返回一个新数组，新数组由调用判断函数时返回true (或其他真值)的元素组成。如果给jQuery.grep() 传入true 作为第三个参数，则它会反转判断函数，返回的数组将会由判断函数调用时为false或其他假值的元素组成。
- $.inArray()：该函数和ES5 中Array对象的indexOf()方法类似。它的第一个参数可以是任意值，第二个参数则是数组(或类数组对象)，返回值是第一个参数值在数组中第一次出现的序号，如果该参数值不存在的话，则返回-1。
- $.isArray(): 当参数是原生Array对象时，返回true。
- $.isEmptyObject()：当参数对象没有可枚举的属性时，返回true。
- $.isFunction()：当参数是原生Function对象时，返回true。
- $.isPlainObject()：如果参数是"纯"对象，而不是某些特定类型或类的对象的实例时，返回true。
- $.makeArray()：如果参数是类数组对象，该函数会将对象的属性复制到一个新的(真)数组中，并返回该数组。如果参数不是类数组对象，该函数会仅返回一个新数组，该数组只包含传入的参数一个元素。
- $.map()：该函数和ES5 中Array对象的map()方法类似。它接受数组或类数组对象作为第一个参数；第二个参数则为映射函数。每一个数组元素与其序号都会传入这映射函数中，返回值就是由映射函数返回的值组成的新数组。jQuery.map() 与ES5 map() 方法存在两点不同。首先，如果映射函数返回的是null，该值不会被包含在返回的数组中。其次，如果映射函数返回的是数组，该数组的元素会被添加到结果数组中，而不是数组本身中。
- $.merge()：该函数接受两个数组或类数组对象。它会将第二个参数的元素添加到第一个上面，并返回第一个参数。第一个数组会修改，第二个不会。可以使用该函数来浅拷贝类数组对象
- $.parseJSON()：该函数会解析JSON格式的字符串，返回解析结果。
- $.proxy()：该函数和ES5 中Function对象的bind()方法类似。它接受函数作为第一个参数，对象作为第二个参数，并返回一个新函数，该函数会作为第二个参数对象的方法调用。jQuery.proxy()在调用时还可以传入对象作为第一个参数，传入属性名作为第二个参数。该名称代表的属性值应该是一个函数。通过这种方式调用，函数jQuery.proxy(o,n)的返回值与jQuery.proxy(o[n],o)一样。jQuery.proxy()的目的是用来与jQuery的事件处理程序绑定机制一起使用。如果绑定了一个代理函数，可以使用原始函数来解除绑定它。
- $.support：这个属性类似jQuery.browser，它用来做可移植的特性探测，而不是脆弱的浏览器探测。jQuery.support的值是一个对象，该对象的属性都是布尔值，用来指明浏览器特性的存在情况。
- $.trim()：该函数和ES5 中给字符串添加的trim()方法类似。它接受字符串作为唯一参数，返回的字符串开头和结尾处的空白字符都已移除。

## 选择器

## 插件扩展

开发jQuery插件非常简单。关键点是要知道jQuery.fn是所有jQuery对象的原型对象。示例：

```js
jQuery.fn.println = function() {
  //将所有参数合并成空格分隔的字符串
  var msg = Array.prototype.join.call(arguments , " ");
  //遍历jQuery对象中的每一个元素
  this.each(function() {
    //将参数字符串作为纯文本添加到每一个元素后面，并添加一个<br/>
    jQuery(this).append(document.createTextNode(msg).append("<br/>"));
  });
  //返回这个未加修改的jQuery对象，以便链式调用
  return this;
}
```

下面是一些值得留意的jQuery插件约定：

- 不要依赖 `$` 标识符
- 如果插件代码不返回自己的值，请确保返回jQuery对象以便链式调用
- 如果扩展方式拥有两个以上参数或配置选项，请允许用户能使用对象的方式传递选项
- 不要污染jQuery方法的命名空间。
- 如果插件需要绑定事件处理程序，请将所有这些处理程序放在事件命名空间中
- 如果插件需要使用data()方法与元素关联数据，请将所有数据值放在单一对象中，然后用与插件名相同的键值将该对象作为单一值存储。
- 用"jquery.plugin.js"这种文件命名方式保存插件代码到一个文件中（将"plugin"替换为插件名）。

```js
// 下面这个例子定义了一个新的:draggable过滤器，可用来仅返回拥有draggable=true属性的元素
// 使用上面定义的这个选择器，可以用$("img:draggable") 来选取可拖曳的图片，
// 而不用使用冗长的$("img[draggable=true]")。
jQuery.expr[';'].draggable = function(e) { return e.draggable === true; };
```

自定义选择器函数的第一个参数是候选的DOM元素。如果该元素匹配选择器，则返回true；否则返回false。许多自定义选择器只需要这一个元素参数，但实际上在调用它们时传入了4个参数。第二个参数是整数序号，表示当前元素在候选元素数组中的位置。候选元素数组作为第4个参数传入，选择器不应该修改它。第三个参数很有趣的:这是调用RegExp.exec()方法后返回的数组。如果有的话，该数组的第4个元素（序号是3）是伪类过滤器后面的圆括号中的值。圆括号和里面的任何引号都去除了，只留下参数字符串。下面是一个例子，用来说明如何实现一个:data(x) 伪类，该伪类只在元素拥有data-x属性时返回true

```js
jQuery.expr[':'].data = function(element, index, match, array) {
  // 注意: IE7及其以下版本不支持hasAttribute()
  return element.hasAttribute("data-" + match[3]);
};
```

## UI类库

## 总结

### 问题

1、如何同时使用prototype和jQuery？

- 先引入prototype，再引入jQuery。
- 使用 `jQuery.noConflict()` 将 `$` 函数改名。

2、转义

1. 对于html元素中的id属性，如果其中有":"号的时候，在使用js的getElementById()等方法时，不需要进行转义；在使用jquery时，则必须转义。又因为id是字符串，所以要用"\\"转义。

## 示例

**1、输入框输入限制：**

- 使用场景：文本框中不允许输入特殊字符
- 解决方法：监听keypress事件，不是数字、字母、下划线时返回false

**2、Ajax提交：**

post提交

```js
$.post('http://xxx/api',
    {
        key: 'value'
    },
    function (json, textStatus, jqXHR) {
        if (ajaxResponseIsOK(json)) {
            // ...
        }
    },
    "json"
);

$.ajax({
    type: "post",
    url: 'http://xxx/api',
    async: false,
    data: param,
    contentType: "application/json;charset=utf-8",
    dataType: "json",
    success: function (obj) {
        if (ajaxResponseIsOK(obj)) {
            // ...
        }
    }
});
```

3、jquery.form.js示例：

```js
$("#form").ajaxSubmit({
    async: true, //异步提交
    url: 'http://xxx/api', /*设置post提交到的页面*/
    type: "post", /*设置表单以post方法提交*/
    dataType: "json", /*设置返回值类型为文本*/
    success: function (res) {
        if (ajaxResponseIsOK(res)) {
            // ...
        }
    }
});
```

**4、返回值的通用处理：**

简易拦截器

```js
// 需要引入jQuery.js、layer.js
// 处理ajax返回值的函数
function ajaxResponseIsOK(json) {
    if (typeof json == 'string' && json.indexOf(':') > 0) { // 如果返回的是json字符串，转换成json对象
        json = eval('(' + json + ')');
    }
    if (json.Status == 401) { // 过期，重新登录
        simpleAlert(json.Message, 2, json.TargetLink);
        return false;
    } else if (json.Status == 403) { // 权限不足
        simpleAlert(json.Message, 2);
        return false;
    }
    return true;
}

// 弹出提示框
function simpleAlert(msg, icon, url) {
    layer.msg(msg, {
        icon: icon,
        time: 2500,
        shade: [0.4, '#FFF'],
        scrollbar: false,
        offset: 350
        //shift: 6//抖动
    }, function () {
        // 返回给定页面（error.html）
        if (url && typeof url == 'string') {
            location.href = url;
        }
    });
}
```

`<b style="color:yellow">说明：</b>`上面的方法需要在每个ajax回掉函数中都先调用 `ajaxResponseIsOK` 函数，并不方便，也容易遗漏！
