# Angular语法

## 事件绑定

事件绑定是模板指令中很好用的一部分。我们可以把相关事件的处理函数直接写在DOM中，这样做的最大好处就是可以从DOM结构上看出业务处理的形式，你知道当你点击这个节点时哪个函数被执行了。

- ng-change
- ng-click
- ng-dblclick
- ng-mousedown
- ng-mouseenter
- ng-mouseleave
- ng-mousemov
- ng-mouseover
- ng-mouseup
- ng-submit

对于事件对象本身，在函数调用时可以直接使用$event进行传递：

```html
<p ng-click="click($event)">点击</p>
<p ng-click="click($event.target)">点击</p>
```

## 表单控件

表单控件类的模板指令，最大的作用是它预定义了需要绑定的数据的格式。这样，就可以对于既定的数据进行既定的处理。

### form

form是核心的一个控件。ng对form这个标签作了包装。事实上，ng自己的指令是叫ng-form的，区别在于，form标签不能嵌套，而使用ng-form指令就可以做嵌套的表单了。

form的行为中依赖它里面的各个输入控制的状态的，在这里，我们主要关心的是form自己的一些方法和属性。从ng的角度来说，form标签，是一个模板指令，也创建了一个FormController的实例。这个实例就提供了相应的属性和方法。同时，它里面的控件也是一个NgModelController实例。

很重要的一点，form的相关方法要生效，必须为form标签指定name和ng-controller，并且每个控件都要绑定一个变量。form和控件的名字，即是$scope中的相关实例的引用变量名。

除去对象的方法与属性，form这个标签本身有一些动态类可以使用：

- ng-valid 当表单验证通过时的设置
- ng-invalid 当表单验证失败时的设置
- ng-pristine 表单的未被动之前拥有
- ng-dirty 表单被动过之后拥

form对象的属性有：

- $pristine 表单是否未被动过
- $dirty 表单是否被动
- $valid 表单是否验证通过
- $invalid 表单是否验证失败
- $error 表单的验证错误

其中的 `$error` 对象包含有所有字段的验证信息，及对相关字段的NgModelController实例的引用。它的结构是一个对象，key是失败信息，required，minlength之类的，value是对应的字段实例列表。

>注意，这里的失败信息是按序列取的一个。比如，如果一个字段既要求required，也要求minlength，那么当它为空时，$error中只有required的失败信息。只输入一个字符之后，required条件满足了，才可能有minlength这个失败信息。

```html
<form name="test_form" ng-controller="TestCtrl">
  <input type="text" name="a" required ng-model="a" />
  <input type="text" name="b" required ng-model="b" ng-minlength="2" />
  <span ng-click="see()">{{ test_form.$error }}</span>
</form>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl',
    function ($scope) {
      $scope.see = function () {
        console.log($scope.test_form.$error);
      }
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

### input

input是数据的最主要入口。ng支持HTML5中的相关属性，同时对旧浏览器也做了兼容性处理。最重要的，input的规则定义，是所属表单的相关行为的参照（比如表单是否验证成功）。

input控件的相关可用属性为：

- name 名字
- ng-model 绑定的数据
- required 是否必填
- ng-required 是否必填
- ng-minlength 最小长度
- ng-maxlength 最大长度
- ng-pattern 匹配模式
- ng-change 值变化时的回调

```html
<form name="test_form" ng-controller="TestCtrl">
  <input type="text" name="a" ng-model="a" required ng-pattern="/abc/" />
  <span ng-click="see()">{{ test_form.$error }}</span>
</form>
```

input控件，它还有一些扩展，这些扩展有些有自己的属性：

- input type="number" 多了 number 错误类型，多了 max，min 属性。
- input type="url" 多了 url 错误类型。
- input type="email" 多了 email 错误类型。

### checkbox

它也算是input的扩展，不过，它没有验证相关的东西，只有选中与不选中两个值：

```html
<form name="test_form" ng-controller="TestCtrl">
  <input type="checkbox" name="a" ng-model="a" ng-true-value="AA" ng-false-value="BB" />
  <span>{{ a }}</span>
</form>
<script>
var TestCtrl = function($scope){
  $scope.a = 'AA';
}
</script>
```

两点：

- controller 要初始化变量值。
- controller 中的初始化值会关系到控件状态（双向绑定）。

### radio

也是input的扩展。和checkbox一样，但它只有一个值了：

```html
<form name="test_form" ng-controller="TestCtrl">
  <input type="radio" name="a" ng-model="a" value="AA" />
  <input type="radio" name="a" ng-model="a" value="BB" />
  <span>{{ a }}</span>
</form>
```

### textarea

同input。

### select

这是一个比较牛B的控件。它里面的一个叫做ng-options的属性用于数据呈现。对于给定列表时使用。

最简单的使用方法，`x for x in list`

在 `$scope` 中，select绑定的变量，其值和普通的value无关，可以是一个对象

显示与值分别指定，`x.v as x.name for x in o`

加入分组的，`x.name group by x.g for x in o`

分组了还分别指定显示与值的，`x.v as x.name group by x.g for x in o`

示例：04_表单

如果参数是对象的话，基本也是一样的，只是把遍历的对象改成(key, value)：

```html
<form name="test_form" ng-controller="TestCtrl"
    ng-init="o={a: 0, b: 1}; a=o.a;">
  <select ng-model="a" ng-options="k for (k, v) in o" ng-change="show()">
  </select>
</form>
<form name="test_form" ng-controller="TestCtrl"
    ng-init="o={a: {name: 'AA', v: '00'}, b: {name: 'BB', v: '11'}}; a=o.a.v;">
  <select ng-model="a" ng-options="v.v as v.name for (k, v) in o" ng-change="show()">
  </select>
</form>
<form name="test_form" ng-controller="TestCtrl"
    ng-init="o={a: {name: 'AA', v: '00', g: '=='}, b: {name: 'BB', v: '11', g: '=='}}; a=o.a;">
  <select ng-model="a" ng-options="v.name group by v.g for (k, v) in o" ng-change="show()">
  </select>
</form>
<form name="test_form" ng-controller="TestCtrl"
    ng-init="o={a: {name: 'AA', v: '00', g: '=='}, b: {name: 'BB', v: '11', g: '=='}}; a=o.a.v;">
  <select ng-model="a" ng-options="v.v as v.name group by v.g for (k, v) in o" ng-change="show()">
  </select>
</form>
```

## 模板中的过滤器

这里说的过滤器，是用于对数据的格式化，或者筛选的函数。它们可以直接在模板中通过一种语法使用。对于常用功能来说，是很方便的一种机制。

多个过滤器之间可以直接连续使用。

### 排序 orderBy

orderBy 是一个排序用的过滤器标签。它可以像 sort 函数那样支持一个排序函数，也可以简单地指定一个属性名进行操作：

```html
<div ng-controller="TestCtrl">
  {{ data | orderBy: 'age' }} <br />
  {{ data | orderBy: '-age' }} <br />
  {{ data | orderBy: '-age' | limitTo: 2 }} <br />
  {{ data | orderBy: ['-age', 'name'] }} <br />
</div>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl',
    function($scope){
      $scope.data = [
        {name: 'B', age: 4},  
        {name: 'A', age: 1},  
        {name: 'D', age: 3},  
        {name: 'C', age: 3},  
      ];
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

### 过滤列表 filter

filter 是一个过滤内容的标签。

如果参数是一个字符串，则列表成员中的任意属性值中有这个字符串，即为满足条件（忽略大小写）：

```html
<div ng-controller="TestCtrl">
  {{ data | filter: 'b' }} <br />
  {{ data | filter: '!B' }} <br />
</div>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl', 
    function($scope){
      $scope.data = [
        {name: 'B', age: 4},  
        {name: 'A', age: 1},  
        {name: 'D', age: 3},  
        {name: 'C', age: 3},  
      ];
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

可以使用对象，来指定属性名，$ 表示任意属性：

```html
{{ data | filter: {name: 'A'} }} <br />
{{ data | filter: {$: '3'} }} <br />
{{ data | filter: {$: '!3'} }} <br />
```

自定义的过滤函数也支持：

```html
<div ng-controller="TestCtrl">
  {{ data | filter: f }} <br />
</div>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl', 
    function($scope){
      $scope.data = [
        {name: 'B', age: 4},  
        {name: 'A', age: 1},  
        {name: 'D', age: 3},  
        {name: 'C', age: 3},  
      ];
      $scope.f = function(e){
        return e.age > 2;
      }
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

### 其它

时间戳格式化 date ： 

```html
<div ng-controller="TestCtrl">
  {{ a | date: 'yyyy-MM-dd HH:mm:ss' }}
</div>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl', 
    function($scope){
      $scope.a = ((new Date().valueOf()));
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

列表截取 limitTo ，支持正负数： 

```html
{{ [1,2,3,4,5] | limitTo: 2 }}
{{ [1,2,3,4,5] | limitTo: -3 }}
```

大小写 lowercase ， uppercase ： 

```html
{{ 'abc' | uppercase }}
{{ 'Abc' | lowercase }}
```

### 例子：表头排序

```html
<div ng-controller="TestCtrl">
  <table>
    <tr>
      <th ng-click="f='name'; rev=!rev">名字</th>
      <th ng-click="f='age'; rev=!rev">年龄</th>
    </tr>
    <tr ng-repeat="o in data | orderBy: f : rev">
      <td>{{ o.name }}</td>
      <td>{{ o.age }}</td>
    </tr>
  </table>
</div>
<script type="text/javascript">
  angular.module('app', [], angular.noop).controller('TestCtrl', 
    function($scope){
      $scope.data = [
        {name: 'B', age: 4},  
        {name: 'A', age: 1},  
        {name: 'D', age: 3},  
        {name: 'C', age: 3},  
      ];
    }
  );
  angular.bootstrap(document.documentElement, ['app']);
</script>
```

### 例子：搜索

```html
<div ng-controller="TestCtrl" ng-init="s=data[0].name; q=''">
  <div>
    <span>查找：</span> <input type="text" ng-model="q" />
  </div>
  <select ng-multiple="true" ng-model="s" 
          ng-options="o.name as o.name + '(' + o.age + ')' for o in data
                            | filter: {name: q} | orderBy: ['age', 'name'] ">
  </select>
</div>
<script type="text/javascript">
  var TestCtrl = function($scope){
    $scope.data = [
      {name: 'B', age: 4},  
      {name: 'A', age: 1},  
      {name: 'D', age: 3},  
      {name: 'C', age: 3},  
    ];
  }
  angular.bootstrap(document.documentElement);
</script>
```

## 锚点路由

准确地说，这应该叫对 hashchange 事件的处理吧。 

就是指 URL 中的锚点部分发生变化时，触发预先定义的业务逻辑。比如现在是 /test#/x ，锚点部分的值为 # 后的 /x ，它就对应了一组处理逻辑。当这部分变化时，比如变成了 /test#/t ，这时页面是不会刷新的，但是它可以触发另外一组处理逻辑，来做一些事，也可以让页面发生变化。 

这种机制对于复杂的单页面来说，无疑是一种强大的业务切分手段。就算不是复杂的单页面应用，在普通页面上善用这种机制，也可以让业务逻辑更容易控制。 

ng 提供了完善的锚点路由功能，虽然目前我觉得相当重要的一个功能还有待完善（后面会说），但目前这功能的几部分内容，已经让我思考了很多种可能性了。 

ng 中的锚点路由功能是由几部分 API 共同完成的一整套方案。这其中包括了路由定义，参数定义，业务处理等。 

### 路由定义

要使用锚点路由功能，需要在先定义它。目前，对于定义的方法，我个人只发现在“初始化”阶段可以通过 $routeProvider 这个服务来定义。 

在定义一个 app 时可以定义锚点路由： 

```html
<html ng-app="ngView">
  ... ...
<div ng-view></div>
<script type="text/javascript">
  angular.module('ngView', [],
    function($routeProvider){
      $routeProvider.when('/test', {
        template: 'test',
      });
    }
  );
</script>
```

首先看 ng-view 这个 directive ，它是一个标记“锚点作用区”的指令。目前页面上只能有一个“锚点作用区”。有人已经提了“多个可命名”的锚点作用区的代码到官方，但是目前官方还没有接受合并，我觉得多个作用区这个功能是很重要的，希望下个发布版中能有。 

锚点作用区的功能，就是让锚点路由定义时的那些模板， controller 等，它们产生的 HTML 代码放在作用区内。 

比如上面的代码，当你刚打开页面时，页面是空白的。你手动访问 /#/test 就可以看到页面上出现了 'test' 的字样。 

在 angular.bootstrap() 时也可以定义： 

```js
angular.bootstrap(document.documentElement, [
  function($routeProvider){
    $routeProvider.when('/test', {
      template: 'test'
    });
  }
]);
```

### 参数定义

在作路由定义时，可以匹配一个规则，规则中可以定义路径中的某些部分作为参数之用，然后使用 `$routeParams` 服务获取到指定参数。比如 /#/book/test 中，test 作为参数传入到 controller 中：

```html
<div ng-view></div>
<script type="text/javascript">
  angular.module('ngView', [], function($routeProvider){
    $routeProvider.when('/book/:title', {
      template: '{{ title }}',
      controller: function($scope, $routeParams){
        $scope.title = $routeParams.title;
      }
    });
  }
);
</script>
```

访问：/#/book/test 

不需要预定义模式，也可以像普通 GET 请求那样获取到相关参数： 

```js
angular.module('ngView', [],
  function($routeProvider){
    $routeProvider.when('/book', {
      template: '{{ title }}',
      controller: function($scope, $routeParams){
        $scope.title = $routeParams.title;
      }
    });
  }
);
```

访问：/#/book?title=test 

### 业务处理

简单来说，当一个锚点路由定义被匹配时，会根据模板生成一个 $scope ，同时相应的一个 controller 就会被触发。最后模板的结果会被填充到 ng-view 中去。 

从上面的例子中可以看到，最直接的方式，我们可以在模板中双向绑定数据，而数据的来源，在 controller 中控制。在 controller 中，又可以使用到像 $scope，$routeParams 这些服务。 

这里先提一下另外一种与锚点路由相关的服务， $route 。这个服务里锚点路由在定义时，及匹配过程中的信息。比如我们搞怪一下： 

```js
angular.module('ngView', [],
  function($routeProvider){
    $routeProvider.when('/a', {
      template: '{{ title }}',
      controller: function($scope){
        $scope.title = 'a';
      }
    });
    $routeProvider.when('/b', {
      template: '{{ title }}',
      controller: function($scope, $route){
        console.log($route);
        $route.routes['/a'].controller($scope);
      }
    });
  }
);
```

回到锚点定义的业务处理中来。我们可以以字符串形式写模板，也可以直接引用外部文件作为模板：

```js
angular.module('ngView', [],
  function($routeProvider){
    $routeProvider.when('/test', {
      templateUrl: 'tpl.html',
      controller: function($scope){
        $scope.title = 'a';
      }
    });
  }
);
```

tpl.html 中的内容是： 

```html
{{ title }}
```

这样的话，模板可以预定义，也可以很复杂了。 

现在暂时忘了模板吧，因为前面提到的，当前 ng-view 不能有多个的限制，模板的渲染机制局限性还是很大的。不过，反正会触发一个 controller ，那么在函数当中我们可以尽量地干自己喜欢的事： 

```js
angular.module('ngView', [],
  function($routeProvider){
    $routeProvider.when('/test', {
      template: '{{}}',
      controller: function(){
        $('div').first().html('<b>OK</b>');
      }
    });
  }
);
```

那个空的 template 不能省，否则 controller 不会被触发。 

## 定义模板变量标识标签

由于下面涉及动态内容，所以我打算起一个后端服务来做。但是我发现我使用的 Tornado 框架的模板系统，与 ng 的模板系统，都是使用 `{{ }}` 这对符号来定义模板表达式的，这太悲剧了，不过幸好 ng 已经提供了修改方法：

```js
angular.bootstrap(document.documentElement, [
  function($interpolateProvider){
    $interpolateProvider.startSymbol('[[');
    $interpolateProvider.endSymbol(']]');
  }
]);
```

使用 $interpolateProvider 服务即可。 

## AJAX

ng 提供了基本的 AJAX 封装，你直接面对 promise 对象，使用起来还是很方便的。 

### HTTP请求

基本的操作由 `$http` 服务提供。它的使用很简单，提供一些描述请求的参数，请求就出去了，然后返回一个扩充了 success 方法和 error 方法的 promise 对象（下节介绍），你可以在这个对象中添加需要的回调函数。 

```js
angular.module('app', [], angular.noop)
.controller('TestCtrl', function($scope){
  var p = $http({
    method: 'GET',
    url: '/json'
  });
  p.success(function(response, status, headers, config){
      $scope.name = response.name;
  });
});
angular.bootstrap(document.documentElement, ['app']);
```

$http 接受的配置项有： 

- method 方法 
- url 路径 
- params GET请求的参数 
- data post请求的参数 
- headers 头 
- transformRequest 请求预处理函数 
- transformResponse 响应预处理函数 
- cache 缓存 
- timeout 超时毫秒，超时的请求会被取消 
- withCredentials 跨域安全策略的一个东西 

其中的 transformRequest 和 transformResponse 及 headers 已经有定义的，如果自定义则会覆盖默认定义： 

```js
var $config = this.defaults = {
  // transform incoming response data
  transformResponse: [function(data) {
    if (isString(data)) {
      // strip json vulnerability protection prefix
      data = data.replace(PROTECTION_PREFIX, '');
      if (JSON_START.test(data) && JSON_END.test(data))
        data = fromJson(data, true);
    }
    return data;
  }],

  // transform outgoing request data
  transformRequest: [function(d) {
    return isObject(d) && !isFile(d) ? toJson(d) : d;
  }],

  // default headers
  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'X-Requested-With': 'XMLHttpRequest'
    },
    post: {'Content-Type': 'application/json;charset=utf-8'},
    put:  {'Content-Type': 'application/json;charset=utf-8'}
  }
};
```

>注意它默认的 POST 方法出去的 Content-Type 

对于几个标准的 HTTP 方法，有对应的 shortcut ： 

- $http.delete(url, config) 
- $http.get(url, config) 
-	$http.head(url, config) 
-	$http.jsonp(url, config) 
-	$http.post(url, data, config) 
-	$http.put(url, data, config) 

注意其中的 JSONP 方法，在实现上会在页面中添加一个 script 标签，然后放出一个 GET 请求。你自己定义的，匿名回调函数，会被 ng 自已给一个全局变量。在定义请求，作为 GET 参数，你可以使用 JSON_CALLBACK 这个字符串来暂时代替回调函数名，之后 ng 会为你替换成真正的函数名： 

```js
var p = $http({
  method: 'JSONP',
  url: '/json',
  params: {callback: 'JSON_CALLBACK'}
});
p.success(function(response, status, headers, config){
    console.log(response);
    $scope.name = response.name;
});
```

$http 有两个属性： 

-	defaults 请求的全局配置 
-	pendingRequests 当前的请求队列状态 

```js
$http.defaults.transformRequest = function(data){console.log('here'); return data;}
console.log($http.pendingRequests);
```

### 广义回调管理

和其它框架一样， ng 提供了广义的异步回调管理的机制。 $http 服务是在其之上封装出来的。这个机制就是 ng 的 $q 服务。 

不过 ng 的这套机制总的来说实现得比较简单，按官方的说法，够用了。使用的方法，基本上是： 

- 通过 $q 服务得到一个 deferred 实例 
- 通过 deferred 实例的 promise 属性得到一个 promise 对象 
- promise 对象负责定义回调函数 
- deferred 实例负责触发回调 

```js
angular.module('app', [], angular.noop)
.controller('TestCtrl', function($scope){
    var defer = $q.defer();
    var promise = defer.promise;
    promise.then(function(data){console.log('ok, ' + data)},
               function(data){console.log('error, ' + data)});
    //defer.reject('xx');
    defer.resolve('xx');
});
```

了解了上面的东西，再分别看 $q ， deferred ， promise 这三个东西。 

#### $q

$q 有四个方法： 

- $q.all() 合并多个 promise ，得到一个新的 promise 
-	$q.defer() 返回一个 deferred 对象 
-	$q.reject() 包装一个错误，以使回调链能正确处理下去 
-	$q.when() 返回一个 promise 对象 

$q.all() 方法适用于并发场景很合适： 

```js
angular.module('app', [], angular.noop)
.controller('TestCtrl', function($scope){
  var p = $http.get('/json', {params: {a: 1}});
  var p2 = $http.get('/json', {params: {a: 2}});
  var all = $q.all([p, p2]);
  p.success(function(res){console.log('here')});
  all.then(function(res){console.log(res[0])});
});
```

`$q.reject()` 方法是在你捕捉异常之后，又要把这个异常在回调链中传下去时使用： 要理解这东西，先看看 promise 的链式回调是如何运作的，看下面两段代码的区别： 

```js
var defer = $q.defer();
var p = defer.promise;
p.then(
  function(data){return 'xxx'}
);
p.then(
  function(data){console.log(data)}
);
defer.resolve('123');

var defer = $q.defer();
var p = defer.promise;
var p2 = p.then(
  function(data){return 'xxx'}
);
p2.then(
  function(data){console.log(data)}
);
defer.resolve('123');
```

从模型上看，前者是“并发”，后者才是“链式”。而 `$q.reject()` 的作用就是触发后链的 error 回调： 

```js
var defer = $q.defer();
var p = defer.promise;
p.then(
  function(data){return data},
  function(data){return $q.reject(data)}
).
then(
  function(data){console.log('ok, ' + data)},
  function(data){console.log('error, ' + data)}
)
defer.reject('123');
```

最后的 `$q.when()` 是把数据封装成 promise 对象： 

```js
var p = $q.when(0, function(data){return data},
                   function(data){return data});
p.then(
  function(data){console.log('ok, ' + data)},
  function(data){console.log('error, ' + data)}
);
```

#### deferred

deferred 对象有两个方法一个属性。 

- promise 属性就是返回一个 promise 对象的。 
- resolve() 成功回调 
- reject() 失败回调 

```js
var defer = $q.defer();
var promise = defer.promise;
promise.then(function(data){console.log('ok, ' + data)},
             function(data){console.log('error, ' + data)});
//defer.reject('xx');
defer.resolve('xx');
```

####  promise

promise 对象只有 then() 一个方法，注册成功回调函数和失败回调函数，再返回一个 promise 对象，以用于链式调用。 

## 工具函数

### 上下文绑定

angular.bind 是用来进行上下文绑定，参数动态绑定的工具函数。 

```js
var f = angular.bind({a: 'xx'},
  function(){
    console.log(this.a);
  }
);
f();
```

参数动态绑定： 

```js
var f = function(x){console.log(x)}
angular.bind({}, f, 'x')();
```

### 对象处理

对象复制：`angular.copy()`

```js
var a = {'x': '123'};
var b = angular.copy(a);
a.x = '456';
console.log(b);
```

对象聚合：`angular.extend()`

```js
var a = {'x': '123'};
var b = {'xx': '456'};
angular.extend(b, a);
console.log(b);
```

空函数：`angular.noop()` 

大小写转换：`angular.lowercase()` 和 `angular.uppercase()`

JSON转换：`angular.fromJson()` 和 `angular.toJson()`

遍历：`angular.forEach()`，支持列表和对象： 

```js
var l = {a: '1', b: '2'};
angular.forEach(l, function(v, k){console.log(k + ': ' + v)});
var l = ['a', 'b', 'c'];
angular.forEach(l, function(v, i, o){console.log(v)});
var context = {'t': 'xx'};
angular.forEach(l, function(v, i, o){console.log(this.t)}, context);
```

### 类型判定

- angular.isArray 
- angular.isDate 
-	angular.isDefined 
-	angular.isElement 
-	angular.isFunction 
-	angular.isNumber 
-	angular.isObject 
-	angular.isString 
-	angular.isUndefined 

## 其它服务

### 日志

ng 提供 $log 这个服务用于向终端输出相关信息： 

-	error() 
-	info() 
-	log() 
-	warn() 

```js
angular.module('app', [], angular.noop)
.controller('TestCtrl', function($scope){
  $log.error('error');
  $log.info('info');
  $log.log('log');
  $log.warn('warn');
});
```

### 缓存

ng 提供了一个简单封装了缓存机制 $cacheFactory ，可以用来作为数据容器： 

```js
var TestCtrl = function($scope, $cacheFactory){
  $scope.cache = $cacheFactory('s_' + $scope.$id, {capacity: 3});

  $scope.show = function(){
    console.log($scope.cache.get('a'));
    console.log($scope.cache.info());
  }

  $scope.set = function(){
    $scope.cache.put((new Date()).valueOf(), 'ok');
  }
}
```

调用时，第一个参数是 id ，第二个参数是配置项，目前支持 capacity 参数，用以设置缓存能容留的最大条目数。超过这个个数，则自动清除较旧的条目。 

缓存实例的方法： 

-	info() 获取 id , size 信息 
-	put(k, v) 设置新条目 
-	get(k) 获取条目 
-	remove(k) 删除条目 
-	removeAll() 删除所有条目 
-	destroy() 删除对本实例的引用 

$http 的调用当中，有一个 cache 参数，值为 true 时为自动维护的缓存。值也可以设置为一个 cache 实例。 

### 计时器

$timeout 服务是 ng 对 window.setTimeout() 的封装，它使用 promise 统一了计时器的回调行为： 

```js
angular.module('app', [], angular.noop)
.controller('TestCtrl', function($scope){
  var p = $timeout(function(){console.log('haha')}, 5000);
  p.then(function(){console.log('x')});
  //$timeout.cancel(p);
});
```

使用 $timeout.cancel() 可以取消计时器。 

### 表达式函数化

$parse 这个服务，为 js 提供了类似于 Python 中 @property 的能力： 

```js
angular.module('app', [], angular.noop)
.controller('TestCtrl', function($scope){
  $scope.get_name = $parse('name');
  $scope.show = function(){console.log($scope.get_name($scope))}
  $scope.set = function(){$scope.name = '123'}
});
```

$parse 返回一个函数，调用这个函数时，可以传两个参数，第一个作用域，第二个是变量集，后者常用于覆盖前者的变量： 

```js
var get_name = $parse('name');
var r = get_name({name: 'xx'}, {name: 'abc'});
console.log(r);
```

$parse 返回的函数，也提供了相应的 assign 功能，可以为表达式赋值（如果可以的话）： 

```js
var get_name = $parse('name');
var set_name = get_name.assign;
var r = get_name({name: 'xx'}, {name: 'abc'});
console.log(r);

var s = {}
set_name(s, '123');
var r = get_name(s);
console.log(r);
```

### 模板单独使用

ng 中的模板是很重要，也很强大的一个机制，自然少不了单独运用它的方法。不过，即使是单独使用，也是和 DOM 紧密相关的程度： 

-	定义时必须是有 HTML 标签包裹的，这样才能创建 DOM 节点 
-	渲染时必须传入 $scope 

之后使用 $compile 就可以得到一个渲染好的节点对象了。当然， $compile 还要做其它一些工作，指令处理什么的。 

```js
angular.module('app', [], angular.noop)
.controller('TestCtrl', function($scope){
  $scope.a = '123';
  $scope.set = function(){
    var tpl = $compile('<p>hello {{ a }}</p>');
    var e = tpl($scope);
    $element.append(e);
  }
});
```

## 自定义模块和服务

### 模块和服务的概念与关系

总的来说，模块是组织业务的一个框框，在一个模块当中定义多个服务。当你引入了一个模块的时候，就可以使用这个模块提供的一种或多种服务了。

比如 AngularJS 本身的一个默认模块叫做 ng ，它提供了 $http ， $q 等等服务。

服务只是模块提供的多种机制中的一种，其它的还有命令（ directive ），过滤器（ filter ），及其它配置信息。

然后在额外的 js 文件中有一个附加的模块叫做 ngResource ， 它提供了一个 $resource 服务。

定义时，我们可以在已有的模块中新定义一个服务，也可以先新定义一个模块，然后在新模块中定义新服务。

使用时，模块是需要显式地的声明依赖（引入）关系的，而服务则可以让 ng 自动地做注入，然后直接使用。

### 定义模块

定义模块的方法是使用 angular.module 。调用时声明了对其它模块的依赖，并定义了“初始化”函数。

```js
var my_module = angular.module('MyModule', [], function(){
  console.log('here');
});
```

这段代码定义了一个叫做 MyModule 的模块， my_module 这个引用可以在接下来做其它的一些事，比如定义服务。

### 定义服务

服务本身是一个任意的对象。但是 ng 提供服务的过程涉及它的依赖注入机制。在这里呢，就要先介绍一下叫 provider 的东西。

简单来说， provider 是被“注入控制器”使用的一个对象，注入机制通过调用一个 provider 的 $get() 方法，把得到的东西作为参数进行相关调用（比如把得到的服务作为一个 Controller 的参数）。

在这里“服务”的概念就比较不明确，对使用而言，服务仅指 $get() 方法返回的东西，但是在整体机制上，服务又要指提供了 $get() 方法的整个对象。

```js
//这是一个provider
var pp = function(){
  this.$get = function(){
    return {'haha': '123'};
  }
}

//我在模块的初始化过程当中, 定义了一个叫 PP 的服务
var app = angular.module('Demo', [], function($provide){
  $provide.provider('PP', pp);
});

//PP服务实际上就是 pp 这个 provider 的 $get() 方法返回的东西
app.controller('TestCtrl',
  function($scope, PP){
    console.log(PP);
  }
);
```

上面的代码是一种定义服务的方法，当然， ng 还有相关的 shortcut， ng 总有很多 shortcut 。

第一个是 factory 方法，由 $provide 提供， module 的 factory 是一个引用，作用一样。这个方法直接把一个函数当成是一个对象的 $get() 方法，这样你就不用显式地定义一个 provider 了：

```js
var app = angular.module('Demo', [], function($provide){
  $provide.factory('PP', function(){
    return {'hello': '123'};
  });
});
app.controller('TestCtrl', function($scope, PP){ console.log(PP) });
```

在 module 中使用：

```js
var app = angular.module('Demo', [], function(){ });
app.factory('PP', function(){return {'abc': '123'}});
app.controller('TestCtrl', function($scope, PP){ console.log(PP) });
```

第二个是 service 方法，也是由 $provide 提供，module 中有对它的同名引用。 service 和 factory 的区别在于，前者是要求提供一个“构造方法”，后者是要求提供 $get() 方法。意思就是，前者一定是得到一个 object ，后者可以是一个数字或字符串。它们的关系大概是：

```js
var app = angular.module('Demo', [], function(){ });
app.service = function(name, constructor){
  app.factory(name, function(){
    return (new constructor());
  });
}
```

这里插一句，js 中 new 的作用，以 new a() 为例，过程相当于：

- 创建一个空对象 obj
- 把 obj 绑定到 a 函数的上下文当中（即 a 中的 this 现在指向 obj ）
- 执行 a 函数
- 返回 obj

service 方法的使用就很简单了：

```js
var app = angular.module('Demo', [], function(){ });
app.service('PP', function(){
  this.abc = '123';
});
app.controller('TestCtrl', function($scope, PP){ console.log(PP) });
```

### 引入模块并使用服务

结合上面的“定义模块”和“定义服务”，我们可以方便地组织自己的额外代码：

```js
angular.module('MyModule', [], function($provide){
  $provide.factory('S1', function(){
    return 'I am S1';
  });
  $provide.factory('S2', function(){
    return {see: function(){return 'I am S2'}}
  });
});

var app = angular.module('Demo', ['MyModule'], angular.noop);
app.controller('TestCtrl', function($scope, S1, S2){
  console.log(S1)
  console.log(S2.see())
});
```
