# 禅道

## 目录

1. [简介](#简介)
2. zentaoPHP框架快速入门
   - [helloworld](#helloworld)
   - [zentaoPHP框架基础](#zentaoPHP框架基础)
     - [两种请求方式](#两种请求方式)
     - [如何生成链接](#如何生成链接)
     - [框架页内HTML、CSS、JS](#框架页内HTML、CSS、JS)
   - [深入zentaoPHP框架](#深入zentaoPHP框架)
     - [DAO功能](#DAO功能)
     - [分页解决方案](#分页解决方案)
     - [数据验证](#数据验证)
3. [zentaoPHP二次开发简介](#zentaoPHP二次开发简介)
   - 扩展机制
     - [扩展机制简介](#扩展机制简介)
     - [对控制层(control)扩展](#对控制层(control)扩展)
     - [对模型层(model)扩展](#对模型层(model)扩展)
     - [对视图层(view)扩展](#对视图层(view)扩展)
     - [对样式表和js进行扩展](#对样式表和js进行扩展)
     - [对语言配置进行扩展](#对语言配置进行扩展)
     - [增加新的类库](#增加新的类库)
   - api机制
     - [api机制简介](#api机制简介)
     - [需要登录验证的api调用](#需要登录验证的api调用)
   - [命令行机制](#命令行机制)
4. 禅道二次开发
   - [禅道目录结构](#禅道目录结构)
   - [找到要修改的文件](#找到要修改的文件)
5. [参考](#参考)

## 简介

**目录结构：**

- 其中config目录存储配置文件。
- db目录存储的是demo演示所用的blog表的定义。
- www/favicon.ico是网站小图标文件。
- framework则是框架的核心目录，里面包含了router, control, model和helper的定义文件。
- www/index.php是入口程序，所有的请求都经由index.php来进行转发。
- www/js目录用来存放js脚本文件。
- lib目录用来存放常用的类文件。
- module则是模块目录，所有的功能模块都放在这个目录下面。
- www/theme则用来放样式表和图片文件。

打开[项目](http://localhost:8090/zentaopms/www/user-login-L3plbnRhb3Btcy93d3cv.html)

数据库[配置](./config/my.php)

## helloworld

MVC模式：

- [代码](./module/hello/control.php)
- [运行](http://localhost:8090/zentaopms/www/hello-world)

## zentaoPHP框架基础

zentaoPHP框架的所有请求都是通过index.php来进行的。它的基本原理是通过设置apache或者其他webserver，将所有的请求都转交给index.php。index.php加载框架文件，初始化应用，然后分析请求，得到请求对应对模块名、方法和参数，然后加载相应模块的control方法，model方法，后渲染模板，展示给用户。基本的模型如下：

![x](./Resource/请求流程.png)

### 两种请求方式

zentaoPHP框架共支持两种方式，一种是传统的GET方式，一种是静态友好的方式。

1. 传统GET方式

   可以在config/my.php里面设置requestType为GET来启用GET方式。当打开GET方式之后，访问地址格式如下：

   index.php?m=$moduleName&f=$methodName&$param1=$value1&param2=valur2&t=html

   - m: 代表模块名称，比如m=blog，则代表访问blog模块。
   - f: 代表要访问的模块control里面的方法名，比如f=edit，代表访问blog/control.php里面定义的edit方法。
   - t: 代表模板类型，默认是html，比如f=edit&t=html，对应的模板文件是blog/view/edit.html.php。

   其他的都是参数，也就是变量中指定的方法的参数。比如id=1，则代表终调用blog/control.php里面的edit方法，并向其传id=1的参数。

2. 静态友好方式

   静态友好方式需要webserver的url重写支持。如果是使用apache作为webserver的话，框架已经自带了.htaccess文件，里面已经包含了url重写规则。

   如果是nginx，需要配置下面的参数：

   ```$xslt
   location /
    {
        try_files $uri $uri/ /index.php?$args;
    }
    location ~ \.php$
    {
        fastcgi_pass  unix:/var/run/php5-fpm.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $request_uri;
        include modules-enabled/fastcgi.conf;
    }
   ```

   与此同时还需要修改config/my.php，把requestType设置成PATH_INFO。还有一个变量分隔符，需要设置。框架默认的是短横线:-。

   比如访问 `http://localhost/zentaophp/blog/view/179.html`：blog为模块名，view是方法名，179是参数，.html则代表了模板的类型。

### 如何生成链接

因为zentaoPHP框架有两种运行方式，所以在生成链接的时候，尽量不要手工拼写链接代码，通过调用系统提供的createLink方法，来生成链接。

1. $this->createLink()方法

   比如，我们要生成一个blog模块的view方法的链接，需要传递参数为id=17，这样来调用：

   ```$xslt
   echo $this->createLink('blog', 'view', 'id=17&cat=123')
   ```

   第一个参数是模块名称，第二个参数是方法名，第三个参数是参数，使用key1=value1&key2=value2这种方式来进行传参。

   如果运行方式为PATH_INFO，这样会生成 blog-view-17-123.html这样的链接。

   如果运行方式为GET，则生成?m=blog&f=view&id=17&cat=123&t=html的链接。

2. helper::createLink()方法

   $this->createLink()方法，是可以在control和view里面直接调用的。如果需要在其他地方调用，则可以使用helper::createLink()，参数是一样的。

3. JS版本的createLink()方法

   另外，我们还提供了一个js版本的createLink()函数，用来在js交互中生成一些链接。具体的代码，可以参考app/demo/www/js/my.js里面的定义。

   不过在调用js版本的createLink()之前，需要调用下js::exportVars()方法，来输出下当前系统的配置参数。

### 框架页内HTML、CSS、JS

禅道框架里面提供了一个front.class.php，里面内置了三个类，分别为html, js和css，用来生成一些html标签，创建简单的js交互。

一、html类

- `html::title($title)`  生成$title标签。
- `html::meta($name, $value)` 生成html的meta标签。
- `html::icon($url)` 生成icon文件的调用代码。
- `html::rss($url, $title)` 输出rss。
- `html::a($href, $title, $target, $misc)`，生成超链接。
- `html::mailto($mailto, $title)` 生成mailto 链接。
- `html::select($name, $options, $selected, $attr)`，生成标签。
- `html::radio($name, $options, $selected, $attr)`, 生成单选按钮。
- `html::checkbox($name, $options, $selected, $attr)`，生成复选按钮。
- `html::input($name, $value, $attr)` 生成文本框。
- `html::hidden($name, $value, $attr)`生成隐藏变量。
- `html::password($name, $value, $attr)`生成密码框。
- `html::textarea($name, $value, $attr)`生成textarea
- `html::file($name, $attr)`生成文件选择框。
- `html::submitButton($label, $attr)` 生成提交按钮。
- `html::resetButton()`，生成重置按钮。
- `html::commonButton($label, $attr)` 生成一个普通的按钮。
- `html::linkButton($label, $link, $attr)`，生成一个带有链接的按钮。

二、JS类

- `js::import($url, $version)` 生成一个js文件的调用。version用来区分不同的版本，以避免客户端js文件不刷新的问题。
- `js::alert($message)`，生成一个警告框
- `js::error($errors)`，错误警告，$errors可以是数组。
- `js::confirm($message, $okURL, $cancelURL, $okTarget, $cancelTarget)`，选择提示。
- `js::locate($url, $target)`，跳转页面， target是要跳转的窗口。
- `js::closeWindow()`, 关闭窗口。
- `js::refresh($url, $target, $timeout)`，刷新页面。
- `js::reload($window)`, 自动重载某一个窗口。
- `js::exportConfigVars()`，将$config里面框架运行的必需信息输出到js中。
- `js::execute($code)`，执行某一段js代码。

三、css类

- `css:import($url, $version)`, 导入某一个css文件。
- `css::internal($css)`，生成code

## 深入zentaoPHP框架

模块的目录结构：

- **config.php**: 这个模块的配置文件，可以用来存放专门针对这个模块的配置，也可以覆盖全局性的配置。
- **lang**: 存放各个语言的文件。比如中文存为zh-cn.php，英语存为en.php，繁体存为zh-tw.php。
- **control.php** 为这个模块对应的控制器类文件。
- **model.php** 为这个模块对应的业务逻辑类文件。
- **view**：存放的各个方法的视图文件。比如index.html.php是index方法的模板文件

common模块需要特殊说明一下：common模块里面存储的是当前这个应用公用的语言文件、模板文件、model文件等。比如lang/zh-ch.php将存储一些公用的语言文件。header.html.php是模板公用的头文件。footer.html.php是模板公用的页脚文件。error.html.php则是公用的出错信息提示的模板文件

### DAO功能

zentaoPHP并没有试着去实现ORM或者ActiveRecord这样的概念。因为我们相信，框架要留给开发人员足够的自由发挥的空间，而不是所有的都要包办。所以框架里面提供了一个简单方便的数据库访问对象类DAO。并且我们在封装DAO的时候尽可能的兼容标准的sql写法。

DAO类的定义在lib下面的dao.class.php中。框架在加载的时候，会自动生成`$this->dao`对象，可以在control, model或者view层的代码中直接使用`$this->dao`来执行各种方法。

如果是查询类的语句，需要使用fetch系列的方法来返回数据。更新，删除，替换这些方法可以使用`exec()`方法。

DAO在后执行的时候，有下面的方法：

- `fetch()`: 获得满足条件的第一次记录，返回的是对象格式。
- `fetch($filed)`：获得满足条件的第一个记录的字段$field对应的值。
- `fetchAll()`：获得满足条件的所有记录，以数组格式返回，索引为0-n
- `fetchAll($key)`: 获得满足条件的所有记录，并使用字段$key作为索引值。
- `fetchPairs($key, $value)`：返回键值对的列表。如果不指定参数，则取返回记录中的第一个字段作为key，第二个字段作为value。
- `fetchGroup($group, $key)`：把满足条件的记录按照`$group`字段进行分组。比如把所有`$status=active`的放在一起。

为了书写的方便，DAO类里面封装了若干操作符：

- eq: equal，等于
- ne: not equal，不等于
- gt: great than, 大于
- lt: little than, 小于
- in: 介于一个列表中。
- between: 在一个区间中。
- notin：不在一个列表中。
- like: 模糊匹配。

普通的查询：查询account=wwccss的记录。

```php
$this->dao->select('*')
->from('user')
->where('account')
->eq('wwccss')
->fetch();
```

再复杂一点，加入andWhere (或者orWhere)

```php
$this->dao->select('*')->from('user')
->where('id')->gt(10)
->andWhere('age')->lt(20)
->orderBy('id desc')
->limit('1,10')
->fetchAll()
```

左连接查询

```php
$this->dao->select('t1.*, t2.*')->from('user')->alias('t1')->leftJoin('userGroup')->alias('t2')->on('t1.account = t2.account')->fetchAll();
```

其他便利的方法：

```php
$this->dao->findByAccount($account)->from('user')->fetch(); // 魔术方法，按照account进行查询。
$this->dao->select('*')->from('user')->fetchAll('account'); // 返回的结果中，以account为key。
$this->dao->select('account, realname')->from('user')->fetchPairs(); // 返回account=>realname的键值对。
$this->dao->select('class, account, realname')->from('user')->fetchGroup('class'); // 按照所属的class进行分组
```

根据条件拼装SQL：beginIF, FI()

```php
$this->dao->select('*')->from('user')->where('id')->gt(10)->beginIF($class == 'online')->andWhere('status')->eq('online')->fi()->fetchAll();
```

使用一个data对象来更新。data对象的key对应到数据表中字段名。

```php
$user->account = 'wwccss';
$user->password = '123456';
$this->dao->insert('user')->data($user)->exec();
```

或者一个字段一个字段更新：

```php
$this->dao->insert('user')
->set('account')->eq($account)
->set('password')->eq($password)
->exec();
```

获得后插入的记录id

```php
echo $this->dao->lastInsertID();
```

更新语句和insert基本类似，可以使用一个data对象或者单个字段进行更新。

```php
$user->name = 'wwccss';
$user->age = 10;

$this->dao->update('user')->data($user)->where('id')->eq($userid)->limit(1)->exec();

$this->dao->update('user')
->set('account')->eq($account)
->set('password')->eq($password)
->exec()
```

replace也是需要定义一个data对象，然后调用replace方法。需要注意的是replace要保证表有主键或者唯一索引。

```php
$this->dao->replace('user')->data($user)->exec();
```

删除语句：

```php
$this->dao->delete()->from('user')->where('id')->eq($userid)->exec();
```

### 分页解决方案

以查询用户列表为例，在应用中建立一个user的模块，在其中的control文件中，定义一个browse方法，来完成分页的功能：

**一、browse方法关于分页的三个参数：**

browse方法需要定义三个参数：recTotal, recPerPage, pageID，变量名是固定的。

```php
public function browse($recTotal, $recPerPage, $pageID)
{
    /* 加载分页类，并生成pager对象。*/
    $this->app->loadClass('pager', $static = true);
    $pager = new pager($recTotal, $recPerPage, $pageID);
    /* 将分页类传给model，进行分页。*/
    $users = $this->user->getList($pager);
}
```

**二、model方法中调用pager对象：**

model中定义一个getList方法，接收pager对象，并在dao查询的时候，调用pager($pager)方法来生成分页语句。

```php
public function getList($pager)
{
    return $this->dao->select(*)->from('user')->page($pager)->fetchAll();
}
```

**三、control中将pager对象赋值给模板：**

再回到control的browse方法中，将pager对象赋值给模板。

```php
public function browse($recTotal, $recPerPage, $pageID)
{
    /* 加载分页类，并生成pager对象。*/
    $this->app->loadClass('pager', $static = true);
    $pager = new pager($recTotal, $recPerPage, $pageID);
    /* 将分页类传给model，进行分页。*/
    $users = $this->user->getList($pager);

    /* 赋值到模板。*/
    $this->view->users = $users;
    $this->view->pager = $pager;
}
```

模板中显示分页链接：show()方法有两个参数，`$align`: left, center, right，默认是居右对齐。`$type`: full|short|shortest

```php
<?php $pager->show();?>
```

### 数据验证

mvc程序中，每一层都可以放验证规则。比如很多的表单验证，会自动根据用户的输入进行验证，然后给予提示。那么数据验证放在哪一层呢？这个问题网络上大家有很多的争议。有的人主要放在view这一层，有的则主张放在control层。zentaoPHP选择了model层。

为什么这样做呢？因为model层是底层，所有的数据操作，都要经过model来进行处理。那么只要在这一关把数据验证做好，就可以保证数据的准确和安全。当然，框架的用户，可以同时在前端加上js的验证，和model层的验证不会冲突的。下面来看下如何使用禅道的数据过滤机制。

受php的filter机制启发，禅道的数据过滤分为两个部分，一个是数据修正，一个是数据验证。首先是要对从客户端传递过来的数据进行修正，然后再对数据进行校验。

验证类是在lib/filter/filter.class.php里面定义的。

首先来看代码：

```php
$bug = fixer::input('post')
->add('openedBy', $this->app->user->account)
->add('openedDate', $now)
->setDefault('project,story,task', 0)
->setDefault('openedBuild', '')
->setIF($this->post->assignedTo != '', 'assignedDate', $now)
->setIF($this->post->story != false, 'storyVersion', $this->loadModel('story')->getVersion($this->post->story))
->specialChars('title,steps,keyword')
->cleanInt('product, module, severity')
->join('openedBuild', ',')
->remove('files, labels')
->get();
```

- 首先，是调用fixer这个类的input方法，它的参数post表示是从$_POST这个变量中获取数据。
- 紧接着的两行add()，是向数据中增加两个变量。
- 然后后面的两行setDefault则是表示，当这个变量没有传值的时候，设成默认的值。
- 接下来是两行setIF。setIF共有三个参数，第一个是判断条件，后面两个分别是key和value。也就是当条件为true的时候，设置$key = $value。
- 下面的spechialchars则表示对这三个字段进行htmlspecialchars处理;cleanInt则将变量处理成int类型，join，则将openedBuild使用，连接起来。
- 最后，还需要把两个不需要的变量去掉，使用remove。
- 通过get方法就可以得到一个已经经过修改的完整的数据集合。这个集合已经可以准备入库了。让我们来看下数据是如何验证的。

```php
$this->dao->insert(TABLE_BUG)->data($bug)
->autoCheck()
->batchCheck('id, name', 'notempty')
->exec();
```

这句sql插入语句通过data方法，将修正过的数据传递给dao对象，然后通过autoCheck()对其进行自动检查。autoCheck会根据数据库里面字段的类型，长度进行判断。如果类型不对，或者长度不对，会自动记录错误。然后后面调用了batchCheck()方法，对一批字段进行非空的验证。
当然也可以通过check()方法对单个字段进行验证。验证的规则有很多，比如notempty, unique, email, account等等。

如果数据验证过程中没有错误，则执行了exec()方法，将数据插入数据库。

如果有错呢？exec()方法什么都不会执行，但会记录到错误日志中。可以在control中里面判断是否有错误。

```php
if(dao::isError()) die(js::error(dao::getError()));
```

如果有错误，用js警告框的方式弹出，然后重置错误日志。  

数据修正方法：

- cleanEmail:    将目标字段处理为email
- encodeURL：    将目标字段进行urlencode
- cleanURL：     将目标字段中不符合url标准的字符去掉。
- cleanFloat：   将目标字段处理为float类型。
- cleanINT       将目标字段处理为int类型。
- specialChars： 对目标字段使用htmlspecialchars处理。
- stripTags：    去除目标字段中的标签。
- quote：        对目标字段做quote处理。
- setDefault：   对目标字段设置默认值。如果用户有传值，使用用户传的值。
- setIF：        当满足某个条件的时候，对每个字段进行设置。
- setForce：     强制覆盖某个字段的值。
- remove：       删掉某一个字段。
- removeIF：     满足某个条件的时候删除某一个字段。
- add：          添加某一个字段。
- addIF：        当满足某个条件的时候，添加某一个字段。
- join：         对目标字段使用逗号连接起来。
- callFunc:      使用自定义函数对数据进行修正。

数据检查方法：

- bool:     目标字段必须是布尔型。
- int:      目标字段必须是int类型。
- float:    目标字段必须是float类型。
- email:    目标字段必须是email类型。
- url:      目标字段必须是url 类型。
- ip:       目标字段必须是ip地址。有一个可选参数：$range all|public|static|private
- date：    目标字段必须是一个日期格式。
- reg:      目标字段必须满足正则表达式。
- length:   长度要满足指定的大小。
- notEmpty: 目标字段不能为空。
- empty:    目标字段必须为空。
- account:  目标字段必须是一个合法的用户名。
- equal:    目标字段必须等于某一个值。
- call:     调用用户自己的检查函数。

## zentaoPHP二次开发简介

每一个应用都会涉及到扩展方面的问题、和外面系统集成的问题。zentaoPHP框架也在这几个方面做了充分的工作，方便大家通过二次开发来满足这些需求。总体来讲，zentaoPHP框架提供了扩展机制、API集成和命令行调用机制工三种方式来满足大家的需求。

- **扩展机制**：可以使用PHP、HTML、CSS或者JS代码来对现有的代码功能进行改动，或者新增功能。
- **API接口**：可以通过http方式调用使用zentaoPHP框架开发的应用，和其他系统进行集成。
- **命令行**：可以通过命令行调用应用内部的方法，可以用来做备份、更新、发信等操作。

### 扩展机制简介

使用zentaoPHP开发的应用都是由一个个的模块组成的。每个模块会对应到module下面的一个目录，比如user模块。每个模块按照mvc进行划分，有自己的control(控制层)、 model(模型层)和view(视图层)。同时我们还补充了其他几个辅助的概念：config(配置)、lang(语言)、 css(样式)和js(js脚本)。通过zentaoPHP框架的扩展机制，可以实现对任一层的扩展。

下面是一个扩展代码的目录结构：

```txt
user/control.php
user/model.php
user/view/{metho1.html.php, method2.html.php, ...}
user/config/config.php
user/css/{method1.css, method2.css, common.css, ...}
user/js/{method1.js, method2.js, common.js, ...}
user/ext/control/{method1.php, method2.php, ...}
user/ext/model/{extend1.php, extend2.php, ...}
user/ext/view/{method1.html.php, method2.html.php, ...}
user/ext/config/{config1.php, config2.php, ...}
user/ext/lang/zh-cn/{lang1.php, lang2.php, ...}
user/ext/lang/en/{lang1.php, lang2.php, ...}
user/ext/css/method1/{1.css, 2.css, ...}
user/ext/js/method1/{1.js, 2.js, ...}
```

开发者只要按照这种扩展机制，把相应的扩展代码部署到对应的目录，即可实现对现有功能的重新定义或者新增功能。因为扩展代码和主干代码是分离的，所以就不用担心主干代码升级时会覆盖扩展代码。就可以做到放心的升级。

新增模块是简单的。只需要按照zentaoPHP框架的结构，在module目录下面创建一个目录，比如叫做pay，然后按照zentaoPHP框架的约定，分别实现相应的control, model, view, css, js, lang等概念即可。

### 对控制层(control)扩展

对现有模块的control层的扩展有两种，一种是覆盖现有的方法，一种是增加新的方法。下面我们来看下如何进行扩展。

**一、文件命名规则：**

无论是覆盖现有的方法，还是新增方法，扩展文件都是以方法名为名，保存到ext/control目录下面。文件名都是小写。

比如以user模块为例，我们想重新定义它的注册逻辑，只需要在module/user/ext/control下面创建register.php，然后实现代码即可。

如果我们想为user模块增加一个开放登录功能，比如叫做oauth，只需要在module/user/ext/control下面创建oauth.php，然后实现代码即可。

**二、独立扩展代码：**

在对control层进行扩展的时候，可以完全独立，也可以重用主干代码在control里面定义的方法。下面的例子是完全的独立的。

```php
class user extends control
{
    public function register()
    {
        $this->view->header->title = 'getsid';
        $this->view->sid = session_id();
        $this->view->test = $this->misc->test();
        $this->display();
    }
}
```

请大家注意类名的定义：user，从control基类派生而来。这样的定义是完全独立的。

**三、继承扩展：**

上面的例子是独立的扩展，但很多时候还想重用禅道原来的代码，则可以通过继承扩展的方式来实现。

```php
include '../../control.php';
class myUser extends user
{
    public function register()
    {
        ....
        $this->process() // process方法是在../../control.php里面定义
    }
}
```

首先需要手工包含../../control.php，然后类名定义是 myUser(my + 模块名)，从user类派生而来，这样就可以在register方法里面调用../../control.php里面定义的process方法了。

**四、限制：**

由于框架加载机制的限制，control一个方法只能有一个扩展。

### 对模型层(model)扩展

model为模型方法，主要用来处理各种数据的查询、更新。model的扩展分为三种方式，一种是直接新增或者覆盖方法，一种是通过钩子来实现，第三种则是完全定义一个新的类，下面分别来讲述下各自实现的机制。

**一、直接新增或者覆盖方法：**

不管是新增方法还是覆盖现有的方法，都是在模块的ext/model/目录下面建立相应的以方法为名的文件。比如，我们打算对misc的model新增一个方法，叫做foo，那么只需要在misc/ext/model/下面建立foo.php，代码如下：

```php
public function foo()
{
    return 'foo';
}
```

需要说明的是这里面的定义<b style="color:red">不包含类的声明</b>，就只是一个方法的声明。禅道框架在执行的时候，会自动将扩展目录下面的foo.php里面的代码，替换misc/model.php中的foo方法的代码。如果是新增的方法，则会追加到misc/model.php的代码中，最终生成一个合并之后的model类文件。

**二、通过钩子来扩展：**

除了新增或者覆盖方法之外，还可以通过钩子方式来扩展。所有的钩子都是存放在ext/model/hook目录下面，文件命名规则是：方法名.扩展名.php

比如我对misc模块中的helllo方法进行钩子的扩展，在misc/ext/model/hook/下面创建hello.abc.php的文件，然后在里面实现代码就可以了。

禅道框架会把某一个方法的所有的钩子代码合并到终的代码中。

<b style="color:red">不过这种方法有很多限制，会有意想不到的行为，不建议大家使用。</b>

**三、通过类的方式来扩展：**

除了上面两种方式之外，model的扩展还有第三种方式，就是将所有的扩展放在一个类里面，然后通过框架的loadExtension()方法来加载。这种主要是为了解决加密文件冲突的问题。zentaoPHP框架在处理model的扩展时，会把相应的代码进行合并，但这时候问题就来了。如果对第一种方法的扩展，也就是exe/model/abc.php进行加密，就会和其他的开源的model扩展冲突。如果不加密，无法保护作者的代码。为了解决这个问题，我们特地实现了第三种扩展方法，下面我们来说明下：

**3.1 在ext/model/class/下面创建一个类，文件名的规则是插件名.class.php。**

比如我们的甘特图插件，定义为project/ext/model/class/gantt.class.php，里面定义各种代码。

类名规则是{插件名}{模块名}，模块名首字母大写，如ganttProject。

```php
class ganttProject extends projectModel
{
    public function createRelationOfTasks($projectID)
    {
    }
}
```

>注意：这个地方类是继承自projectModel，这样还可以重用原来的代码。

**3.2 在ext/model/创建调用的程序。** 比如叫做project/ext/model/gantt.php

```php
public function createRelationOfTasks($projectID)
{
    $this->loadExtension('gantt')->createRelationOfTasks($projectID);
}
```

通过loadExtension()方法来调用3.1里面调用的gantt.class.php里面的方法。
这样禅道框架只需要对所有的class扩展进行加密就可以了，就可以解决加密文件冲突的问题了。

### 对视图层(view)扩展

视图文件的扩展分为两种方式，一种是完全覆盖，第二种是通过钩子机制来扩展。

**一、完全覆盖：**

视图文件的覆盖可以通过完全覆盖的方式来重新定义。比如我对bug模块的create页面进行扩展。原来的视图文件是存放在module/bug/view/create.html.php。如果需要对其进行扩展，只需要将这个create.html.php拷贝到module/bug/ext/view/create.html.php，然后对这个网页进行修改就可以了。

<b style="color:red">需要注意的是，拷贝过去的时候，包含路径要做相应的改动。</b>

**二、通过钩子进行扩展：**

第一种方法比较简单，也比较直观，但有它的缺点，就是代码无法重用。假设后面版本有了新的改动之后，老版本的视图文件和新版本的程序就有可能不兼容。所以可以考虑通过钩子脚本来实现代码的重用。

钩子脚本的命名规则为 `方法名.扩展名.html.hook.php`。该钩子文件会在整个模板加载完之后加载，在里面可以执行相应的php代码，或者js代码。这样就提供了一种通过js来动态修改页面元素的机制，从而达到对页面元素的完全控制。

比如 misc/ext/view/getsid.color.html.hook.php

```js
$('#topbar').css('color', 'red');
```

通过上面这段js代码，实现了对顶部导航条的加红显示。

### 对样式表和js进行扩展

**一、样式表的扩展：**

如果想对某一个页面的样式进行修改，可以有两种方法。一种就是通过前面所讲的视图文件的扩展来进行。还有一种方法就是单独为这个页面定义样式。比如我想对bug模块的create页面进行样式的重新定义，可以这样定义：

在module/bug/ext/css/下面创建create目录，然后在下面创建一个css文件名，在里面定义自己的样式就可以了。

<b style="color:red">框架在加载create方法的时候，会把module/bug/ext/css/create目录下面的所有css文件都加载进来。</b>

**二、js的扩展：**

和样式表的扩展一样，某一个页面js的扩展也是同样的规则。比如对bug模块的create页面进行扩展，可以在bug/ext/js/下面创建create目录，然后在里面定义js脚本就可以了。

<b style="color:red">框架在加载create方法的时候，会把module/bug/ext/js/create目录下面的所有js文件都加载进来。</b>

### 对语言配置进行扩展

**一、语言的扩展：**

zentaoPHP框架把所有页面提示都已经抽象成语言配置，可以通过对语言的重定义来实现对程序的定制修改。

语言的扩展文件存放在ext/lang/目录下面。按照不同的语言建立相应的目录，比如zh-cn下面，可以有多个文件，zentaoPHP框架会自动加载该目录下面所有以.php结尾的文件。

比如扩展bug模块的语言文件，可以建立module/bug/ext/lang/zh-cn/1.php。

**二、配置的扩展：**

2.1 模块配置的扩展

每个模块配置文件的扩展文件存放在ext/config/目录下面，可以有多个文件，zentaoPHP框架会自动加载该目录下面以config开头的.php文件。这样不同的扩展可以有自己的配置项，彼此之间不会冲突。

2.2 全局配置的扩展

全局配置文件存放在框架基础目录的config目录下面，不建议直接修改config.php文件，可以在同目录下的my.php中修改，因为config会自动载入my.php文件中的内容。如果相对全局的配置进行扩展，也可以参考禅道等产品的扩展方式，将扩展文件存放在config/ext/目录下面，在禅道的conifg.php文件底部你可以看到下面代码：

```php
/* Include extension config files. */
$extConfigFiles = glob(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'ext/*.php');
if($extConfigFiles) foreach($extConfigFiles as $extConfigFile) include $extConfigFile;
```

### 增加新的类库

独立的类库文件和通常的php class没有任何区别，只要将其存放在lib目录下面，文件名为小写的类名，或者建立一个目录。比如，新增一个image的类，可以存放在lib/image.class.php，也可以存放在lib/image/image.class.php。

### api机制简介

**一、API机制介绍：**

前面章节讲述的扩展机制是需要直接开发PHP或者html, css, js等代码。zentaoPHP还提供了API机制，方便大家来和其他的系统进行集成。

API机制都是基于http协议的。返回的数据以json格式存储。

zentaoPHP架共实现了两种API机制。一种为直接的页面调用，一种通过超级model调用接口，直接调用model层的方法，下面我们一一来看下。

**二、页面直接调用：**

当你访问使用zentaoPHP开发的页面时，将访问的url地址中的html换成json，得到的就是json格式的数据。

比如 `http://pms.zentao.net/project-task-8.html`，返回的网页格式，把后面的.html改成.json，返回的是什么？对了，返回的是json格式的数据。

如果是 GET 方式，那么只需要将t参数改成json，`http://pms.zentao.net/?m=project&f=task&t=json`。

返回的数据是做了两次json_encode，下面是代码的示例：

```php
$result = file_get_contents('http://pms.zentao.net/project-task-8.json');

$result = json_decode($result);
if($result->status == 'success' and md5($result->data) == $result->md5)
{
    $data = json_decode($result->data);
    print_r($data);
}
```

先判断第一层里面的result是否正确，md5签名是否正确，然后再对data对象进行json_decode。

**1.2.2 超级model调用接口：**

页面的调用，存在一定的局限，比如返回的数据可能没有你想要的，或者返回了你不需要的数据。为此，我们特地准备了一个超级model调用接口。该接口的使用方式：

- 首先要为相应的帐号增加超级model调用接口的访问权限。
- 然后就可以通过api模块的getModel方法，获取任意模块的model的公开方法了。

getModel方法需要三个参数，分别是模块名，方法名，然后是该方法的参数列表，key1=value1,key2=value2这种方式，多个参数之间用英文逗号隔开。以调用bug模块的getUserBugPairs()方法为例：

- GET方式调用：`?m=api&f=getModel&module=bug&methodName=getUserBugPairs&params=account=$account`
- PATH_INFO方式：`api-getmodel-bug-getUserBugPairs-account=$account.json`

>备注：超级model调用方法暂时只有禅道项目管理软件实现。蝉知门户和然之协同暂时还没有实现。

### 需要登录验证的api调用

在使用api机制进行集成的时候，有的应用场景会涉及到会话登录。这种情况下面会话调用需要经过下面的三个步骤：

**一、获得session：**

首先要访问api模块的getSessionID方法，获得session。

- GET方式：`?m=api&f=getSessionID&t=json`
- PATHINFO: `api-getsessionid.json`

返回的格式中包含sessionName和sessionID。

在后续的访问中，必须以cookie的方式，或者GET方式，将session传递给服务器。

简单的方式就是在请求的url地址后面追加 `$sessionName=$sessionID`。比如 `http://pms.zentao.net/index.json?zentaosid=xxxxxxx`

>注意：上面地址中的sid参数名称可以在config文件里面通过 `$config->sessionVar` 设置，比如禅道config/config.php文件中 `$config->sessionVar = 'zentaosid'`。老版本禅道默认是 sid，新版本禅道默认是 zentaosid，可以具体查看一下使用禅道的代码中是如何定义的。

**二、验证用户身份。**

然后可以访问user模块的login方法，来进行用户身份的验证。用户身份验证，需要提供用户名和密码，以post方式传递给user-login方法。变量名为：account, password。

**三、调用相应的API。**

用户验证通过之后，就可以通过页面调用的api，或者超级model调用的api来获取相应的数据了。

>备注：目前该功能还只有在禅道项目管理软件中实现，蝉知门户和然之协同暂时还没有实现。

### 命令行机制

**一、何谓命令行入口：**

使用zentaoPHP开发的应用有集中的入口。拿禅道项目管理软件举例，www/index.php是重要，也是大家平时都在使用的入口。还有就是www/install.php, www/upgrade.php，顾名思义，为安装的入口和升级的入口。这三个入口，index.php是有权限控制的，而install.php和upgrade.php则没有权限限制，只有在特定的情况下面才会起作用。正常安装或者升级之后，再访问install.php或者upgrade.php是无效的。

命令行入口位于bin/ztcli。其实它也是一段php代码。它主要是给系统管理员使用的。通过这个入口，可以非常方便的访问到禅道系统的每一个页面，从而为各种便利的操作提供了可能。

**二、命令行入口的基本用法：**

命令行入口有三个文件，分别是ztcli, ztcli.sh和ztcli.bat。其中ztcli是主体的php脚本。另外两个则是为了使用方便，做的封装。先来看主体脚本的执行。

在bin目录下面执行下面的命令（一定要在bin目录下面）。

语法格式：`php ztcli http://xxxx/zentaopms/xxxxx`（其中的php，如果找不到，则根据需要换成php可执行文件所在的绝对路径）

举例来讲，我的禅道的访问路径是 `http://pms.zentao.net`，我想触发燃烧图的更新程序，命令如下：`php ztcli http://pms.zentao.net/project-computeburn.html`

如果你配置的禅道访问方式是通过GET方式，那么命令则变成：`php ztcli "http://pms.zentao.net/?m=project&f=computeburn"`，这时后面的url地址需要用引号引起来。也就是说你在浏览器里面看到的是什么，通过ztcli都可以访问。

**三、封装：**

如果你php可执行文件不在PATH路径中，那么你可以修改ztcli.sh(linux)或者ztcli.bat(windows)，将其中的路径补全。比如ztcli.bat中，我可以这样写 `d:\zentao\user\local\php\php.exe ztcl %*`。封装好之后，你就可以直接运行ztclibat url地址就可以了。

**四、高级用法：**

在你访问禅道的页面时候，可以将访问的资源变化一下，比如 `http://pms.zentao.net/project-task-8.html`，返回的网页格式，把后面的.html改成.json，返回的是json格式的数据。如果是 GET 方式，那么只需要将t参数改成json，`http://pms.zentao.cn/?m=project&f=task&t=json`。

通过这个超级的命令行入口，其实可以做很多事情了。具体如何使用，看大家灵活运用了。

## 禅道目录结构

**顶级目录结构：**

- bin目录是存放里禅道的一些命令行脚本；
- config下面存放了禅道运行的主配置文件和数据库配置文件。
- db下面是历次升级的数据库脚本和完整的建库脚本。
- framework里面则是禅道php框架的核心类文件。
- lib目录下面是其他几个类文件。比如数据库访问，发送邮件，数据验证等。
- module下面则是存放了具体的模块。禅道目前已经有30余个模块了。
- tmp目录是禅道程序运行时的临时文件存放目录。
- www目录则是存放了各种样式表文件，js文件，图片文件，以及禅道的入口程序，index.php

**www目录：**

- data目录是上传附件所在的目录。
- fushioncharts则存放了报表解决方案所需要用到的flash文件。
- js目录下面则是禅道用到的各种jquery插件和相应的功能函数。
- theme目录则是样式表文件的目录。
- www根目录下面的index.php是整个禅道程序的入口程序。所有的请求都是通过这个程序进入的。
- install.php则是安装程序。
- upgrade.php是升级程序，每次升级的时候需要访问这个文件。
- .htaccess和.ztaccess文件是apache使用的配置文件。可以在rewrite模块打开的情况下，配置禅道使用静态方式访问。

**module目录：**

module目录下面总共有30多个模块，分别对应了禅道里面的某一个功能模块。整个禅道的功能，就是由这些模块组合而成。让我们来看一个具体的模块。

- lang目录下面存放的当前模块的语言文件。zh-cn对应中文简体，zh-tw中文繁体，依次类推。如果需要修改禅道里面某些字段的名称或者配置，则需要打开相应的文件进行修改。
- view目录下面存放了每一个页面所对应的模板文件。比如bug浏览页面，对应的模板就是browse.html.php。
- config.php存放了当前模块相应的配置项。
- control.php则是整个bug模块所有页面的入口。也就是说，bug相关的页面浏览都可以在这个文件里面找到相应的方法定义。
- model.php则是bug相关数据库操作的方法列表。

## 找到要修改的文件

### control方法的定位

control方法是每一个页面的入口，顺藤摸瓜，让我们先来看个例子：`bug-browse-1.html` 或者是 `/?m=bug&f=browse&productID=1&t=html`。这里面有什么玄机呢？让我们来揭晓。

`bug-browse-1.html`，表示是访问 bug 这个模块的 browse 方法，传递的第一个参数为 1，访问的页面类型是 html。

同样，`/?m=bug&f=browse&productID=1&t=html`，m代表了模块名称，f代表了方法名称，后面的则是参数列表。

那么我们就可以对应到禅道的源代码，`module/bug/control.php` 中的 browse 方法

### control方法里面的调用

ok，我们现在已经知道了入口的函数在什么地方，我们来跟到里面看看吧。

`$this->bug`，表示的是调用 bug 模块的 model 对象，那么它对应的文件在什么地方呢？聪明的你，应该已经猜到了吧。在 `module/bug/model.php`

`this->loadmodel('tree')->xxx`，表示加载 tree 模块的 model 对象，它对应的文件在 `module/tree/model.php`

`$this->app->loadClass('pager')`，表示加载一个lib类，它对应的文件则在 `lib/pager/pager.class.php`

`$this->lang->bug->xxx`，它的定义在 `module/bug/lang/zh-cn.php`。后面的 zh-cn 根据当前用户的语言而定。

再看模块文件。`$this->display()` 之后，调用的是 view 目录下面和当前方法同名的模板文件。比如 bug 的 browse 方法，它对应的模板文件是 `module/bug/view/browse.html.php`

## 参考

- [使用帮助](https://www.zentao.net/book/zentaopmshelp/40.html)
