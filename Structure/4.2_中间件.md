# 中间件

## 目录

- Web Server
  - Nginx
  - OpenResty
  - Tengine
  - Apache Httpd
  - Tomcat
  - Jetty
- 缓存
  - 本地缓存
  - 客户端缓存
  - 服务端缓存
    - Web缓存
    - [Memcached](#Memcached)
    - [Redis](#Redis)
    - Tait
- 消息队列
  - [消息总线](#消息总线)
  - 消息的顺序
  - [RabbitMQ](#RabbitMQ)
  - [RocketMQ](#RocketMQ)
  - ActiveMQ
  - Kafka
  - Redis消息推送
  - ZeroMQ
- 定时调度
  - 单机定时调度
  - 分布式定时调度
- RPC
  - Dubbo
  - Thrift
  - gRPC
- 数据库中间件
  - Sharding Jdbc  
- 日志系统
  - 日志搜集
- [配置中心](#配置中心)
  - 为什么需要统一配置？
  - 解决思路
  - Zookeeper方案
  - Zookeeper代码实现
- API网关

## Memcached

### Memcached安装

Windows安装包：

- [32位系统 1.2.5版本](http://static.runoob.com/download/memcached-1.2.5-win32-bin.zip)
- [32位系统 1.2.6版本](http://static.runoob.com/download/memcached-1.2.6-win32-bin.zip)
- [32位系统 1.4.4版本](http://static.runoob.com/download/memcached-win32-1.4.4-14.zip)
- [64位系统 1.4.4版本](http://static.runoob.com/download/memcached-win64-1.4.4-14.zip)
- [32位系统 1.4.5版本](http://static.runoob.com/download/memcached-1.4.5-x86.zip)
- [64位系统 1.4.5版本](http://static.runoob.com/download/memcached-1.4.5-amd64.zip)

memcached >= 1.4.5 版本安装

1、解压下载的安装包到指定目录。  
2、在 memcached1.4.5 版本之后，memcached 不能作为服务来运行，需要使用任务计划中来开启一个普通的进程，在 window 启动时设置 memcached自动执行。

我们使用管理员身份执行以下命令将 memcached 添加来任务计划表中：

```bat
schtasks /create /sc onstart /tn memcached /tr "'D:\memcached-amd64\memcached.exe' -m 512"
```

>注意：  
>1、你需要使用真实的路径替代 D:\memcached-amd64\memcached.exe。  
>2、-m 512 意思是设置 memcached 最大的缓存配置为512M。  
>3、我们可以通过使用 "D:\memcached-amd64\memcached.exe -h" 命令查看更多的参数配置。

3、如果需要删除 memcached 的任务计划可以执行以下命令：

```bat
schtasks /delete /tn memcached
```

[Memcached三种客户端的使用](https://www.jianshu.com/p/8c8432255e6f)

## Redis

## Tait

## 消息队列

在企业应用系统领域，会面对不同系统之间的通信集成与整合，尤其当面临异构系统时，这种分布式的调用与通信变得越发重要。其次，系统中一般会有很多对实时性要求不高的但是执行起来比较较耗时的地方，比如发送短信，邮件提醒，更新文章阅读计数，记录用户操作日志等等，如果实时处理的话，在用户访问量比较大的情况下，对系统压力比较大。

面对这些问题，我们一般会将这些请求，放在消息队列MQ中处理；异构系统之间使用消息进行通讯。

MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。

MQ是消费-生产者模型的一个典型的代表，一端往消息队列中不断写入消息，而另一端则可以读取或者订阅队列中的消息。

消息传递相较文件传递与远程过程调用（RPC）而言，似乎更胜一筹，因为它具有更好的平台无关性，并能够很好地支持并发与异步调用。所以如果系统中出现了如下情况:

1. 对操作的实时性要求不高，而需要执行的任务极为耗时；
2. 存在异构系统间的整合；

一般的可以考虑引入消息队列。对于第一种情况，常常会选择消息队列来处理执行时间较长的任务。引入的消息队列就成了消息处理的缓冲区。消息队列引入的异步通信机制，使得发送方和接收方都不用等待对方返回成功消息，就可以继续执行下面的代码，从而提高了数据处理的能力。尤其是当访问量和数据流量较大的情况下，就可以结合消息队列与后台任务，通过避开高峰期对大数据进行处理，就可以有效降低数据库处理数据的负荷。

## 消息总线

## RabbitMQ

RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统。他遵循Mozilla Public License开源协议。

### RabbitMQ安装

1. 由于RabbitMQ使用Erlang语言编写，所以先[安装Erlang语言运行环境](https://www.cnblogs.com/longlongogo/p/6479424.html)。

   >（1）下载地址：[http://www.erlang.org/downloads](http://www.erlang.org/downloads)。  
   >Erlang(['ə:læŋ])是一种通用的面向并发的编程语言，它由瑞典电信设备制造商爱立信所辖的CS-Lab开发，目的是创造一种可以应对大规模并发活动的编程语言和运行环境。  
   >使用Erlang来编写分布式应用要简单的多，因为它的分布式机制是透明的：对于程序来说并不知道自己是在分布式运行。Erlang运行时环境是一个虚拟机，有点像Java虚拟机，这样代码一经编译，同样可以随处运行。它的运行时系统甚至允许代码在不被中断 的情况下更新。另外如果需要更高效的话，字节代码也可以编译成本地代码运行。  
   >
   >（2）设置环境变量：  
   >手动编辑"path"加入路径，示例：`C:\Program Files\erl8.2\bin`
   >
   >（3）检查Erlang是否安装成功  
   >打开cmd，输入 `erl` 后回车查看信息

2. 下载安装[RabbitMQ](http://www.rabbitmq.com/)

   >使 RabbitMQ 以 Windows Service 的方式在后台运行：打开 cmd 切换到 sbin 目录下执行：

   ```sh
   rabbitmq-service install
   rabbitmq-service enable
   rabbitmq-service start
   ```

***CentOS 7 安装 RabbitMQ***

1. 添加 Erlang 源：`vim /etc/yum.repos.d/rabbitmq-erlang.repo`，文件中添加如下内容保存：

   ```ini
   [rabbitmq-erlang]
   name=rabbitmq-erlang
   baseurl=https://dl.bintray.com/rabbitmq/rpm/erlang/20/el/7
   gpgcheck=1
   gpgkey=https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc
   repo_gpgcheck=0
   enabled=1
   ```

2. 新建目录：`mkdir /usr/local/software`
3. 下载 RabbitMQ rpm 安装文件：`wget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.7/rabbitmq-server-3.7.7-1.el7.noarch.rpm`
4. 安装 RabbitMQ Server：`yum install -y rabbitmq-server-3.7.7-1.el7.noarch.rpm`
5. 安装 RabbitMQ Web 管理界面并启动 RabbitMQ Server：

   ```sh
   rabbitmq-plugins enable rabbitmq_management
   systemctl start rabbitmq-server
   ```

6. 由于 RabbitMQ 默认用户 Guest 只能访问安装在 RabbitMQ 本机上的 Web 管理页面，因此当 RabbitMQ 安装在 Linux 服务器上时，需要做如下操作才能在别的机器上访问其 Web管理页面：

   - 添加用户：`rabbitmqctl add_user root 123456`，其中 root 表示新添加用户名，123456 表示登录密码；
   - 赋予用户权限：`rabbitmqctl set_permissions -p "/" root '.*' '.*' '.*'`；
   - 赋予用户角色：`rabbitmqctl set_user_tags root administrator`；
   - 查看 RabbitMQ 用户：`rabbitmqctl list_users`。

7. 访问：`http://192.168.1.120:15672`，得到 RabbitMQ Web 管理页面

   此时，RabbitMQ 已经安装成功。

### RabbitMQ概念说明

RabbitMQ是一个消息代理。他从消息生产者(producers)那里接收消息，然后把消息送给消息消费者(consumer)在发送和接受之间，他能够根据设置的规则进行路由，缓存和持久化。

一般提到RabbitMQ和消息，都用到一些专有名词。

- 生产(Producing)意思就是发送。发送消息的程序就是一个生产者(producer)。我们一般用"P"来表示
- 队列(queue)就是邮箱的名称。消息通过你的应用程序和RabbitMQ进行传输，它们只能存储在队列(queue)中。队列(queue)容量没有限制，你要存储多少消息都可以——基本上是一个无限的缓冲区。多个生产者(producers)能够把消息发送给同一个队列，同样，多个消费者(consumers)也能从同一个队列(queue)中获取数据。
- 消费(Consuming)和获取消息是一样的意思。一个消费者(consumer)就是一个等待获取消息的程序。我们把它称作"C"。

RabbitMQ 的重要概念有以下几个：

- Broker：接收消息，分发消息应用；
- Exchange：消息交换机；指定消息按照什么规则路由到哪个队列 Queue；
- Queue：消息队列，存储消息的载体；
- Binding：Exchange 和 Queue 之间的虚拟连接；Binding 中可以包含 RoutingKey，其信息被保存到 Exchange 中的查询表中，作为 Message 的分发依据；
- RoutingKey：路由关键字，Exchange 根据 RoutingKey 将消息投递到对应的队列中；
- Vhost：虚拟主机，一个 Broker 可以有多个虚拟主机，用作不同用户的权限分离；一个虚拟主机持有一组 Exchange、Queue 和 Binding；
- Producer：消息生产者，主要将消息投递到对应的 Exchange 上面；
- Consumer：消息消费者，消息的接收者，一般是独立的程序；
- Channel：消息通道，也称信道。在客户端的每个连接里可以建立多个 Channel，每个 Channel 代表一个会话任务。

## RocketMQ

## 配置中心

### 为什么需要统一配置

做项目时用到的配置比如数据库连接等最简单的方式是写死在项目里，如果需要更改，那么就通过修改配置文件然后再投产上去。问题来了，如果是集群呢，有100台机器，这时候做修改就太不切实际了；我们需要用统一配置管理。

### 解决思路

1. 把公共配置抽取出来
2. 对公共配置进行维护
3. 修改公共配置后应用不需要重新部署

### Zookeeper方案

![x](./Resource/Zookeeper方案.png)

1. 公共配置抽取存放于zookeeper中并落地数据库
2. 对公共配置修改后发布到zookeeper中并落地数据库
3. 对应用开启配置实时监听，zookeeper配置文件一旦被修改，应用可实时监听到并获取

### Zookeeper代码实现
