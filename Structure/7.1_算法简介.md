
# 算法

职场行话：**数据结构是程序的骨架，算法则是程序的灵魂！**

人们设计各种算法的目的是解决现实中的问题，虽然各种算法的实现五花八门，但是设计算法却有一些通用的方法或思想（也有的资料将其称为算法设计模式）。归纳起来，这些常见的算法设计方法有迭代法、穷举搜索法、分支界限法（剪枝法）、递推法、递归法、回溯法、分治法、贪婪法和动态规划法等。

各种算法设计方法并不是孤立存在的，很多算法最终的实现都是几种算法思想在一起融合后的产物。例如，穷举搜索法常常要结合递归和回溯操作实现穷举遍历，有时候还需要借助分支界限法“剪掉”一些重复的分支或明显不可能存在解的分支，目的是提高穷举的效率；再比如很多读者望而生畏的动态规划法，其递推关系的确定体现的就是递推的思想；再比如，迭代法通常结合分治的思想，使得每次迭代都能把大问题分解为一系列容易求解的小问题。

## 什么是算法

算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作

## 算法特性

- 有穷性：一个算法必须总是（对任何合法的输入值）在执行有穷步之后结束，且每一步都可在有穷时间内完成；
- 确定性：算法中每一条指令必须有确切的含义，读者理解时不会产生二义性。在任何条件下，算法只有唯一的一条执行路径，即对于相同的输入只能得出相同的输出。
- 可行性：一个算法是能行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。
- 输入：一个算法有零个或多个的输入，这些输入取自于某个特定的对象的集合。
- 输出：一个算法有一个或多个的输出。这些输出是同输入有着某些特定关系的量。

## 怎么比较算法优劣

**时间复杂度和空间复杂度：**

评价一个算法的优劣，可以在相同的规模下，考察算法执行时间的长短来进行判断。而评估一个程序的执行时间通常有两种方法：

1. 事后统计法：缺点：不利于较大范围内的算法比较。（异地，异时，异境）
2. 事前估算法

<table>
<thead>
<tr>
<th colspan="2">程序在计算机上运行所需时间的影响因素</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法本身选用的策略</td>
<td></td>
</tr>
<tr>
<td>问题的规模</td>
<td>规模越大，消耗时间越多</td>
</tr>
<tr>
<td>书写程序的语言</td>
<td>语言越高级，消耗时间越多</td>
</tr>
<tr>
<td>编译产生的机器代码质量</td>
<td></td>
</tr>
<tr>
<td>机器执行指令的速度</td>
<td></td>
</tr>
</tbody>
</table>

综上所述，为便于比较算法本身的优劣，应排除其它影响算法效率的因素。

从算法中选取一种对于所研究的问题来说是基本操作的原操作，以该基本操作重复执行的次数作为算法的时间量度。（原操作在所有该问题的算法中都相同）

$$T(n)=O(f(n))$$

上式表示：随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称**时间复杂度**。

<table>
<thead>
<tr>
<th colspan="2">基本操作的执行次数不确定时的时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>平均时间复杂度</td>
<td>依基本操作执行次数概率计算平均值</td>
</tr>
<tr>
<td>最坏情况下时间复杂度</td>
<td>在最坏情况下基本操作执行次数</td>
</tr>
</tbody>
</table>

评估空间复杂度时，若额外空间相对于输入数据量来说是常数，则称此算法为原地工作。如果所占空间量依赖于特定的输入，则除特别指明外，均按最坏情况来分析。

## 如何“玩”算法

既然是“玩”算法，首先要会玩，否则只会被算法“玩死”。

很多朋友啃完了《算法》《算法导论》或其他算法书籍，对各种排序、搜索、遍历等常用算法了如指掌，但是遇到实际的问题时还是束手无策，这与智力无关，这其实就是经验和方法集的问题。

很多啃过算法书的朋友都知道堆排序和最大最小堆，但是却不能有效地应用到实际问题中。例如，某算法书介绍 Dijkstra 算法时，提到当问题规模比较大时，每次查找 dist 数组中的最小值可能成为效率的瓶颈，可以用一个最小堆来维护 dist 结果，使得每次取最小值的操作变成 O(1) 时间复杂度。看到这，许多读者不知所措，不知道如何将自己掌握的最小堆算法与 Dijkstra 算法结合在一起改进算法的效率。尽管部分人看不起穷举法，但是不可否认，有些人却连基本的穷举算法都设计不出来。

“玩”算法就是要能够做到以下三点：

1. 对遇到的特殊问题要能够自己设计出算法实现（可能是一个智力游戏题目，也可能是工作中遇到的实际问题）；
2. 对于原理公开的知名算法，要能将算法原理翻译成具体的算法代码（如二部图匹配的匈牙利算法、大整数乘法的 Karatsuba 算法）；
3. 对已有具体实现的算法，要能够设计出合适的数学模型，将算法应用到实际问题中（如遗传算法、SIFT 图像识别算法）。

想要做到这些，除了熟练掌握各种常用的基础算法外，还需要了解算法设计的常用思想和模式，并且要掌握将题目转换成数据模型，并进一步用数据结构实现数据模型的一般方法，这一节课我们就来讲讲数据模型和建模。

### 数据模型

如果想要计算机来解决问题，就必须用计算机能理解的方式描述问题。计算机只能用数据描述问题，这就需要一个合理的数据模型用来存储这些数据，这里提到的数据模型不同于大家普遍理解的数学模型，因为数学模型的意义更宽泛，也更抽象，语言、图表和公式都可以用来描述数学模型。

数据模型的定义更具体一点，就是用在计算机程序中可以直接使用的，用编程语言直接描述的数学模型，可以将数据模型简单理解为与数学模型相一致的数据结构定义，是数学模型的一种表达形式。

建立问题的数据模型实际上是对问题的一种抽象表达，通常也需要伴随着一些合理的假设，其目的就是对问题进行简化，抓住主要因素，舍弃次要因素，逐步用更精确的语言描述问题，最终过渡到用计算机语言的数据结构能够描述问题为止。

一个完整的算法实现应该包含三个重要的组成部分，即数据模型、算法逻辑主体和输入输出。

输入就是把自然语言描述的问题转化成计算机能存储或处理的数据，并存入数据模型中；输出就是将计算机处理后的结果（也在数据模型中定义）转化成人类能理解的方式输出。

算法的逻辑主体就是具体承载数据处理的代码流程，负责对数据模型中的输入数据进行处理、转换，并得到结果。

这三个组成的核心是数据模型，好的数据模型不仅能准确地描述问题，还能简化算法实现或提高算法的效率，不好的数据模型可能会导致算法的实现困难、效率低下，甚至无法实现算法。

<b>根据问题的描述建立数据模型的能力是“玩”算法的关键。</b>

不能对问题进行归纳并抽象出数据模型的，就不能设计出解决问题的算法实现，换句话说，就是缺乏解决实际问题的能力。这种能力的缺乏体现在两个方面，一方面是不能针对特有的问题设计出解决问题的算法实现，而这种特有的问题有可能是其他人没有遇到过的，没有现成的方法可用；另一方面是不能用已有的通用算法解决具体的问题，像遗传算法这样的通用算法，通常需要结合实际问题的数据模型才能真正解决问题。

如果不能解决工作和生活中实际面临的问题，学再多的算法又有何用？不过是把别人做过的事情再做一遍而已。

建模是个很抽象的话题，这世界上的问题纷繁复杂，不存在能解决一切问题的通用建模方法，一个人也不可能看了几篇文章就能全面掌握各种问题的建模方法。

前面提到过，这种能力其实就是经验和方法集的问题，多练习、多思考，学会总结和归纳，是提高建模能力的关键。话题抽象并不表示这个问题是毫无章法可言的，实际上，在某些方面还是有一些规律可循。接下来的内容是我总结出来的一些惯用方法，给大家提供一个建模时的思考方向。

### 总结

“玩”算法的目的不是学会一种算法或很多种算法，而是学会用算法来解决问题，掌握解决问题的能力是关键。

这一课，我们介绍了这种能力的核心内容——如何建立与算法相适应的数据模型。建模能力的提高是一个长期的积累过程，这里提到的只是最常见的思路和方法。除此之外，提高建模能力还需要熟悉各种常见的数据结构的特点和使用方法，需要多做、多练、多思考，善于把别人的经验变成自己的经验。
