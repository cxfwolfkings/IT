

# ***\*松耦合系统架构浅析\****

## 导读：系统架构分解及松耦合综述

  说起“架构”一词，想必绝大多数有过项目经验的开发人员都不陌生，很多人也将“架构师”作为自己职业发展的一个方向。可“架构”这个词虽然很多中英文书籍都已经对它下了相对比较准确的定义，但是仍然避免不了它在人们心中一直是一种言之较虚的存在。

  无论说它是“组件以及组件之间的关系”又或是“一切不能轻易改变的与系统相关的重要的决策、方案、规则和要素”，都很难具象的告诉人们哪些东西应该包含到架构文档中去。至于像“4+1”视图之类的理论，如果严格按照这种形式来组织架构，就会发现有可能遗漏一些关键决策。当然，出现这种情况，完全可以通过增加更多的视图来解决。不过，有些决策却不是可以通过视图能够直观展示的。

  如果说架构是一组决策、方案、规则和要素的集合以不同视图向不同干系人的一种展现，那么我们有理由暂时抛开这些理论定义的约束，去问一下我们在架构阶段需要得到哪些信息？需要将哪些内容固化下来，指导以后的设计及开发？

  从这个角度上看就会发现，架构也是分层次的。这也或许是为什么架构师也会有很多名称的原因。

  国内部分企业将架构上升为一种方法论的角度，试图通过一套方法来合理的演进架构。不得不说，只有从方法论层面来审视架构设计，才能更宏观的明确它在企业中的位置以及它应该如何正确的发展。

  笔者早期了解过 TOGAF、Zachman Framework 等企业架构框架（了解不深，不敢妄谈），暂且不提在企业内部实施这种框架的成本以及所带来的价值，作为系统的承建者，它们却也给我们提供了一种高层的思考及分解架构的方式。

### ***\*系统架构的分解\****

  我们若要描述软件系统的一切重要的决策、方案、规则和要素，仔细分析会发现，它们是多个方面的，这也与 TOGAF 的描述相符。

  首先，是业务层面的内容，我们可以称为“业务架构”。可能很多人会问，“业务”不是属于“软件需求规格”该描述的事情吗？与架构有什么关系？

  如果我们开发的是一个独立的小规模的软件系统，通过一份“软件需求规格说明书”足以将其需求描述清楚，并作为系统研发的依据。但如果我们所要描述的是整个企业的业务支撑，此时显然不是通过一套系统来解决的，它可能包含数十个独立的系统，它们需要通过定义清晰的接口相互访问，以支持企业业务的正常运作。

  此时，需要结合企业的愿景，以高度抽象的方式（不需要关注具体的功能细节描述，此部分应由软件需求规格说明书描述）描述各个系统的核心业务模型、端到端的业务流程，以及它们之间的业务边界、交互过程。 另外，对于业务非常复杂的系统，我们需要对其进行按照不同层级进行业务域/功能、过程进行分解，以供不同的干系人参考。通过这种分解，就会明确在整个系统中，有哪些角色、每个角色需要操作管理哪些系统/模块/功能组件、与哪些角色进行交互、交互过程是如何进行的。

  这项业务域/功能、过程的分解结果与软件需求规格说明书相互配合，以准确的描述软件的业务需求。通过这种不同层级分解的方式，需求人员才会明确各系统、子系统、组件的业务范围、交互过程，从而基于此进一步细化各个功能点需求。

  我们之所以将其称为“业务架构”，是因为它描述的是业务层面的重要决策、业务组件以及组件间的端到端的业务流程，这些组件是以不同抽象层次展现的。它们不会描述系统有几个页面、每个页面有哪些输入、哪些操作，但这些却需要明确包含到需求规格说明书中，以指导设计、开发、测试。

  其次，是数据层面的内容，我们可以称之为“数据架构”。从本质上说，应用系统是不同的角色通过不同的功能对数据进行查看和操作的过程，应用系统是数据的记录和流转。对于数据部分，同样有很多关键的决策需要记录，当然这些决策不是指你在数据库建几张表、每张表有哪些列、每一列是什么类型。

  数据架构中的内容更多侧重于对核心数据模型、共享数据，以及数据生命周期的描述。通过数据架构，我们可以明确系统各数据域包含的核心模型、数据域边界、共享数据、数据生命周期等。

  再次，是应用层面的内容，我们可以将其视为对“业务架构”和“数据架构”向 IT 架构实现层面的转化，这也是与开发最为密切的一部分。通过对“业务架构”中业务域、业务组件、业务模型、业务过程的拆分、合并，从而形成应用架构层面的系统、子系统、模块以及对象。通过对“数据架构”中的数据域、核心模型、共享数据的转化，形成应用架构层面的数据库表设计、共享数据接口设计等。

  应用架构还包括集成架构和技术架构。前者包括与第三方系统的集成方式，如共享数据存储、SOA、RESTful、消息中间件等；后者包括基础技术平台的选型。

  最后，是基础设施层面的内容，包括我们的系统最终的部署环境：物理机还是云平台、主备还是大规模分布式集群，部署的操作系统：Linux 还是 Windows，还包括数据库环境的搭建、网络环境拓扑等等。有人称之为“技术架构”，但是为了避免与应用架构中的技术部分混淆，我们暂且称之为“基础设施架构”。

  综上可以发现，我们认为构建系统的核心决策是多方面的，既包含业务、数据，又包含应用和基础设施。而每一部分，我们又都可以采用一种分层的方式对其进行有效的分解，以便逐步细化，使其边界清晰，以做到高内聚、低耦合。

  因此，***\*我们说的松耦合的系统架构，更多的是一种对系统全方位的分析、分解的过程\****（抱歉，此时方才点出主题）。但在进入正题之前，还请允许我再多言几句这个常见的词汇。

### ***\*松耦合\****

​	想必绝大多数 IT 从业者（这个范围已经足够广了）都对这个词耳熟能详，甚至都会觉得完全没必要再对它进行任何阐述。

  但是不得不说，不同岗位对于松耦合的认识是不同的。对于开发人员，如果修改一个接口的时候，不影响其它接口，修改一个数据结构的时候不会影响其他无关的功能，那么我们就说他的代码是松耦合的。对于设计人员，如果变动一个模块的设计不会影响另一个模块，模块间的接口保持相对稳定，那么我们也会说他设计的模块是松耦合的。

  这些都是我们常见的松耦合的例子，但显然不是全部。可以想象一下，每次重新构建系统的时候，开发环境中是否有多余的不用的技术组件/框架，仅仅是因为它被包含到了你们的技术平台当中？每次部署/升级系统时，是否每次都是替换全部的发布包？

  如果是，那就说明至少在这几个方面，你的平台、系统不是松耦合的。当然，之所以出现这样的问题，是由多种因素综合导致的，这也是为什么我们开篇先把架构的各个方面都罗列一遍的原因。

  比如系统无法做到细粒度部署，首先可能是技术平台不支持、可能是应用组件业务层面耦合过重、也可能是部署架构的原因。只有通盘考虑各个环节，每个环节都按照既定的架构目标去设计，才能最终实现架构的真正意义上的松耦合。

### ***\*内容综述\****

  此系列文章主要从以上讲到的架构的各方面的内容入手，来探讨各种松耦合的方案、方法及途径。

· 首先是业务/数据分层分解。

· 其次是应用架构中的技术平台（后文称为“技术架构”）。

· 再次是应用架构中的功能架构（后文称为“开发架构”）。

· 最后是部署架构部分。

  除了业务/数据部分外，其他都不同程度的涉及对技术的选型、方案等的分析与讨论。

### ***\*总结\****

  本文作为开篇，主要简单讲述了系统架构的各个方面以及交代后续文章的内容。从下一篇开始，我们开始介绍对业务/数据的分层分解。

## 第01课：业务架构和数据架构松耦合

### ***\*概述\****

  任何系统尤其是事务性系统（与分析性系统对应），从本质上来说都可以将其分解为三个主要的部分：参与者、对象、操作。系统功能可以进一步理解为：参与人对某个或者某几个对象的一系列操作。

  参与者可以是真实的人，也可以是一个第三方系统或者自动化终端。对象指的就是领域对象。操作就是系统功能处理过程。

  下面以我们最熟悉的购物场景为例进行分析，会发现通过明确这三个组成部分，有助于我们更快、更准确、更清晰的理解需求：

l 参与者：买家、卖家。

l 领域对象：商品、支付信息、订单。

l 操作：购买及结算、发货。

  买家查看商品、添加到购物车、确定购买、生成订单并结算。卖家收到订单后，确认并进行发货。

  那有人可能会说，这不就是用例吗？也对也不对。用例（指用例图）多是对参与者、用例以及它们之间的关系的描述，其中用例对应了系统的功能，它包含了对象和业务过程两部分，是一种综合性描述。

  虽然通过用例图很容易知道参与人是如何协作并操作系统功能的，但这种方式并不能使我们很好的发现领域对象以及业务过程的边界，尤其我们的业务过程是横跨多个子系统、系统的情况。还有用例图只是一种概要性描述，并未详细描述业务过程，更多的情况是，我们需要结合用例图、BPMN 等从不同角度来进行描述。

  而且本文更多是侧重于如何来分析一个系统的需求，而不是需求的最终描述形式。也就是说我们讲的更多是一个方法论，而不是这个方法论的输出结果。

  尤其是对于复杂的业务系统集，弄清有哪些参与者、每个参与者可以操作哪几个系统的哪几个功能，需要与哪几个参与者协作完成。所有这些问题都有助于我们划分系统的业务边界和数据边界，构建松耦合的系统。

### ***\*业务过程框架\****

  如果你稍微了解电信行业的业务系统，那么就会对 eTOM 不陌生。简而言之，它是一套业务过程框架(Business Process Framework)，是一种参考框架或者分类模型，通过这方法论将服务提供商所涉及的所有业务活动进行分类。

  通过这种分类方式，可以有效的实现服务提供商业务过程的治理，使得任何粒度的变更都会体现到业务过程框架中来。

  我们在变更业务过程时，尤其是对于跨系统、子系统的业务过程变更。有时候很难理清它涉及的变更点，也很难直观的评估这些变更对业务过程的影响，这主要是因为我们常常在一个固定的粒度考虑业务变更。如果这个粒度过粗，那么有可能使得变更点不够具体、很难指导开发，如果这个粒度过细，那么又会导致变更点遗漏。除此之外，还会容易导致业务过程的边界不够清晰，使得各个系统或者模块产生耦合。

  一种合理的业务过程管理方式就是按层级进行分解，而这也是 eTOM 所采用的方式。通过借鉴 eTOM 这种业务过程框架，可以使我们在业务架构上实现松耦合，有助于对业务过程进行有效管理。

  在 eTOM 中，业务过程被按照不同层级进行了分解，主要体现为以下几个级别：

l Level 0——业务活动：识别和建模业务目标、价值流和环境约束，确定产品线作为最终交付的业务目标。在这一级别可以明确各产品线之间的边界。

l Level 1——过程组：设计产品结构、产品交付和支持流程链、企业级数据模型、组织结构，识别业务知识，这是所交付业务的功能结构。定义不同的视图来描述业务过程是如何结构化交付 Level 0 中的业务活动的，过程组织形式必须是从功能角度端到端的。

l Level 2——核心过程：识别行业标准参考模型；开发通用流程、过程层次结构；识别和建模业务数据定义、系统结构；定义业务角色。该级别主要是可识别的端到端业务过程的子过程。

l Level 3——业务流程：设计详细流程、分配业务角色、确定支持系统及数据流。将业务数据模型映射到系统数据模型，考虑失败路径、队列和瓶颈，该级别主要定义 Level2 中过程的具体流程。

l Level 4——操作流程：开发详细的子流程设计，定义操作角色，将过程链接到书面过程，确定详细的系统、设备和资源使用情况，该级别主要是对 Level3 的进一步细化。

l Level 5——详细的流程：通过工作流系统、电子商务解决方案和系统开发自动的交付流程。链接过程和数据模型到系统和软件开发环境，该级别主要是对 Level4 的进一步细化。

  也许你对 eTOM 这种划分感觉有点不知所以然。没关系，接下来通过一个例子进行说明，你或许会理解这套方法论在业务系统构建过程中的价值。

### ***\*业务过程分解示例\****

  本节试图通过一个示例来演示业务过程的逐步分解，当然本节对于业务过程的理解（尤其是高层分解）并不与 eTOM 一致，这也是仁者见仁智者见智的事情，关键是如何将这套方法论用到我们的实际工作中，去改进我们的业务过程管理，而不是生搬硬套。

#### ***\*业务活动\****

  如果你不是孤立的分析一个系统，而是全局考虑企业整体的业务活动，就会发现，企业的业务和数据是分区域而且最终形成一个闭环。

  业务数据基本上按照下面的一个示意图进行流动，以确保企业活动的正常运行：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps10.jpg)

  基础：如果你是一家销售类企业，那么在业务活动开始之前，需要有一些基础数据进行驱动。这些数据包括产品及价格、销售策略、供应商和合作伙伴等等，这些都应该认为是基础数据，它们是先于业务活动开始而存在的。

  运营：当基础数据具备之后，在这些基础数据的驱动之下，业务活动便可以开始运行。如产品销售形成的订单、支付记录、配送以及后期的服务，这是业务活动的核心。

  分析：基于对运营过程产生的数据进行各维度分析，并将分析结果应用于“基础”和“运营”的调整与优化，从而形成数据上的闭环。

  企业：前面三者形成了业务数据的闭环，而“企业”则作为一个横切面贯穿三者。它主要用于企业对各环节的监控、管理，如人员管理、绩效管理、财务管理、经营指标监控等。

  有了这四者，企业业务活动才能正常运行，但是这只是一个通用概念，我们再将其具像一下——电商类运营系统（受业务知识所限，不确保业务域的完整性，如有遗漏，实在抱歉）。

  在这四个环节的基础上，我们可以将系统的业务目标进行一个初步拆分：

  我们初步将整个的业务活动拆分为五部分：

l 产品及客户的管理：包括产品定义、产品销售、客户注册及管理、客户购买及支付等等。

l 库存：在整个产品销售过程中涉及的物品的管理，一部分属于销售过程，如销售出库及退还，一部分不属于销售过程，如进货、盘库。

l 服务：对产品销售各环节的服务跟踪及保障，如投诉处理等。

l 商家及合作伙伴：如商城入驻商家的管理、分成等。

l 企业：企业内部的管理，如销售人员、财务管理等。

  从我们对这五部分的介绍会发现，你可以根据这个分解划分产品线（可以再拆分或者合并，但最好与你的业务过程视图相符）。

#### ***\*过程组\****

  通过“业务活动”的分解，我们会自然而然对于它的每一部分再进行细分，如下图所示：

![x](./Resources/st001.png)

  这里需要注意横向拆分和纵向拆分的区别：

  横向拆分表示功能相关的过程，纵向拆分表示端到端的业务流程。

  也就是通过横向拆分，将业务过程按照功能耦合程度聚合成不同的组。通过纵向拆分，则是对功能组内的端到端业务过程进行的拆解。

  以“产品、客户”为例，从横向看，它包括了产品策略及定义、客户注册、购买、计费等整个交易链条的功能。从纵向看，这个交易链条被拆分成了几部分：首先是产品策略的定义，其次是产品生命周期管理，然后是运营准备（客户注册、支付账户设置等等），再就是运营实现（购买、生成订单），最后是计费（支付、生成账单等等）。

#### ***\*核心过程\****

  显而易见，通过“过程组”两个维度的划分，我们很容易在此基础上做进一步的细化，明确核心功能。由于本部分非常复杂，不再整张视图显示，我们只拿“产品、客户”部分作为示例（假设这两部分我们作为一个系统，当然你可以进一步拆分为产品和客户两个系统）。

  通过“过程组”的横向和纵向分析，我们可以推导出下面的图（部分示意）：

  这部分我们可以视为系统模块视图，你也可以将这部分与上一部分结合，提供一个总体的业务架构图。注意每一部分所在的纵向拆分区域。

#### ***\*业务流程\****

  该步主要是针对第二步，细化业务流程。以上一步中的“订单管理”为例：

  

  通过图可以发现，它将订单管理做了进一步的拆解，这个层面我们可以将其视为每个模块提供的服务。

  还需要注意，通过从产品、模块到业务服务的分解，我们需要逐步识别参与人及其在每个系统中的角色。如产品管理，企业运营人员是否可以操作？合作伙伴是否可以操作？它们分别是通过哪个系统进行操作？这会影响最终的系统实现方案：是在产品系统中提供多种角色限制还是将产品作为服务提供给合作伙伴系统。

  在这一级别，我们已经可以以业务过程的形式描述一些核心功能，如订单处理：

![x](./Resources/st002.png)

 

  注意它们在每个系统中的分解（不同背景色），这会影响业务边界的确定以及各系统服务的发布。

  当你的业务系统需要对企业外部组织提供服务时，这个流程也可以用于映射你的业务过程编排工作。

#### ***\*操作流程及详细流程\****

  你还可以针对业务流程中的每一个节点再进一步分解（这也是必须的，作为服务实现的依据）。

  如上一步的“订单创建”，我们需要详细描述创建的步骤，需要记录哪些关键数据，做哪些完整性校验等等，此处不再赘述。

  通过这种逐层分解，我们很容易明确每个产品、产品中每个模块、模块中每个服务的边界，以及它们是如何协作的。通过这种协作，我们支撑了系统哪些业务过程。

  只有这样，我们才会知道业务过程有没有缺失，能不能有效支撑企业业务的开展。当业务过程变更时，我们也会更有效的将其分解为各个产品、模块以及服务的变更，以风险和影响范围可控的方式。

### ***\*数据架构松耦合\****

  说实话，数据架构松耦合这个词听起来还是有些抽象，如果换句话说数据拆分，估计就具像的多。但是我们说数据拆分只是数据架构松耦合的一部分内容，而且是偏应用架构层面更多一些。

  数据架构的松耦合需要包含两个方面，一个是数据模型的松耦合，体现在业务过程各个环节流转数据的解耦，一个是数据拆分策略，这体现在对共享数据的处理方式。

  前者决定于业务模型的分析能力，后者决定于技术架构及部署架构的复杂度以及是否满足用户需求。

#### ***\*数据模型松耦合\****

  数据架构中，数据模型的分析与建立与业务架构设计是同时进行的，如果在业务架构完成之后，孤立的进行数据架构设计，那么就很难达到预期。

  当我们进行数据架构设计时，也需要与业务架构一样，进行逐层分解，这样有助于让我们发现数据域的边界，而数据域的边界则是我们需要解决耦合的地方。

  考虑一下业务过程的分解，我们就会很容易得出在产品、模块级别数据模型的边界，并且完成对核心模型的逐步细化。例如：

l 在“业务活动”阶段，我们得出的核心模型是产品、客户、库存、供应商/合作伙伴、服务等。

l 在“过程组”阶段进一步细化，如客户又细化为：客户基本信息、账户、订单、账单。

l 在“核心过程”阶段，客户订单又细分为：订单基本信息、订单项、订单操作记录、支付记录等等。

  通过这种方式，我们可以形成能够导出为数据结构设计的输出结果。重要的是这些业务模型的边界很清楚，不会导致管理混乱。

#### ***\*数据拆分\****

  数据拆分这部分相对比较难描述，在这一阶段理论上不应该规定具体的技术方案细节，如采用文件还是采用共享数据库，是否考虑对数据库做垂直拆分或水平拆分，采用什么样的主键策略。这些应该放到应用架构去考虑。

  该部分的侧重点还是要与业务过程结合。需要确定哪些数据需要共享，共享的边界是什么：产品间、产品内、模块内。实际上绝大多数考虑的应该是产品间的数据共享问题，因为基本上产品内的数据是共享的，除非你倾向于更细粒度的组织你的系统。

  除了共享数据，还要考虑数据冗余（这是另一种形式的共享），如供应商订单是否需要冗余客户信息，如何冗余，当客户信息发生变更后如何处理，这会影响到后续的接口设计，需要提前明确下来。

  通过合理的共享、冗余以及更新策略，确保数据模型之间的独立性，实现系统之间的拆分，以便从数据上实现松耦合。

### ***\*小结\****

  本节简单讨论了一下业务架构和数据架构的分层处理。通过对业务架构的逐层分解，可以明确业务过程边界，以可控的方式管理及演进业务过程，实现业务架构的松耦合。在业务过程分解的过程中，可以同步对数据架构进行分解，明确数据边界，实现数据架构的解耦。

 

## 第02课：技术架构松耦合

### ***\*概述\****

  技术架构（此处我们单指作为应用系统基础的技术平台）对于研发维护多个软件产品的企业并不陌生。它试图解决企业内部技术复用、提升研发效率、规范研发质量的问题。

  对于技术复用层面，除非是架构类型相差很大的软件产品（如企业信息管理系统与大数据分析系统），否则绝大多数公司更倾向于使用已有的技术框架来开发新的产品。这可以大大降低初期的技术成本。对于已经熟悉的框架，也不存在过多的学习成本（API 层面）和适应成本（规范层面），有助于开发人员快速投入开发工作。

  由于开发人员已经非常熟悉当前的技术框架，再加上针对相似的产品有丰富的面向业务的封装组件，这些组件通常易用、业务切合紧密，已经经过许多项目检验，非常健壮，这会大大提升开发人员的工作效率。

  此外，一个成熟的技术框架，一定在代码规范层面定义了良好的约束，使得代码更易维护。使用已有框架的好处就是，这些好的约束可以继承过来，开发人员已经熟悉了这些约束，不会有任何不适。

  以上都是一个通用的技术框架的好处，而且从中我们不难发现一个技术框架所包含的内容。

l 对于各种选型框架的集成。如 Spring MVC 与 Apache Shiro、MyBatis、Thymeleaf、Activiti 等的集成。

l 针对各种选型框架，提供相关的业务封装组件。如常见 CRUD 的封装、JSP 标签或者 JS 组件的封装、图表的封装。

l 提供软件开发规范及约束。如各层 API 的命名、配置文件的命名、参数命名等。

  这些都是比较常见的一个技术框架所包含的内容。但是在构建技术框架时，我们会面临与构建一个业务系统同样的问题，而这些问题却并不总是按照业务系统的构建思想来看待它。

  比如模块化，笔者接触到许多公司，对于技术框架还是以一种比较原始的方式来进行管理，即便他们对待业务系统时，习惯性的考虑如何划分子系统和模块。

  本文中，笔者尝试结合业务系统以及部分成熟框架的模块化方案，来探讨一下与松耦合技术框架相关的内容。

### ***\*技术架构起步\****

  当开始搭建一个通用的技术架构时，它最常见的结构可能如下图所示：

  这是一个集成了很多第三方框架的技术平台，它可能已经满足了很多业务系统的开发需求。

  但是作为一个公司内部的通用平台，显然它需要做的不止这些。因为我们除了要在技术框架集成层面做到复用，以避免每个项目重复这部分工作外，还要尽可能的提升开发效率。而提升开发效率通常有两种途径：

l 封装各种组件，减少功能开发中的重复性工作。如 JSP 标签库、JS 组件库、通用数据访问组件等。

l 提供手脚架，自动生成部分代码。最常见的是针对 ORM 自动生成持久层代码，当然也可以针对几种常见的页面布局，提供自动生成代码的机制，甚至对于诸如对象增删改查这种常见的管理功能，生成从前端到后端的全部代码。

  对于技术重复性工作，可以通过手脚架来解决，而对于功能重复性工作，则应通过封装各种组件来处理，以提升代码的可复用以及可维护性（但是需要保持封装组件的可扩展性，以便应对定制化需求）。

  ***\*注解：\****所谓“技术重复性”，指的是那些技术实现上相同或相似，但是具体数据不同的工作场景。如为不同的两张数据表生成 ORM 映射。所谓“功能重复性”，则是指在功能实现上相似的工作场景。如尽管是展现数据不同的两张表格，但都要设置分页条数、表头样式、单元格编辑器等。

  因此，进一步完善的一个技术框架如下图所示：

![x](./Resources/st003.png)



 

  在 Ruby On Rails 刚诞生那几年，在 Java 平台，也出现过几个手脚架项目，如 AppFuse（2016 年已停止维护）、Spring ROO 等。作为 Web 应用快速开发框架，它们的特点是，集成了基本的 Web 应用所需的技术（当然要比上图中的少很多），提供了从前端 JSP 至后端 ORM 的自动化生成。换句话说，不需要编写一行代码，即可实现对某个对象的管理功能。它们基本符合一个 Web 开发框架（或者成为平台）的定义，但是考虑到其适用人群，它们都是尽可能只做通用性的集成。但是作为企业开发平台，却往往包含对一些特殊框架的集成处理。

  除此之外，对于带有手脚架的开发框架，还要考虑如何将手脚架代码与通用组件分离，避免手脚架代码与所开发项目代码耦合，因为它们只是辅助开发的组件，并不需要包含到发布包中。

  这样的一个带有手脚架的开发框架，可能在一段时间内会满足大多数项目的快速开发，如果你幸运的没有遇到以下问题。

### ***\*随之而来的问题\****

  对于企业开发平台，最初，它可能只包含仅有的几个基础功能，如容器、数据访问、事务、安全认证、MVC 以及模板引擎。但是随着业务系统功能需求的增加或者其所支撑的业务系统数量的增加，这个技术框架会越来越复杂，集成各种各样的技术组件。

  如某个业务系统需要支持消息处理，那么便在框架中引入了 Apache ActiveMQ。如系统新增了批处理的需求，便又增加了 Spring Batch 的支持。如某个系统需要存储大量图片，那么我们就要考虑分布式文件系统，如 HDFS、Fastdfs。

  随着技术集成的日积月累，最终的样子（也许还会更复杂）会像上图中所示，它成了一个大而全的平台。也就是说从技术需求角度考虑，它是相对完善的。但是它却面临一个严重的问题——如何松耦合。

  它对于公司内所用到的技术无所不包，这个庞然大物不但厚重而且不稳定，稍不留神就会出现不可预料的缺陷。比如，也许一个业务系统并未使用工作流，但是却因为缺少了某个工作流的配置（也许是个非常简单的配置，但是每个系统却都要配置一下，无论需不需要），而导致启动失败。

  这种匪夷所思的问题对于业务系统开发人员来说是极度崩溃的，他们无法处理这些莫名其妙的问题，只能再反馈给平台的维护者。这就与测试人员发现一个需求的变更竟然导致一个毫不相关的功能出现致命缺陷一样，简直让人无法理解。

  还有就是各种依赖冲突问题，会发现由于 Spring 依赖的日志框架与 Hibernate 的版本不同，导致项目无法启动或者日志输出异常。

  也许有人觉得这种情况不可想象，基础框架怎么可能会糟糕成这个样子，可现实就是还有很多公司仍采用这种原始的方式进行基础框架搭建。可能是团队技术能力的问题，也可能是公司研发投入成本不足。

  不仅如此，我们还会面临另一个问题。也许不同的项目在少数几个组件的选型要求上会有所区别。如对缓存的选择，是 EhCache 还是 Memcached，具体到应用场景，有时候我们确实很难一刀切的规定只能用其中某一种。如果强制规定，要么是人为的增加了简单应用的复杂度，要么是降低了复杂应用的质量。这个时候，更好的方式可能是两种方案都集成，但是由项目具体选择使用哪一种。

### ***\*如何解决\****

  很明显，针对上面描述的问题。首先，多余的框架不应包含到项目中来。也就是说，如果我的项目没有批处理的需求，那么就不应该有 Spring Batch 的相关包，更不应该有与它相关的配置。其次，要支持在同类型（当然是有限的几种）框架中选择一个最适合当前项目的可选项。

  可以先来看第二个问题，这个相对比较简单。我们不妨看一下 Spring，Spring 最早集中于提供 IoC 的解决方案，因此对于一些成熟的第三方框架，它会提供相关的集成方案，以便直接在实际项目中使用。

  而且 Spring 对于同类型的框架，提供了风格一致的集成 API。也就是说，基本上不需要了解各种第三方框架的 API，而是通过一套类似的 Spring API 来使用这些框架。如针对数据访问层提供的模板类，无论是 Hibernate、JDBC 还是 Redis，它们的 API 都非常相似，易学易用。而且 Spring ORM 同时提供了对 Hibernate（多个版本并存）、Jdo、JPA 的支持，Spring Data 更进一步提供了对多种数据存储平台的支持，如 RDBMS、NoSQL 等。除了模板类外，Spring 对于功能相同、实现不同的各种组件还提供了一致的工厂类，如各种远程访问工厂。在实际项目中，我们可以任意选择其中的一种实现，而且使用配置极其相似，即便将来需要替换，成本也不会很高。

  对于每种框架的集成代码，Spring 的处理方式也不相同，我们可以视情况而定。如 Spring ORM 中，所有框架的集成都放到了一个包中，这样无论你是否使用 Hibernate，项目中都会包含这些类。而 Spring Data 的处理方式则更清晰一些，它对于每种集成方案拆分为一个包，你只引用需要的 JAR 包即可。因为集成代码相对第三方框架的代码毕竟数量要少得多，所以并不是主要问题。如果你的集成代码只有几个类，完全没必要单独发布为一个包，而如果你的集成代码相对数量比较多，则可以考虑按集成框架进行拆分（当然，数量并不是是否拆分的唯一因素）。

  所以，对于这个问题，一个关键点是，对于同类框架如何提供风格一致的 API，以便业务系统开发人员易于学习使用、减少迁移/变更成本。

  对于第一个问题，解决起来则要复杂一些。在 Spring Boot 等出现之前，更多的解决方式则是对平台按照集成的各种框架进行模块化拆分。

  我们继续拿 Spring 作为例子（毫不夸张的说，Spring 可以作为 Java 平台的一款教科书式的框架），它以 IoC 作为载体，将整个框架划分为多个模块，如 MVC、ORM、JMS、JMX 等等。你可以选择只将其中的某几个模块添加到你的项目中。同时，还需要添加这几个模块的依赖包。如果采用 Maven 或者 Gradle 等进行项目依赖管理，这个过程会简单的多。例如 Maven2，它支持传递性依赖，这样我们项目在引用这个模块时，就不必再关心它依赖哪些第三方包了，否则这将是一件比较折磨人的事情，因为你不可能总是记得清楚编译阶段依赖哪些包，运行阶段依赖哪些包，除非你已经在项目环境中开发了一个简单的功能并运行成功。

  模块化拆分加上传递性依赖，可以初步的实现技术框架中各组件的松耦合管理。当然，这种松耦合是指使用上的，而框架发布还是需要统一进行，否则容易导致依赖的第三方框架版本冲突的问题。

  通过这种方式进行管理的技术框架架构如下图所示（技术集成我们只是列举了很少一部分作为示例，以下图例同）：

   ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps11.jpg)

  当然，我们说，这只是框架演进的开始，下面继续。

### ***\*借鉴 Spring Boot 的思想\****

  通过诸如 Maven 等管理工具，我们可以方便的对技术框架进行模块化管理及使用，但是这种组织形式还是以单个 JAR 包为主，但有时候粒度相对大一些反而更方便。

  为什么这么说呢？因为项目中使用时基本上不是以单个模块进行添加的。比如，技术框架以“Spring MVC+模板引擎”的方式提供 Web 开发支持。此时，对于 Spring MVC 的集成和对于模板的集成需要拆分为两个模块，因为我们可能提供多种可选的引擎。而在实际项目开发中，则更希望指定一种组合式的依赖，而不是分别指定 Spring MVC 和模板引擎。

  很多用过 Spring Boot 的人，都说它是“傻瓜式”的。这是因为它屏蔽了绝大部分的集成细节，通过优秀的依赖管理，使得模块化添加非常自然便捷，不必担心依赖冲突等问题，更不必逐项添加你所依赖的 Spring 模块。

  只需要在项目的 pom.xml（以 Maven 为例）文件中添加各种 starter 即可（如 spring-boot-starter-web）。如果使用 springsource 提供的 STS 作为开发工具，那么可以直接使用该 IDE 创建 Spring Boot 项目。

![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps12.jpg) 

  上图是通过 STS 创建一个 Spring Boot 项目时的可选的 starter，可以说它涵盖了非常广泛的、各种用途的第三方框架的集成。

  在 Spring Boot 中，这些 starter 也是一个 Jar 包，它包含了一个 pom.xml 文件，声明了其所依赖的 Spring 模块、第三方框架及其版本。下图是 spring-boot-starter-thymeleaf 包含的 pom.xml，它依赖 spring-boot-starter 和 spring-boot-starter-web 两个 starter 和 thymeleaf 包。

![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps13.jpg) 

  使用时只需要简单选择自己希望使用的 starter 即可，完全不需要关心它的依赖问题。也就是说，通过这种方式，我们可以灵活组装自己的基础技术框架。

  而且在特定的 Spring Boot 版本内，第三方框架的版本肯定是统一的，不必担心存在版本冲突的问题。

  按照这种思路可以在自己的技术框架中，将完成特定功能的一组模块定义为一个单独的 starter（没有想到更好的名称，暂时也使用这个称谓），这样只需要在项目的 pom.xml 文件中添加该 starter 依赖，而不需要添加任何模块或者第三方框架的依赖。如下图所示：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps14.jpg)

  由图可知，我们的技术框架分为以下三层。

l 第一层：以第三方框架为基础；

l 第二层：对于各种集成方案进行模块化；

l 第三层：同时进一步将模块进行依赖整合，便于项目引用。

  我们的集成代码完全集中在第二层，而第三层仅仅是出于依赖管理的需要。

  我们的 starter 可以结合架构类型等来划分，如 Web 应用、SOA 应用、批处理应用等等。而 Web 应用则包含了我们要使用的 MVC 框架、模板引擎、持久化框架等。如果支持对模板引擎或者持久化框架的选型，那么可以针对 Web 应用提供多个 starter，如 thymeleaf-jpa-starter、freemarker-mybatis-starter。

  在这种情况下，我们的技术框架完全由 Maven 进行管理（可以搭建 Maven 私服），不必提供一个全集的技术框架发布包。新建项目时，按照包含的应用类型添加对应的 starter 即可。

### ***\*静态文件的管理\****

  对于技术架构部分，我们前面谈到的几乎都是如何有效的对第三方框架和集成代码（服务端）进行管理，而对于企业级开发框架，还忽视了一点，就是对于静态文件的管理，如第三方 JS 库、公司封装的 JS 库、CSS 框架等。显然，这些是无法按照前面的方案进行管理的。但是，尽管如此，最终的使用方式还是希望像前面讲解的一样简单，而不是手动复制文件和目录。这时候可以通过 Maven 的 archetype 来解决。

  针对我们要提供的应用类型，创建不同的 archetype。对于每种 archetype，创建静态资源目录，复制相关的静态文件，如富网络应用、Web 应用、移动 Web 应用等。假如创建的是一个复合应用（如富网络应用+SOA），那该怎么定义？没关系，现在主要解决的是静态文件管理的问题，对于未包含的，完全可以在 pom.xml 中添加其对应的 starter 即可。

  当我们按照前端的分类创建了各种 archetype 后，搭建项目环境就会变得更加简化，尤其是使用 STS 等 IDE 时。我们只需要选择合适的 archetype，便可一键创建项目的工程目录，它包含了我们想要的前端静态文件、所有依赖的第三方框架以及集成代码，它已经完全是一个可以正常运行的环境，而且不包含任何多余的我们不需要的内容。

  加入 archetype 后，我们的技术框架如下图所示：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps15.jpg)

### ***\*手脚架\****

  最后我们再谈一下手脚架，尽管很多人认为自动生成的代码维护起来比较麻烦，但是不可否认它会显著提升我们的工作效率。例如对于 Java 语言，如果稍微研究过 Eclipse JDT，那么完全可以结合公司代码规范、技术框架的 API，开发出自己的手脚架。如 Spring ROO 一样，我们可以通过各种命令以及命令选项，控制生成的内容，如 ORM、控制层、展现层。

  如前所说，手脚架只是一个辅助开发的工具，它不应包含在项目的发布包中。可以通过以下几种方式提供手脚架。

l IDE 插件：无论是 Eclipse，还是 NetBeans 等 IDE，都支持插件机制。通过开发一个独立的插件，我们可以在 IDE 中直观的选择配置并生成代码，而且这种方式不会对项目造成污染。

l 独立的手脚架目录：当创建项目工程时，单独建立一个目录用于存放手脚架代码。这种方式会对项目造成污染，尽管它不会最终包含在发布包中。而且这种方式只能通过命令行进行操作，与 IDE 的结合较差。

  至于手脚架可以包含哪些内容，只要是我们认为有助于减少开发人员工作量的工作都可以包含进来。它不像技术框架的组件，并不会影响最终的项目质量。只要项目开发人员认为自动生成的代码有问题，他完全可以基于自动生成的代码进行修改，以符合自己的需要，甚至也可以暂时不使用相应的命令，等待它们变得更加完善，而并不会阻塞项目的开发进程。

  当然，如果你正在开发一个手脚架，还需要注意手脚架生成代码与项目代码冲突的问题，避免由此导致的代码覆盖。例如对于一个自动生成 ORM 代码的手脚架，如果使用者在实体类中添加了自定义方法，那么后期 ER 变更需要同步更新实体类时，是否会直接覆盖这些自定义方法？当然，这个问题还会存在于可视化开发界面的一些工具中。你应该对于自动生成的代码进行良好设计，如预留自定义接口，以避免这种情况，使得即支持自定义代码扩展，又可以对自动化部分进行多次同步更新（***\*即自动生成的代码与自定义代码松耦合\****）。

  添加了手脚架的技术框架如图所示：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps16.jpg)

  在图中，我们为手脚架设置了不同的背景色，表示它不作为项目的一部分。

### ***\*小结\****

  对于技术架构的松耦合，它与业务功能的松耦合出发点并不完全一样。它更多体现的是一种 API 设计方法和模块化管理方式。通过风格一致的 API，降低研发人员的学习和使用成本，使组件易于替换。而通过模块化的管理方式，则可以使得项目开发环境的搭建大大简化，使开发人员不必关注各种依赖问题。

## 第03课：开发架构松耦合

### ***\*概述\****

  “开发架构”这个称谓对于有些人来说，可能使用“开发视图”更容易理解。总之，根据前文的讲解，应用架构包含了我们通常理解的架构视图的绝大部分，除了进程、部署等视图。

  无论称谓是什么，这里专指的应用系统在开发环境中的静态组织结构，也是项目开发人员具体的工作环境。因此这部分的松耦合与项目开发人员密切相关。

  谈到开发架构的松耦合，主要包含两方面的内容：

l API 依赖的松耦合。

l 项目模块（工程目录）的松耦合。

### ***\*API 依赖的松耦合\****

  实际上，在开发阶段，绝大多数人接触到的松耦合基本属于这一类。无论我们读过的代码设计相关的书，还是实际工作经验，又或是来自一些支持 AOP 的第三方框架的约束，这些都会促使我们按照一种良好的松耦合的方法来编写代码。如面向接口、继承、多态以及各种相关的设计模式等等。对于如何编写松耦合的代码，本文不再展开过多论述，相信阅读过诸如设计原则、设计模式之类书籍的人并不难做到。本文主要侧重于探讨针对我们编写的模块，如何处理模块之间松耦合的问题。

  首先，我们开发的绝大多数应用是分层的，如常见的 Web 应用分为展现层、服务层、持久层。应用分层便会存在层与层之间依赖的问题。诸如 Spring 等框架，通过依赖注入，使得层与层之间的依赖实现了松耦合。

  层与层之间的依赖注入，可以有两种形式。

l 面向接口：也就是说层与层之间通过接口实现松耦合。上层模块根据配置在容器中查找接口的实现，下层模块需要实现接口并注册到容器中。这种方式，接口成了层与层之间的耦合点，接口的变化会同时影响上下层。

l 面向代理：也就是说层与层之间不再有接口上的耦合。上层根据需要，定义一个接口代理，这个代理会自动查找下层模块的实现。下层模块不必实现相关接口（注意：这并不代表它不需要实现任何接口，而是不需要实现与上层耦合的接口），只需要在容器中注册即可。这种方式的好处是不存在接口变化的影响（尤其对于 Java 这种编译型语言）。但是它会产生更细粒度的依赖，如方法，因为至少需要在上层的代理中指定下层的组件名、方法、参数等信息。当然，如果下层模块方法实现的足够健壮（如充分考虑方法版本的兼容性），这种问题会减少很多。除此之外，面向代理的好处还有就是透明的切换下层组件的访问方式（本地、远程）。当然，这种方式与面向接口相比实现起来会复杂一些。

  其次，即便位于同一层中的各个模块（如服务层），也存在相互依赖的问题，比如订单服务需要访问客户服务获取客户资料。这种情况的解决方式应该与层与层之间的依赖类似。

  同一层各个模块之间的依赖（尤其是服务层）相对比较复杂的地方就是，对于传输对象的处理。举个例子：订单服务需要调用客户服务获取客户资料，积分服务也需要调用客户服务获取客户资料。那么对于客户服务返回的客户资料传输对象，便会形成一种模块间的耦合关系。

  对于这个问题，有不同的解决方式，并没有绝对的对与错，随着项目的不断迭代以及新出现的依赖方面的挑战可以不断修改处理的方法。总体来讲，可以有三种。

l 将每个模块发布服务的传输对象单独打包，依赖该服务的模块只需要依赖该传输对象的发布包即可。

l 将项目中所有模块的传输对象合并打包，各模块都依赖这个传输对象包。这是第一种方案的“懒惰”版，毕竟如果模块数量非常大时，管理工作量会比较大。当然这种方式的缺陷也很明显，是与模块化方向背离的。

l 每个模块使用自己的传输对象。这种方式只适用于那种弱依赖的远程调用（像本地调用、Spring Http Invoker 这种强依赖调用是不可行的）。也就是说，当模块调用外部服务时，按照自己使用的数据，定义传输对象。这种方式是耦合性最小的方式（部分讲解微服务的书也提到了这种处理方式），因为我们不需要关注服务发布方的全部数据，而是按需获取。当然这是一种很理想的服务调用方式，但是现实却是很多数据在多个模块之间是重复的。对于上面的例子，也许无论订单还是积分，都需要获取客户的名称、地址、联系方式等信息。结果就是，在这些模块的传输对象中，你都需要重复包含这些信息。

  如果认为传输对象重复定义是不可忍受的，那么可以选择方案一，如果项目这种情况并不多，那么可以选择方案三，如果认为合并到一起不是什么大问题的话，方案二也可以使用，即便后期需要拆分，这也并不难做到。

### ***\*模块的松耦合\****

  首先承认，这个标题并不合适，因为模块的松耦合也包括“API 依赖的松耦合”，但是我始终没有想到一个合适的称谓来描述它。

  通过讲解一个实际的工作场景，可能会更好的理解这个问题。设想我们的系统相对比较庞大，从前端到后端被拆分成了许多模块，如果在开发过程中我们想测试某个模块的功能（从前端到后端）。你喜欢仅仅启动测试模块及产生 API 依赖的模块，还是说你原意将整个系统启动起来？很明显，相信绝大多数人会选择前者。如果每次测试都要启动整个系统，那么开发测试的效率将会非常低，不仅仅是因为系统启动更加耗时，还因为其他模块可能存在缺陷（因为同时处于开发过程中，出现致命缺陷的概率非常大）导致系统无法正常运行。

  再考虑一个工作场景，实际上无论是 B/S 还是 C/S 结构的系统，无论我们最终将应用系统部署到服务器还是将服务器作为一个组件嵌入到应用当中，本质上来说，它还是遵从了 Servlet 规范（当然，此处指绝大多数，而不是所有）。虽然 Servlet 规范提供了多种模块化机制，但是它的入口却只有一个，即 web.xml 描述文件。如何将 web.xml 中的配置，以注解或者 web-fragment.xml 的形式分解到各模块中，也是实现松耦合的关键。

  我们也可以将上面的两个场景作为模块松耦合目标的一部分。而且这个层面的松耦合更有助于我们将系统向更细粒度的部署架构方向演进。可以说，这种方式已经距离微服务架构一步之遥，而且由清晰的模块化架构到微服务，这种循序渐进的架构重构更易成功实现微服务化治理。不仅如此，你还会发现，这种架构极易回退，如果你认为微服务并不适合你们。

  我们至少有两种方案可以实现将模块独立运行。第一种是采用 Servlet 规范的模块化机制，第二种是采用诸如 Spring Boot 的方式。

  我们先来看第一种。

#### ***\*Servlet 规范\****

  Servlet 规范支持应用配置的模块化和可插拔，主要分为三种方式：

l 注解

l SCI

l web-fragment.xml

  这三种方式都可以用于实现模块之间配置的松耦合，尽管它们的实现方式有所区别。

  对于注解的方式，我们需要在每个模块中定义自己的 Servlet、Filter 并添加相应的注解，用于分发处理当前模块的请求，以代替原有 web.xml 中的配置。理想情况下，web.xml 中不保存任何配置（由于应用服务器都会提供默认的 web.xml，因此项目中甚至可以不需要该文件）。

  这样，每个模块都变为一个可部署的 Web 应用（暂时不考虑静态文件，接下来会单独讨论）。模块与模块之间，除了必要的 API 层面的依赖，不会存在任何配置依赖。

  当然，实际情况可能要稍微复杂一些。例如设置请求/响应编码、安全认证，这些通用 Filter 我们更希望统一配置，而不是每个模块都要配置一次。此时，可以单独保留一个通用的“门户”模块，用于保存系统的这些基础配置。这个“门户”模块与其他模块并没有任何依赖关系，只是提供了请求映射层面的基础功能，因此它是可以轻易替换的。

  如果你使用的是一个来自第三方框架的 Servlet 实现，此时使用注解并不是一个好的选择（除非你愿意实现它的一个子类或者装饰类，以便添加注解）。

  此时，可以使用 @WebListener 注解，以编码的方式添加 Servlet，或者采用 SCI。

  SCI（ServletContainerInitializer）基于 SPI 机制，以编码的方式添加 Servlet、Filter。与注解相比，它扩展性更好。

  这两种方式都能在脱离 XML 的情况下，实现 Web 应用配置的模块化。如果你不希望 Servlet API 侵入每个模块，那么可以考虑 SCI 的方式。以通用模块的方式提供 SCI 实现，并自定义扩展机制，每个模块根据自定义的扩展机制声明自己的配置。

  最后是 web-fragment.xml，作为 web.xml 的片段，它与 web.xml 格式完全相同，完全是对 web.xml 内容的拆解。尽管在规范中，它支持加载顺序，我们还是建议不要使用该特性，而是要合理的划分各模块的请求地址，因为这种加载顺序的定义，也会造成模块间的依赖。

  这三种方案，你可以进行灵活选择，甚至混合使用（尽管我们建议只采用其中一种），这都不是关键问题。这一部分内容的一个关键点是你如何合理拆分各模块的请求，最好是通过开发规范的方式进行明确，以确保各模块之间独立开发而又不会重复。尤其是原有系统请求采用集中式处理的情况下（使用一个 Servlet 作为所有请求的入口）。

#### ***\*Spring Boot\****

  对于基于 Spring Framework 的 Web 应用来说，Spring Boot 提供了一种很好的模块化方案，或者换句话说，它本身就是高度模块化的。

  Spring Boot 通过自动构造嵌入式 Web 服务器和 Spring 容器，使得应用可以独立运行，而不需要部署到 Web 服务器中。也就是说，对于采用 Spring Boot 开发的程序，它的启动方式与你通过 main 方法启动任何 Java 程序是一样的。因此，我们可以为每个模块添加一个 main 方法，即可实现模块的独立配置。

  如果所有模块的配置都是一样的，我们甚至可以只在一个通用组件里加一个 main 类，无论是独立启动一个模块，还是启动整个系统，我们都使用这个通用组件作为启动入口。

  当然，你可能会疑惑，既然使用 Spring Boot，为什么不直接按照微服务这种架构设计系统，还要考虑统一启动的场景？我们说，对于微服务这类架构，更多是一种业务层面的驱动，从技术架构上我们则要考虑系统架构的适应性和灵活性。还有就是我们的系统除了服务还有 UI，如果它们也各自以独立的方式运行，这将会使系统复杂度大大增加。

Spring Boot 这种方式使得你可以像管理普通的 Java 程序一样管理 Web 应用。但是从本质上来说，它仍是通过前面所述的 Servlet 规范的机制实现的。只是 Spring Boot 屏蔽了 Web 容器的复杂性，使你可以像开发普通 Java 程序一样开发 Web 应用，并且在此基础上定义了自己的扩展机制以及默认配置，而使你不再需要再关注与 Web 容器相关的配置。

我们之所以将 Spring Boot 单独说明，是因为它与前面讲的基于 Servlet 规范的方案稍有不同，主要体现在：

· 前者以部署包的形式部署到 Web 服务器中，而后者是一个独立启动的程序。

· 前者存在对 Servlet 配置的分解，而后者是由 Spring Boot 自动装配（每个进程一个）。

  除此之外，Spring Boot 还很好的解决了静态文件的问题，下面我们会进行说明。

  资源文件处理

  首先，我们此处所说的资源文件，是指除 Web 应用中除 Java 代码以外的所有文件。它通常包含 JSP、各种模板文件（如 FreeMarker 等）以及静态文件（如 HTML、JS、图片、CSS 等）。

  如果你开发的是一个 SOA 应用或者 C/S 系统的服务端，应该不需要考虑资源文件在模块化过程中所造成的影响。但是，如果你开发的是一个 Web 应用，这却是需要加以考虑的一个问题。

  既然我们的代码按照业务耦合程度拆分成不同的模块，那么我们自然希望与之相关的资源文件也应该被拆分到相应的模块，而不是被放置到一起。

  当我们基于 Servlet 规范进行模块分解时，每个模块是一个可以独立发布到 Web 服务器的应用，因此它自然可以维护只与自己相关的资源文件。只不过这里需要考虑两个问题：

  （1）共用的文件，如 CSS 以及第三方 JS 库如何处理。

  （2）多个模块一起启动的问题。

  对于问题（1），建议将共用文件放置在一个单独的服务器上，各模块直接引用远程链接，而不是放置在本地。系统最终构建时，将这些文件包含进来即可。

  对于问题（2），在集成测试阶段还是比较常见，毕竟独立启动多个模块要更复杂一些，效率相对较低。

  但是部分 IDE（如 Eclipse）只支持将依赖项目以 JAR 的形式部署到当前的应用，而不支持对资源文件的处理。例如，有两个模块 A 和 B，当启动 B 时将 A 添加为依赖项目，此时，A 会作为 JAR 添加到应用 B，但是 A 中包含的资源文件却无法一并包含到应用 B 中，因此你是无法同时测试两个模块的页面的。

  当然，笔者并未尝试过其他 IDE，如果你正在使用的 IDE 支持对资源文件的归集，那么恭喜你。

  对于这个问题，解决起来也并不复杂，可以尝试以下方案：

l 将资源文件改由通过类路径加载，而不是存储目录。这是 Spring Boot 采用的方式。由于应用服务器（如 Tomcat）默认通过存储目录查找资源文件，因此需要实现自己的 Servlet 用于处理 JSP 以及静态文件。在 Spring Boot 中，所有请求均通过 DispatcherServlet 处理，通过为资源文件注册单独的 HandlerMapping，以支持通过类路径加载资源文件。在这种方式下，资源文件与 Java 类文件都会被包含到 JAR 包中，并无二致。

l 不使用 IDE 的自动部署功能，通过 Maven 等工具进行构建测试。在这种方式下，对于资源文件的修改，不能做到实时刷新，便利性大打折扣。

l 如果你熟悉 JDT（仅针对基于 Eclipse 的 IDE），可以扩展 IDE 的自动部署插件，使其支持合并部署。该方案具有一定的技术门槛，实践起来并不划算。

  比较之下，方案一实现起来最简单，同时也更便捷。当然，出于优化系统访问性能的考虑，静态文件更倾向于单独部署到前置 Web 服务器（如 Nginx）上。此时，只需考虑 JSP 以及各种模板文件的处理即可。

### ***\*小结\****

  对于开发架构的松耦合，主要体现在如何解决 API 依赖以及模块产出物（代码、配置、资源文件）的分解上。这种分解便于模块以更轻量级的方式运行，有利于系统整体架构向轻量级架构转型。

  如果你正在尝试将当前系统重构为微服务架构，不妨先尝试如何做类似拆分，这种拆分一定是由业务进行驱动。当你的系统以松耦合的模块化架构运行无碍后，微服务架构便已是一步之遥。

## 第04课：部署架构松耦合

### ***\*概述\****

  当下微服务架构风头正劲，它对系统服务按照业务进行细粒度拆分，每个服务以独立进程的形式启动，以便在架构上提供更好的伸缩性和有效性。

  微服务架构使得我们可以轻易对某个服务进行版本升级、扩容，一个服务的崩溃不会影响其他服务正常运行。这些都是微服务架构的优势，但是在获得这些优势的同时，我们需要付出更多的管控成本，因为你部署、维护及监控的应用程序已变为原来的数十倍甚至上百倍。当然，借助现代化的运维工具，这部分工作已不再令人望而却步。

  我们不止一次的说，微服务架构的演进更多是由业务进行驱动。若业务过程不能进行合理拆分，那么它的这些优势便不复存在。业务耦合会使它的伸缩性和有效性形同虚设。

  抛开微服务架构实施的难度，单从部署架构考虑，微服务可谓将松耦合做到了极致。正所谓：“道可为则，各从其宜”，在具体实践中，受限于客观条件（业务过程还不清晰、团队能力跟不上、运维水平达不到等等），我们很难将系统按照理论模型进行构建。这也使得我们探讨如何进行部署架构松耦合变得有意义。

  通过部署架构松耦合的渐进式重构，会在一定程度上提高系统部署的灵活性，使架构在团队可承受的范围内，逐步向理想状态迈进。

### ***\*几种参考\****

#### ***\*PHP内容管理系统\****

  很多人看到这个标题，可能会产生疑惑，但是我一直深信在架构理念上各种系统是可以相互借鉴的，即便是跨语言。

  如果你稍微了解当下流行的几款开源 PHP 内容管理系统，如 Joomla，就会发现它们都会提供内置的模块框架。每个模块通过系统可识别的描述文件进行自我描述。系统自动解析描述文件，加载模块，并对外提供服务。

  这种模块化框架不仅使系统变得极易扩展（你可以自行开发各种模块以丰富系统功能），也在部署运行期间为系统带来了更好的灵活性。

  在系统运行期间，我们可以灵活安装、卸载、升级模块，而不会影响系统中其它模块的运行。

  从架构层面进行概括的话，首先系统提供了统一的应用模块运行环境，并定义了模块的发布规范，其次，系统根据定义的规范识别并加载模块，对模块进行生命周期管理。从这个角度讲，它与 Java 应用服务器有很大的相似性，只是它更面向业务功能而已。

#### ***\*Java应用服务器\****

  我们通常习惯性的认为 Web 应用是一个应用程序，但是从操作系统层面看，它却不是。它只是可以部署到应用服务器中的一种组件而已，它需要在应用服务器的管控之下提供服务。因此，我们可以将应用服务器和部署到它里面的 Web 应用一起视作一个可执行的应用程序。

  如此审视应用服务器的架构，我们就会发现它是一个健壮的、高度组件化的、易于扩展、易于维护的应用程序。

  我们将部署在应用服务器中的 Web 应用视为其提供业务功能的组件，就会发现这个平台有以下优秀的特性：

l 平台提供基础的、业务无关的远程访问服务（HTTP/AJP）。

l 平台自动加载业务组件（Web 应用），并根据其描述文件（web.xml）对远程请求进行分发处理。

l 业务组件之间是完全松耦合的（类加载器的隔离机制），彼此互不干扰。

l 平台为业务组件提供生命周期管理。通过 JMX，我们可以添加、升级、卸载组件，以及对组件配置进行修改。

l 业务组件是可以任意组合的。我们可以将多个 Web 应用部署到一个应用服务器实例下，也可以将其分开部署。

  通过这种架构，我们很容易基于平台和业务组件对运行实例进行定制，对可选择的业务组件进行升级、扩容。

#### ***\*Jetty\****

  我们将 Jetty 这款轻量级 Java 应用服务器单独介绍，是因为抛开服务器对 Web 应用的松耦合管理不谈，它自身的模块化架构也是非常有借鉴意义的。

  在 Jetty 中，各种基础功能（如 http、session、jmx、gzip、jsp 等等）都是以模块的形式提供的。在我们创建 Jetty 部署目录（jetty-base）时，指定需要包含的模块。那么在这个 Jetty 实例运行时，便只包含这几个模块的功能。这种机制使我们对 Jetty 实例的定制变得非常容易，而这与 Jetty 的高度模块化是分不开的。

  Jetty 的模块包含的内容如下图所示：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps17.jpg)

l .mod 文件用于声明模块的依赖模块、包含 JAR。

l .xml 文件用于向 Server 注册本模块的组件。

l .ini 文件用于设置模块工作需要的系统参数。

  当我们使用 Jetty 提供的命令初始化一个 jetty-base 目录时，它会根据 *.mod 文件中的内容，分析模块依赖树，生成模块的 *.ini 配置文件。

  当我们基于这个 jetty-base 目录运行 Jetty 实例时，Jetty 会根据 *.ini 文件确定加载的模块，再依据模块对应的 *.xml 文件创建组件并注册到 Server 上。

#### ***\*OSGi\****

  与 PHP 这一类脚本语言开发的框架不同，Java 语言很难实现模块的动态化管理，或者说成本比较大。

  这主要因为 Java 语言是基于类加载器机制的。我们要在一个类加载器中实现模块的启动、卸载、升级以及依赖管理是不可能的。首先，一个类加载器不允许存在两个限定名完全一样的类，因此无法实现多版本管理，其次，类加载器中的类不是分模块管理的，当卸载或者升级模块时，你无法实时替换类或者移除类（除非销毁整个类加载器并重新创建）。但是，类加载器之间具有天然的隔离性，应用服务器也采用类加载器机制确保Web应用的隔离。

  但实现复杂并不代表不可能实现。OSGi 便是利用类加载器的隔离性，实现的一套动态模块化框架（更准确的说它只是一套规范，具体实现有 Equinox 和 Felix）。本文不打算详细展开介绍 OSGi 规范，感兴趣的可以[参考这里](https://www.osgi.org/)。

  简而言之，OSGi 框架是充分模块化的，体现在几点：

l 每个模块一个类加载器。

l 每个模块可以选择依赖的模块及版本，也可以选择自己对外公开的包路径（不公开的包路径外部无法访问）。

l 每个模块可以独立安装、升级、卸载，不影响程序运行。

l 支持多版本并存，透明实现升/降级。

  当然，OSGi 还有很多优秀的特性，不再一一赘述。

  你可以发现，OSGi 是一个最完善的模块化方案，但是不得不说，在大多数情况下它显得过重。换句话说就是，你没有享受到它的好处，却承受了它的复杂度。

### ***\*我们该怎么办\****

#### ***\*需要考虑的几个方面\****

  通过分析上面的几个参考，我们大概总结一下模块化需要考虑的几个方面：

l 自我描述文件。模块需要一个描述文件以告知运行环境（容器）它提供了哪些功能（包）、版本、依赖哪些模块以及相关的参数配置。运行环境（容器）在启动时，可以根据自我描述文件完成模块的加载。简而言之，需要至少做两件事，告知容器如何加载“我”，告知容器“我”能做什么（需要容器提供相应的机制，便于模块进行服务/功能注册）。

l 支持模块对容器生命周期事件的监听及处理。模块可以根据这些生命周期事件完成一些初始化、注册以及销毁的处理。

l 在系统运行状态下，实现对模块的安装、升级、卸载。这是最灵活也是要求最高的一个特征，当前只有 OSGi 和应用服务器（Web 应用管理）可以做得到。

l 模块之间要有适当的隔离性，避免产生耦合。这个不难理解，大多数情况下我们在开发架构层面已经做了充分的工作。

l 容器负责对模块生命周期进行管理及监控。通过容器监控，我们可以实时获取模块的运行状态，可以在运行状态下修改模块配置。

#### ***\*方案选择\****

  从前面的讲解，我们可以知道，基于 Java 的模块化方案，动态的安装、升级、卸载复杂度是最高的，而这些都需要底层的基础容器完成。因此，我们需要仔细考虑引入这种复杂度是否划算，其带来的收益是否值得。

  对于一些需要持续运行的非集群环境（如车载系统）就必须要考虑动态模块管理的问题，因为你不可能将系统停止进行升级。而对于可集群部署的环境（如常见的 Web 应用），那么我们完全可以将应用停止来进行升级，因此对于动态管理的需求并不突出。而引入诸如 OSGi 这种动态模块化框架所带来的成本则非常大，包括开发、测试、管理及运维监控。它对整体架构的影响甚至比你直接拆分为微服务都要大。

  笔者几年前曾经尝试一种更粗粒度的基于 OSGi 的模块化方案，在这个方案中，数个 OSGi 组件合并为一个模块，系统以模块为单位确定依赖关系，进行生命周期管理。通过监控平台，支持对模块进行动态维护。后来发现在 OSGi 环境下开发系统所带来的成本远远超过了它带来的收益。

  更多的情况下，我们并不是希望动态管理模块，而是只需要做到灵活部署就行了。因此，像 Jetty 这种，通过简单的命令便可以确定当前实例包含的模块，是一种更好的选择。至于模块之间的隔离性，多数情况下并不需要做到类加载器级别。

  对于一款 Web 应用，模块化架构如图所示：

  ![img](file:///C:\Users\23907\AppData\Local\Temp\ksohtml21028\wps18.jpg)

  每个模块提供一个描述文件，告知容器它依赖的模块、包含的 JAR 包、支持的属性参数等。

  应用容器在初始化时，根据“配置文件”确定要加载的模块及其依赖模块。如果你的开发架构松耦合做的足够好，已经将 web.xml 去掉，那么可以在应用中添加一个自定义文件，否则，你可以将配置放到 web.xml 中。容器分析依赖路径，得到当前实例需要加载的模块。

  对于模块的加载，则有两种方式：

l 得到加载模块的 JAR 包合集并进行加载。你会发现这种情况下，类加载器是自己维护的，作为 Web 应用类加载器的子加载器（如果你的应用服务器为嵌入式，如 Spring Boot 应用，那么你完全可以避免这一点）。这相当于是你自己实现了一套类加载机制，因此我们并不推荐这种方案。

l 如果你仍希望使用 Web 应用类加载器，那么可以只模块化加载配置文件，对于 JAR 包则全集加载。这种情况，不需要改变 Web 应用的类加载器，但是仍需要平台提供模块解析及加载的功能，会对开发架构的松耦合带来影响。

  除此之外，还有一种方式，就是将模块配置分析的过程放置到部署脚本中，部署脚本根据分析结果创建定制的部署包进行部署。这种方式不需要对应用程序的类加载机制进行改造，实现起来相对比较简单，对开发架构的影响也最小（还有就是它的产出物没有任何多余的内容，无论是配置文件还是 JAR 包）。

### ***\*小结\****

  本文探讨的部署架构的松耦合是在将应用拆分成独立的进程之前的一种中间状态，它比管理多个进程要容易一些，适合对应用按模块灵活组合并以独立实例的方式运行。

  它需要结合前期的开发架构松耦合同步进行，尽可能不改造原有 Web 应用的构架（否则会带来不可预知的管理成本），在符合 Servlet 规范的前提下实现。

  经过这种改造，在没有实现微服务架构的情况下，也可以对系统进行按模块运行以及扩容。

## 第05课：总结

  本文作为该课程的最后一部分，对该课程涉及的知识点作一个简单回顾和梳理。

### ***\*系统架构分解\****

  在系统架构分解这一部分大概讲解了系统架构所包含的内容。当我们审视一个系统时，我们需要知道它的“重要决策”包含哪些方面，每个方面涉及哪些内容，需要以什么样的形式去描述。

  详细介绍每种架构的内容及方法显然已经超出本文的范围，你如果感兴趣可以去了解一下 TOGAF、eTOM，当然还有应用架构的 4+1 视图等，都是我们用来做架构的有效的方法论。

  我们在本教程中一直强调方法论和架构的治理。因为只有做到有效的治理，你的架构才能进行持续的可控的演进，确保在架构演进的同时，系统的健壮性和有效性不受影响。

  还有，你也应该注意到，部分架构知识本教程并未涉及到，如基础设施层，它同样非常重要，也有很多需要关注的问题，只是与本教程主要谈论的松耦合关系不大，因而没有提及。

  还有就是对松耦合的定义，我们一定要从广义上来认识它，在架构的各个方面，都会或多或少涉及到松耦合，有业务上的耦合、数据上的耦合、系统/模块上的耦合、部署上的耦合等等。而我们需要做的就是发现各层面的耦合点，找到合适的解决方案。当然，实际工作中，可能不是由一个人去承担这所有工作，这又需要各个岗位的协调和沟通。

### ***\*业务架构及数据架构松耦合\****

  在业务架构和数据架构部分，我们主要讲了如何分层去划分业务过程。通过对业务过程的分层管理，可以实现以下目标：

l 满足不同利益相关者的需求，如 CxO（诸如 CEO、CIO、CTO 等等），他们并不关注每个服务的详细实现，他们只需要知道核心业务过程的高层分解即可。而对于设计人员和开发人员，他们则需要知道详细的业务流程，通过提供不同层级的视图，可以满足他们各自的需要。

l 使得业务过程变更可控，通过业务过程的分层，我们很容易知道业务过程概貌。当业务过程发生变更时（尤其是核心业务过程），它会影响到不同层级分解视图的变更。通过先在高层视图进行变更评估，然后逐步分解传导到低层视图，这种方式使得变更的影响范围可控。

l 这种逐层分解的过程，有利于你以参与角色、核心过程作为基础，逐步延伸业务过程和数据模型，以提供更完善的功能支撑。因为只有当你对业务过程有一个正确的全局观时，才会做到业务架构的逐步演进。

l 良好的业务分层和管控，会给应用架构以正确的指导。通过正确的业务过程分解，我们会提早发现一些对业务处理和数据的技术性要求。应用架构以此作为目标进行构建，避免后期出现应用架构无法满足（或者通过不断调整才能满足）业务需求的情况。例如，业务分层明确了系统和模块的边界，那么在业务过程中，系统间如何通讯？实时性要求如何？需要哪些数据？这些都可以作为应用架构的参考（通过分析“业务流程”部分的输出结果，我们不难发现各系统都需要哪些接口通讯。）。

l 通过业务过程的分解，我们可以以参与角色、核心模型、核心模型附属模型、边缘模型的顺序推演出我们的数据架构，确保数据架构可以有效支撑业务场景。尤其是在产品初创阶段，这种方式可以有效避免开发过程中频繁变更数据模型。后期的变更不仅极易使得数据模型失控，而且也导致数据架构和逻辑/物理实现不一致。

### ***\*技术架构松耦合\****

  技术架构松耦合主要解决技术架构日益臃肿的问题。尤其在 Java 平台，随着依赖的第三方框架的增多，由第三方框架导致的传递性依赖会使得各种库的版本极易出现冲突。因此看似可以随意组合的主流中间件框架，由于一些通用工具库（如日志、XML、JSON 等）的版本问题，会使得你不断调整各个框架的版本，以期达到一种脆弱的有效性。

  除此之外，我们应该致力于使得产品中的第三方框架尽量精简，去除那些不必要依赖库。这样不仅会大大降低发布包的大小（一个功能很少的产品的发布包都需要几十兆，这是不合理的），也会减少由于不必要的配置而引入系统运行问题的风险。

  本教程主要从两个层面出发：

l 第三方库及集成代码的松耦合管理。通过 Maven 等管理工具，我们可以将经过验证的第三方库和模块化的集成代码划分为不同的应用类型。当构建产品时，根据应用类型，自动完成技术架构的搭建工作。

l 静态文件的管理。主要是如何管理依赖的第三方 JS 库、CSS 等资源。

l 手脚架的管理。严格的说，手脚架不属于产品发布包中的一部分，但是它可以包含在技术架构中简化我们的开发工作，将开发人员从重复、单调的工作中解放出来。

### ***\*开发架构松耦合\****

  开发架构的松耦合主要包含两部分。一部分是我们常见的 API 松耦合，你可以根据自己的具体情况，选择适合自己的方案。

  另一部分是模块的松耦合，主要指如何将各个模块的配置、资源文件进行分解，避免其相互依赖。 这样做有几点好处：

l API 松耦合可以降低模块之间功能的相互影响，这也是“松耦合”带给我们的最直接的好处，不仅缩小了变更范围，也减少了变更导致的意外缺陷。

l 模块的松耦合可以使得模块做到独立的启动。这样做的好处是，使得模块更易于测试和部署。若要实现部署架构的松耦合，这部分是必须要做的。

  对于模块的松耦合，大多还是利用了嵌入式服务器和 Servlet 规范的模块化支持。这也是成本最低的一种方案，因为相对于你自行设计的方案，Servlet 规范更健壮而且天然的适用于各种应用服务器（而且既然已经有了现成的方案，我们又何必重新发明轮子呢！）。

### ***\*部署架构松耦合\****

  在部署架构松耦合部分，我们只是简单的列举了几个场景。但是借鉴这几个场景，可以使得我们的应用系统实现模块任意组合打包和部署。

  本部分讨论的部署架构并非最先进的，但也不能说是已过时的，主要还是要看你的应用场景，并不是所有场景都适合诸如微服务、无服务等架构，甚至很多场景都不适合，毕竟软件涵盖的行业和应用类型数不胜数，而我们看到的代表先进架构理念的产品只占了这些行业和应用类型的很少一部分。不要为了技术而技术，否则你的应用的可用性会受到极大的影响。

  对于绝大多数应用，如果你做到了模块的任意组合打包及部署，那么往更高级架构升级时，相信也不会很困难。

### ***\*小结\****

  至此，本课程的所有内容已经结束，如果它能为你的应用系统架构工作带来些许帮助，那么对我们来说将会是非常欣慰的事情。限于文章的篇幅，有些方面我们只是概要讲述，并未详细展开，如果你原意就架构的某个方面与我们进一步探讨，也可以在本课程的读者圈给我们。由于文章编写较为仓促，如果内容有何纰漏，还请及时告诉我们，在此表示万分的歉意。

 

# ***\*架构基础\****

 

## ***\*架构到底是指什么？\****

 

 

## ***\*架构设计的历史背景\****

 

## ***\*架构设计的目的\****

 

## ***\*复杂度来源\****

 

### ***\*高性能\****

 

### ***\*高可用\****

 

### ***\*可扩展性\****

 

### ***\*低成本、安全、规模\****

 

### ***\*架构设计三原则\****

 