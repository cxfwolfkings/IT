# 入门

## 变量，表达式和语句

### 变量和类型

- 变量是指向各种类型值的名字，以后再用到某个值时，直接引用这个名字即可，不用在写具体的值。

  在Python中，变量的使用环境非常宽松。没有明显的变量声明，而且类型不是固定的。你可以把一个整数赋值给变量，如果觉得不合适，把字符串赋值给它完全可以。

  如果你不能确定变量或数据的类型，就用解释器内置的函数type确认

  只要是用双引号或单引号括起来的值，都属于字符串

### 变量名和关键字

- 程序中的变量名要有实际意义。变量名可以是由数字和字符组成的任意长度的字符串，但必须以字母开头。python是区分大小写的。举个例子来说，Name和name是两个不同的变量名。

  符号"_"连接由多个单词组成的变量名。

  如果定义了一个错误的变量名，解释器显示语法错误。请看下面的例子：

  ```py
  >>> 1_first = "第一名"`
  SyntaxError: invalid syntax
  >>> my$ = "dollar"
  SyntaxError: invalid syntax
  >>> print = 12345
  SyntaxError: invalid syntax
  ```

  变量`1_first`不应以数字开头；变量`my$`包含非法的字符；变量名`print`与python定义的关键字`print`重名，所以`print`不能再当作变量名了。python定义了28个关键字：

  and continue else for import not raise
  assert def except from in or return
  break del exec global is pass try
  class elif finally if lambda print while

### 语句

- 语句是Python解释器可以执行的命令。

  赋值语句有两个作用：一是建立新的变量，二是将值赋予变量。任何变量在使用时，都必须赋值。否则，被视为不存在的变量。

  当打印不存在的变量时，系统给出错误信息。

  ```py
  >>> print abc #错误语句，没有该变量。
  NameError: name 'i' is not defined
  ```

  一般的情况下，我们用状态图表示变量的状态。左边是变量的名称，右边是变量值，中间的箭头指向值。状态图显示了赋值语句的最终操作结果

  打印语句print输出表达式的计算结果。单个变量也可以看作是表达式。如果你想在一行打印多个变量，可以用逗号将这些变量隔开，逗号禁止换行。

### 表达式

- 表达式由值、变量和运算符组成。单一的值或变量也可以当作是表达式。

### 运算符和操作数

- 运算符是像加号和减号之类的特殊符号。运算符操作的对象是操作数。

  操作数还可以是变量，当运算执行前，变量被它所指向的值替代。

  需要注意的是除法运算。如果除数和被除数都是整数，那么结果是截调小数部分的整数。解决的办法是将除数和被除数任意之一加小数点，或是加小数点和零。例如：

  ```py
  >>> 5 / 2
  2
  >>> 5.0 / 2
  2.5
  >>> 5 / 2.0
  2.5
  >>> 5 / 2.
  2.5
  ```

  Python还支持复数的运算。复数有两种表示方法，一种如：

  ```py
  >>> a = 1 + 5j
  >>> b = 4j
  ```

  另一种是用函数的方法：

  ```py
  >>> x =complex(1, 5)
  >>> print x
  (1+5j)
  ```

### 运算的顺序

- 如果表达式中有不止一个运算符，那么计算的顺序依靠“优先规则”。Python运算符的“优先规则”和算术的相同。以下关于“优先规则”的建议：

  - 小括号有最高的优先级。在表达式中，括号内的首先计算。我们可以利用括号使表达式更容易读懂，而不影响计算结果。
  - 乘幂运算的优先级仅次于小括号。

    ```py
    >>> （1 + 3） ** 2
    16
    >>> 3 * 3 ** 2
    27
    ```

  - 乘法和除法的优先级相同，比加减法的优先级高。加减法的优先级也是相同的。
  - 具有相同优先权的运算符从左到右进行计算。

### 字符串操作

- 通常情况下，字符串放在双引号或单引号之间。字符串不能进行除法、减法和乘法运算。

  加法"+"能够连接两个字符串成为一个字符串。

  符号"*"也可以操作字符串。只是其中一个操作数必须是字符串，另一个必须是整数。字符串被重复整数遍。例如：

  ```py
  >>> 3 * "Love"
  'LoveLoveLove'
  >>> string = "python"
  >>> string * 2
  'pythonpython'
  ```

### 组合

- 可以把变量，表达式和语句组合起来，完成一项具体的操作。

  赋值语句，即等号“=”的右边可以是任意的表达式。表达式的值是什么类型，变量就是什么类型。

  有一点要记住，赋值语句的左边不能出现表达式。

### 注释

- 好的习惯是在程序中加入适当的注释，以解释它要做的事情。注释必须以符号"#"开始：

  ```py
  # 打印1＋1的结果
  print 1 + 1
  ```
  
  注释可以单独占一行，也可以放在语句行的末尾

## 函数

我们已经见过了函数调用的例子：

```python
>>> type("world")
(type 'str')
```

函数type，它的作用是显示值和变量的类型。括号内的变量和值是函数的参数。函数返回的结果叫返回值。
我们可以把type的返回值赋值给变量：

```python
>>> name = type("pitianjian")
>>> print name
<type 'str'>
```

函数id以值或变量为参数，返回值是一整数，它表示值或变量的唯一标识符。

```python
>>> id(123)
11602164
>>> number = 123
>>> id(number)
11602164
>>> number = "123"
>>> id(number)
13087320
```

每个值或变量都有一个唯一id，id值与变量或值在内存中的位置相关。变量的id也就是它所指向值的id。

### 函数定义

我们可以创建自己的函数，来执行特定的操作。

函数的名字也必须以字母开头，可以包括下划线"_"，但不能把Python的关键字定义成函数的名字。函数内的语句数量是任意的，每个语句至少有一个空格的缩进，以表示此语句属于这个函数的。缩进结束的地方，函数自然结束。

下面定义了一个两个数相加的函数：

```python
def add(p1, p2):
  print(p1, "+", p2, "=", p1+p2)
```

调用函数：

```python
add(1, 2)
```

函数的目的是把一些复杂的操作隐藏，来简化程序的结构，使其容易阅读。函数在调用前，必须先定义。也可以在一个函数内部定义函数，内部函数只有在外部函数调用时才能够被执行。程序调用函数时，转到函数内部执行函数内部的语句，函数执行完毕后，返回到它离开程序的地方，执行程序的下一条语句。

### 函数的行参和实参

上例函数中p1和p2是函数的行参。

1和2是函数的实参。实参把它的值传递给行参，行参被函数内的语句进行各种操作，而实参没有被改变。
函数也可以将变量或表达式当作它的参数。

### 变量的范围

Python有一个主函数：_main_。其它的函数都是在这个函数内执行，或者说_main_调用你的程序及程序内的函数。你在任何函数外创造的变量都属于_main_。

### 函数的返回值

函数的返回值，形象的说是函数结的“果实”；有返回值的函数，称之为“结果”的函数。

```python
import math

def area(radius):
  return math.pi * radius * 2
```

"return"语句的意思是：将表达式的值立即返回，表达式可以是任意复杂的。

有时根据不同的条件，函数能够有多个返回语句。这些return语句处于不同的条件语句中，并且只可能有一个return语句被执行，之后函数就终止了。

在有返回值的函数中，一定要保证每个可能的流程都对应着return语句。如果函数缺少一条对应分支的return语句，这种情况下，函数返回值是None（注意N要大写）。

None是什么类型呢？可以用函数type检验一下：

```python
<type 'NoneType'>
```

由此可见，None是不属于任何类型的类型。

### 类型转换

Python提供了将变量或值从一种类型转换成另一种类型的内置函数。int函数能够将符合数学格式数字型字符串转换成整数。否则，返回错误信息。函数int也能够把浮点数转换成整数，但浮点数的小数部分被截去。

函数float将整数和字符串转换成浮点数。

函数str将数字转换成字符

整数1和浮点数1.0在python中是不同的。虽然它们的值相等的，但却属于不同的类型。这两个数在计算机的存储形式也是不一样。

### 数学函数模块

Python有一个math模块，提供了大部分与数学计算相似的函数。模块是一个文件，它是功能类似的函数的集合。

如果我们想利用math模块中的函数，首先要用关键字import引入模块，然后用点操作符调用模块中的函数。

如果你不想用点操作符，而直接写出math模块中的函数，需要用下面的语句重新输入math中的函数：

```python
from math import *
```

如果你定义的函数中有与模块中函数同名的，模块中函数将被覆盖，即使用点操作符也不能调用模块中的函数。

### lambda函数

Python允许你定义一种单行的小函数。定义lambda函数的形式如下：

labmda 参数：表达式

lambda函数默认返回表达式的值。你也可以将其赋值给一个变量。

lambda函数可以接受任意个参数，包括可选参数，但是表达式只有一个：

```python
>>> g = lambda x, y: x*y
>>> g(3,4)
12
>>> g = lambda x, y=0, z=0: x+y+z
>>> g(1)
1
>>> g(3, 4, 7)
14
```

也能够直接使用lambda函数，不把它赋值给变量：

```python
>>> (lambda x,y=0,z=0:x+y+z)(3,5,6)
14
```

如果你的函数非常简单，只有一个表达式，不包含命令，可以考虑lambda函数。否则，你还是定义函数才对，毕竟函数没有这么多限制。

## 条件表达式

### 布尔表达式

布尔表达式的值只有两个：真和假。在Python语言中，真值为1，假值为0。

### 逻辑操作符

Python有三种逻辑操作：and、or、not。这三个操作符的语义与其英语意义相同，分别是：与、或、非。

严格来说，逻辑操作符的操作数应该为布尔表达式，但Python对此处理的比较灵活，即使操作数是数字，解释器也把他们当成“表达式”。

非0的数字的布尔值为1，0的布尔值是0；空字符串为假，非空字符串为真。

### 条件语句

if语句由“头”和“块”组成，它的书写方式在Python中具有典型的代表性：

```python
Header:
  First Statement
  Second Statement
  ......
  Last Statement
Other Statement
```

“头”是if语句的开始，以冒号结束。在“头”里进行条件判断，以确定是否执行if语句的“块”部分。

在if语句的“块”的每一行，必须至少有一个空格的缩进，缩进表示这一行是属于if语句的一部分。

第一个没有缩进的语句标志着if语句的结束。“块”内至少有一条语句，如果暂时还没有任何操作，你可以加一条语句pass，它什么都不做，是一条空语句。

示例：

```python
def isParity(x):
  if x%2 == 0:
    print x, "是偶数"
  else:
    print x, "是奇数

def largeNumber(x, y):
  if x < y:
    print x, "小于", y
  elif x > y:
    print x, "大于", y
  else:
    print x, "等于", y
```

### while语句

九九乘法表示例：

```python
def minus():
  x = 0;
  y = 0;
  while(x <= 9):
    while(y <= 9):
      if(y == 4):
        print x, "*", y, "=", x * y
      else:
        print x, "*", y, "=", x * y, ' ',
      y = y + 1
    print
    x = x + 1
    y = 0
```

### 条件嵌套

```python
def isEqual(x, y):
  if x == y:
    print x, "等于", y
  else:
    if x < y:
      print x, "小于", y
    else:
      print x, "大于", y
```

### return语句

return在函数中返回函数值。它的另一个作用是当函数内有错误发生时，终止函数的运行，提前退出。

### 键盘输入

Python提供了内置的函数获得键盘的输入。这个函数是raw input，它被调用时，程序暂停执行，等待用户输入一些信息。当你按下回车键后，程序恢复执行，并且raw input 返回用户输入的内容。

```python
>>> name = raw_input("Please input your name:")
Please input your name:pidaqing
>>> print name
pidaqing
```

## 字符串

### 组合数据类型

string类是由多个字符组成的。我们可以把字符串当成一个整体，也可以取得字符串的任何部分。操作符"[]"从字符串中取出任意个连续的字符。函数len返回字符串的长度

### 用for语句遍历字符串

```python
def travel(string):
  index = 0
  while index < len(string):
    letter = string[index]
    print letter
    index = index + 1
```

Python提供了另一种语句for来遍历字符串，它的用法更加简练：

```python
for char in address:
  print char
```

### 字符串片断

字符串的一部分叫做片断。选取片段与选单个取字符很相似：

```python
>>> os = "Linux Unix FreeBSD"
>>> print os[0:5]
Linux
>>> print os[6:10]
Unix
>>> print os[11:18]
FreeBSD
```

操作符[n:m]返回字符串的一部分，从第n个字符开始，到第m个字符结束，包括第n个，但不包括第m个。如果你忽略了n，则返回的字符串从索引0开始；如果忽略了m，则字符串从n开始，到最后一个字符。

如果我们试图用"[]"操作符修改字符串中的任何一个字符，将产生运行时错误。这表明字符串的值是不可改变的。最好的办法是取原字符串的一部分和添加的字符串相加，生成一个新的字符串

```python
>>> str = "python"
>>> newstr = "P" + str[1:]
>>> print newstr
Python
```

下面的例子是从一个字符串中，寻找是否存在给出的字符：

```python
def find(string, ch):
  index = 0
  while index < len(string):
    if string[index] == ch:
      return index
  index = index + 1
return -1
```

一个计算字符串中出现字符次数的函数：

```python
def count(string, ch):
  count = 0
  for char in string:
    if char == ch:
      count = count + 1
  print count
```

### 字符串模块

字符串模块string包含一些处理字符串的函数。在用模块前必须先引入：

```python
>>> bookname = "new concept english"
>>> import string
>>> index = string.find(bookname, "s")
>>> print index
17
```

编写一个判断字符是否为小写的函数：

```python
import string
def isLower(char):
  return string.find(string.lowercase, char) != -1
```

判断一个字符是否存在于字符串中：

```python
import string
def isLower(char):
  return char in string.lowercase
```

## 列表

列表是一组任意类型的值，按照一定顺序组合而成的。组成列表的值叫做元素(Elements)。每一个元素被标识一个索引，第一个索引也是0。列表中的元素可以是任意类型，甚至是列表类型，也就是说列表可以嵌套。

### 列表值

列表中的元素可以是不同类型，也可以是变量，但是修改变量的值，并不影响列表中元素的值。

```python
>>> a = 1
>>> b = 2
>>> num = [a, b, 3]
>>> print num
[1, 2, 3]
>>> a = b =9
>>> print num
[1, 2, 3]
```

包含连续整数的列表是很常见的，因此Python提供一种简单的方法创建他们：

```python
>>>range(1,5)
>>>[1, 2, 3, 4]
```

函数range返回一个整数列表，列表从函数的第一个参数开始，到最后一个参数结束，不包含最后一个参数，相邻两数之间的差值是1。

还有一种特殊不包含元素的列表，称为空列表。并且它被表示为"[]"。列表可以赋值，或作为参数传递给函数。

### 读写元素

读写列表中元素的方法与读写字符串中字符的方法一样－都是通过操作符"[]"。中括号内的表达式代表索引，请记住索引是从0开始的。

索引也可以是一个负数，那么列表的最后一个元素的索引是-1，倒数第二个的索引是－2，依此类推。

### 列表的一些方法

append在列表的尾部追加元素，参数是插入元素的值：

```python
>>> number = [0, 1, 2, 3]
>>> number.append(4)
>>> print number
[0, 1, 2, 3, 4]
```

方法insert在列表中插入元素，它有两个参数，一个是索引位置，一个是插入元素的值：

```python
>>> number.insert(3, 5)
>>> print number
[0, 1, 2, 5, 3, 4]
```

方法extend合并两个列表为一个：

```python
>>> nation1 = ["French", "German"]
>>> nation2 = ["Chinese", "Korean"]
>>> nation1.extend(nation2)
>>> print nation1
['French', 'German', 'Chinese', 'Korean']
>>> print nation2
['Chinese', 'Korean']
```

方法index取得元素的索引值

方法remove从列表中删除第一次出现的值

方法pop删除最后一个值，然后返回这个值

### 列表长度

函数len返回列表的长度，即元素的个数。可以用这个值作为遍历列表的变量。这就意味着，即使列表的长度改变，我们也不用对程序的循环次数作出更改。

in是一个布尔操作符，它测试左边的操作数是否包含于列表。

```python
>>>os=["Linux","Unix","Mac","Windows"]
>>>'windows' in os
1
>>>'BeOS' in os
0
```

in也可以测试字符串中是否包含某个字符

我们可以用not和in 的组合来测试一个元素不包含于列表。

```python
>>>os=["Linux","Unix","Mac","Windows"]
>>>'BeOS' not in os
1
```

### 列表和for循环

用for循环遍历列表，更加简明，它没有循环变量。

```python
os=["Linux","Unix","Mac","Windows"]
for os in os:
  print os
```

### 列表操作符

加号操作符"+"将两个列表连接成一个列表：

```python
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print c
[1,2,3,4,5,6]
```

类似的，乘号操作符“*”表示把列表的所有元素重复一定的次数，然后形成一新的列表：

```python
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

### 列表片断

通过操作符"[]"，将列表元素连续取出的部分，叫片断。

```python
>>> list = ['a', 'b', 'c', 'd', 'e', 'f']
>>> list[1:3]
['b','c']
>>> list[:4]
['a','b','c','d']
>>> list[3:]
['d','e','f']
>>> list[:]
['a','b','c','d','e','f']
```

只要在"[]"内包含冒号":"，所取的片断依然是列表，否则，就是元素的原始类型。

```python
>>> a = ["python", "Java", "perl"]
>>> type(a[:])
<type 'list'>
>>> type(a[0:0])
<type 'list'>
>>> type(a[1:])
<type 'list'>
>>> type(a[1:2])
<type 'list'>
>>> type(a[-1])
<type 'str'>
```

### 列表元素是可变的

和字符串不一样，列表的元素是可更改的，这意味着我们可以修改、添加或删除列表的元素值。

```python
>>> fruit = ["banana", "apple", "quince"]
>>> fruit[0] = "pear"
>>> fruit[-1] = "orange"
>>> print fruit
['pear','apple','orange']
>>> list = ['a','b','c','d','e','f']
>>> list[1:3] = ['x','y']
>>> print list
['a','x','y','d','e','f']
```

也可以通过给元素赋空值，删除一些元素：

```python
>>> list=['a','b','c','d','e','f']
>>> list[1:3]=[]
>>> print list
['a','d','e','f']
```

或是利用列表片断，在特定的位置插入元素。

```python
>>> list = ['a','d','f']
>>> list[1:] = ['b','c']
>>> print list
['a','b','c','d','f']
>>> list[4:4] = ['e']
>>> print list
['a','b','c','d','e','f']
```

### 元素的删除

Python提供了关键字del删除列表中的元素。

```python
>>> a=['one', 'two', 'three']
>>> del a[1]
>>> a
['one','three']
```

关键字del可以处理负数索引。如果索引超出范围，就会产生运行时错误。也可以用片断作为关键字del的索引：

```python
>>> list = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del list[1:5]
>>> print list
['a','f']
```

### 变量和值

每个变量有唯一的标识符，可以用函数id查看标识符。

在内存中，相同字符串，只存在一份；列表、整数、浮点数则不然。

### 别名

因为变量指向内存中的值，如果我们将一个变量赋值给另一个变量，那么这两个变量指向同一个对象。

```python
>>> a = [1,2,3]
>>> b = a
>>> id(a)
7987344
>>> id(b)
7987344
```

因为列表有不同的名字，分别叫做a和b，我们叫它别名。利用操作符"[]"修改任何一个列表的元素，另一个列表做相同的改变。如果重新对其中的一个赋值，那么这两个列表的标识符就不在是相同的了，即已经分别属于不同的列表：

```python
>>> a = [1, 2, 3]
>>> b = a
>>> b[0] = 5
>>> print a
[5, 2, 3]
>>> b = [5, 2, 3]
>>> id(a), id(b)
(13663768, 13615376)
```

### 克隆列表

如果要修改列表，但是要保留原来列表的一份拷贝，就需要列表自我复制，这过程叫做克隆。克隆的结果是产生两个值一样，但却有不同标识符的列表。克隆的方法是利用列表的片断操作符：

```python
>>> x = [1, 3, 5, 7]
>>> y = x[:]
>>> print y
[1, 3, 5, 7]
>>> y[0] = 9
>>> print y
[9, 3, 5, 7]
>>> print x
[1, 3, 5, 7]
>>> id(x)
13161832
>>> id(y)
13075520
```

利用片断操作符，克隆了整个列表。可以清楚的看到，x和y分别代表不同的列表。修改y的元素值，不影响x 列表。

### 列表参数

传递列表参数实际上是传递列表的别名，而不是列表的拷贝。

### 列表嵌套

嵌套的列表是作为另一个列表中的元素。其实列表可以看作是数组，嵌套列表就是多维数组的元素。所以也可以按照下列形式取得元素：

```python
>>> list = [0, [1,2,3], [4,5,6]]
>>> list[0][0]
>>> print list[1][0]
1
>>> print list[1][0],list[1][1],list[1][2]
1 2 3
```

### 矩阵

嵌套列表可以代表矩阵

```python
>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

### 列表映射

```python
>>> fruit = ['apple', 'orange', 'pear', 'banana']
>>> [fruit + 's' for fruit in fruit]
['apples', 'oranges', 'pears', 'bananas']
```

如果我们只想对满足条件的元素进行处理该怎么办呢？很简单，只要在加上if语句就行了。

```python
>>> [fruit + 's' for fruit in fruit if len(fruit) != 6]
['apples', 'pears']
```

## 序列

在Python中还有另一种叫做序列的数据类型。它和列表比较相近，只是它的元素的值是固定的。序列中的元素以逗号分隔开。

通常情况下，序列用小括号括起来。如果要创造一个包含一个元素的序列，那需要在序列的最后加上逗号。要是不加逗号，就把这个变量当成字符串。

```python
>>> tuple = 'a', 'b', 'c', 'd', 'e'
>>> tuple = ('a', 'b', 'c', 'd', 'e')

>>> t1 = ('a',)
>>> type(t1)
<type 'tuple'>

>>> t2 = ('a')
>>> type(t2)
<type 'string'>
```

和列表相似，也可以用索引从序列中读取一个元素。也可以用片断操作符取得列表的一部分。

如果我们试图更改序列的值，解释器会返回错误信息：object doesn't support item assignment

但是我们可以用另一个方法修改序列中的元素：

```python
>>> tuple = ('A',) + tuple[1:]
>>> tuple
('A', 'b', 'c', 'd', 'e')
```

### 序列赋值

在编程中，我们可能要交换两个变量的值。用传统的方法，需要一个临时的中间变量。

Python用序列轻松的解决了这个问题：

```python
>>> a = 1
>>> b = 2
>>> c = 3
>>> a, b, c = c, b, a
>>> print a, b, c
3 2 1
```

从这个例子可以看到，右边序列元素的值按照从左到右的顺序赋值给左边的序列元素。如果右边的序列包含表达式，则先进行计算，然后再赋值。

很自然的想到，如果两个序列的元素个数不相等会怎样呢？解释器会报告出错：unpack tuple of wrong size

### 序列作为返回值

一个语义错误：

```python
>>> def swap(x, y):
x, y = y, x
>>> a = 1
>>> b = 2
>>> swap(a, b)
>>> print a, b
1 2
```

### 随机函数

random模块中的函数random能够产生一个值的范围在0.0到1.0之间的浮点数

```python
>>> import random
>>> for i in range(10):
x = random.random()
print x
```

### 随机数列表

我们编写了一个产生随机数列表的函数：randomList。它的参数是一个整数，返回列表的长度等于这个整数。

```python
>>> import random
>>> def randomList(n):
s = [0] * n
for i in range(n):
s[i] = random.random()
return s
>>> randomList(8)
[0.16067655722093033, 0.80172497198506543, 0.43563417769110524,
0.77550762310178989, 0.062999438929851159, 0.55282106935533726,
0.29624064851123899, 0.11623351040588936]
```

产生的随机数是均匀分布的，也就是说每一个值的机率是相等的。函数random产生的随机数范围是从0.0到1.0。如果把这个范围再分成几个部分，那么每部分产生的随机数的个数，从理论上讲，应该是完全相等。下面来验证这个猜想。

### 计数

解决像这样问题的好办法是把它分成几个子问题，再寻找子问题的解决办法。我们想计算在给定范围内随机数出现的个数。我们曾写了一个程序，遍历一个字符串，计算给定字符出现的次数。对这个程序作一些修改，使之能够解决现在的问题。这个程序的源代码是：

```python
count = 0
for char in fruit:
  if char == 'a':
    count = count + 1
print count
```

第一步：list替换fruit；num替换char。不要着急改变其他部分。

```python
count = 0
for num in list:
  if num == 'a':
    count = count + 1
print count
```

第二步：修改测试条件。检查变量num是否出现在变量low和high之间。

```python
count = 0 for num in list
  if low < num < high:
    count = count + 1
print count
```

第三步：封装代码在名为inBucket的函数中。参数是list、low和high。

```python
def inBucket(list, low, high):
  count = 0
  for num in list:
    if low < num < high:
      count = count + 1
  return count
```

通过拷贝和修改存在的程序，我们很快就写完了一个函数，节约了大量的调试时间。

### 分割范围

如果我们测试的范围较大，还算方便。但是范围越小，就越麻烦。例如：

```python
bucket1 = inBucket(a, 0.0, 0.25)
bucket2 = inBucket(a, 0.25, 0.5)
bucket3 = inBucket(a, 0.5, 0.75)
bucket4 = inBucket(a, 0.75, 1.0)
```

有两个问题要解决：一个是要保存每次输入的结果；另一个是计算分割的范围。我们用循环计算分割的范围。

```python
bucketWidth = 1.0 / numBuckets
for i in range(numBuckets):
  low = i * bucketWidth
  high = low + bucketWidth
  print low, "to", high
```

当numBuckets = 8时，输出是：

```sh
0.0 to 0.125
0.125 to 0.25
0.25 to 0.375
0.375 to 0.5
0.5 to 0.625
0.625 to 0.75
0.75 to 0.875
0.875 to 1.0
```

现在回到第一个问题，用一个列表存储这八个整数结果。

```python
numBuckets = 8
buckets = [0] * numBuckets
bucketWidth = 1.0 / numBuckets
for i in range(numBuckets):
  low = i * bucketWidth
  high = low + bucketWidth
  buckets[i] = inBucket(list, low, high)
print buckets
```

通过把一个大问题分解成几个小问题，再逐个解决这些小问题，最后就把大问题解决了。这种方法我称之为“个个击破”。

## 字典

到目前为止，我们已经学习了三种复合数据类型：字符串、列表和序列。它们用整数作为索引。如果你试图用其它类型做索引，就会产生错误。

字典的索引可以是字符串，除了这一点，它与其它组合类型非常相似。当然，字典的索引也可以是整数。

我们可以创造一个空字典，然后再添加元素。字典的元素以逗号为分隔符，每个元素包含键和键值，它俩用冒号分隔。

键值的顺序与创建时的顺序不同。其实，不必太在意键值顺序。因为我们是利用键浏览与之对应的值。

### 字典操作

函数del删除字典中的元素。

```python
>>> inventory = {'apples': 430, 'bananas': 312,\
'oranges': 525, 'pears': 217}
>>> print inventory
{'oranges': 525, 'apples': 430, 'pears': 217, 'bananas': 312}
>>> del inventory['pears']
>>> print inventory
{'oranges': 525, 'apples': 430, 'bananas': 312}
>>> inventory['pears'] = 0
>>> print inventory
{'oranges': 525, 'apples': 430, 'pears': 0, 'bananas': 312}
>>> inventory.clear()
{}

>>> os = {1: 'Linux', 2: 'Uinx', 3: 'FreeBSD'}
>>> len(os)
3
```

### 别名和拷贝

字典是可变的。如果你想修改字典，并且保留原来的备份，就要用到字典的copy方法。看下面的例子：

```python
>>> opposites = {'up': 'down', 'right': 'wrong', \
'true': 'false'}
>>> alias = opposites
>>> copy = opposites.copy()
```

alias和opposites指向同一个值。而copy则指向全新的拷贝。如果修改alias，opposites也发生变化。

```python
>>> alias['right'] = 'left'
>>> opposites['right']
'left'
```

但是如果修改copy，opposites不变。

```python
>>> copy['right'] = 'privilege'
>>> opposites['right']
'left'
```

### 稀疏矩阵

![x](./Resource/3.png)

如图表示的是稀疏矩阵，用列表表示如下：

```python
matrix = [ [0,0,0,1,0],
           [0,0,0,0,0],
           [0,2,0,0,0],
           [0,0,0,0,0],
           [0,0,0,3,0] ]
```

也可以用字典表示矩阵。该矩阵的非零元素的键用含有两个整数元素的序列表示，分别代表行和列。

```python
matrix = {(0,3): 1, (2, 1): 2, (4, 3): 3}
```

仅仅需要三个键值对表示矩阵的非零值。每个键的类型是数组，键值是整数。用这种方法，我们不能得到值为零的元素，因为这个矩阵中，没有非零值的键。

```python
>>> matrix = {(0,3): 1, (2, 1): 2, (4, 3): 3}
>>> matrix[2, 1]
2
>>> matrix[2, 2]
KeyError: (2, 2)
```

get方法解决了这个问题。

```python
>>> matrix.get((1, 3), 0)
0
```

第一个参数是键；第二个参数表示：如果该键没有出现在字典中，那么这个键的值就是第二个参数。

### 暗示

请看下面的函数：

```python
def fibonacci (n):
  if n == 0 or n == 1:
    return 1
  else:
    return fibonacci(n-1) + fibonacci(n-2)
```

你可能注意到：n的值约大，程序运行的时间就越长。当n等于32时，大约运行25秒。为什么会这样呢？看一下函数的调用图：函数出现了重复的调用。

![x](./Resource/4.png)

比如 n=2 就出现了两次。所以这是没有效率的解决方法。当n变大时，情况变得更糟。一个好的解决办法是将已经运算完的结果保存在字典中，以备以后所需。

```python
previous = {0:1, 1:1}
def fibonacci(n):
  if previous.has_key(n):
    return previous[n]
  else:
    newValue = fibonacci(n-1) + fibonacci(n-2)
    previous[n] = newValue
    return newValue
```

字典首先定义了当n=0,1时的值。当函数fibonacci被调用，先检查字典中是否包含要计算的结果。如果有就立刻返回结果，不再做递归调用。若没有，就得计算新值，并且新值在函数返回前加入到字典中。

用这个版本的fibonacci函数，我们的计算机能够瞬间计算n=40的值。要使用老版本的fibonacci函数，你必须耐心等待。当我们计算n=50时，会得到一个错误：

```python
>>> fibonacci(50)
OverflowError: integer addition
```

python用一种叫做长整数的类型处理任意大小的整数。通常，我们用整数后面加一个大写的 L 表示长整数。

```python
>>> type(3L)
<type 'long'>
```

另一种方法是用函数long把任意的数字类型，即使是数字字符窜，转换成长整数。

```python
>>> long(34)
34L
>>> long(3.4)
3L
>>> long('34')
34L
```

所有的数学操作符都适用于长整数。因此，对于上面的函数fibonacci不必做太多的更改，就能正常运行了。

```python
>>> previous = {0:1L, 1:1L}
>>> fibonacci(50)
20365011074
```

### 计算字符串

我们曾写过一个函数,目的是计算字符串中字母出现的次数。而字典提供了一个很好的方法，来统计字母出现的次数。

```python
>>> letterCounts = {}
>>> for letter in "Mississippi":
letterCounts[letter] = letterCounts.get (letter, 0) + 1
>>> print letterCounts
{'i': 4, 'p': 2, 's': 4, 'M': 1}
```

Python有两个函数items和sort能够更好的完成这一功能。

```python
letterItem = letterCounts.items()
print letterItem
[('i', 4), ('p', 2), ('s', 4), ('M', 1)]
letterItem.sort()
print letterItem
[('M', 1), ('i', 4), ('p', 2), ('s', 4)]
```

## 文件

### 文件的打开和关闭

程序运行的时候，相关数据是保存在内存中的，关闭计算机电源，内存中的数据就丢失了。为了永久的保存数据，必须将数据存储于文件内，文件通常是保存在硬盘、软盘或光盘中。

打开文件就是创造了文件对象。下面的例子中，变量 f 指向一个文件对象。

```python
>>> f = open("test.dat", "w")
>>> print f
<open file 'test.dat', mode 'w' at 0x0151F8A8>
```

函数open的第一个参数是文件名，第二个是打开的模式。"w"表示以写入的方式打开文件。如果文件"test.dat"不存在，open函数就创建它，否则，新创建的文件覆盖已经存在的文件。当我们打印文件对象时，显示了
文件名、模式和对象位置等信息。

为了把一些内容写到文件中，需要调用文件对象的write方法：

```python
>>> f.write("Now is the time")
>>> f.write("to close the file")
>>> f.close()
```

文件的方法close关闭文件。我们向文件test.dat写入了两个字符串，这两个字符串以如下形式存在于文件的同一行：

```sh
Now is the timeto close the file
```

如果要让这两个字符串分别处于一行，则应该在第一个字符串后面加上换行符：

```python
f.write("Now is the time\n")
```

现在可以再一次的打开文件，但这次不是以写的方式，而是以读的方式，即"r"。

```python
f = open("test.dat", "r")
```

如果要以读的方式打开一个不存在的文件，解释器会显示错误信息：

```python
>>> f = open("tes.dat", "r")
IOError: [Errno 2] No such file or directory: 'tes.dat'
```

当创建或读取文件时，Python首先在当前的目录进行工作。若想在别的目录下工作，就必须指明完整的路径。

例如：

```python
>>> f = open("c:\\test.dat", "w")
>>> f.write("OK")
>>> f.close()
```

为了把文件的内容写到字符串中，可以用文件对象的read方法。

```python
text = f.read()
print text
Now is the timeto close the file
```

因为在"time"和"to"之间没有写入空格，所以这两个词连在了一起。

read可以接受数字参数，表示读出一定数量的字符。如果读到文件的末尾，就返回空字符。

```python
>>> f = open("test.dat", "r")
>>> print f.read(5)
Now i
>>> print f.read(100)
s the timeto close the file
>>> print f.read()

>>>
```

接下来的函数是拷贝文件，一次读写五十个字符。第一个参数是源文件名，第二个参数是新文件名。

```python
def copyFile(oldFile, newFile):
  f1 = open(oldFile, "r")
  f2 = open(newFile, "w")
  while 1:
    text = f1.read(50)
    if text == "":
      break
    f2.write(text)
  f1.close()
  f2.close()
  return
```

break表示是当没有字符拷贝，也就是"text"为空字符时，彻底跳出"while"循环，这也是唯一结束"while"循环的方式。

### 文本文件

文本文件包含可打印字符和空格，每一行以换行符为结束标志。Python是处理文本文件的行家里手。下面的例子建立了一个文本文件，它有三行：

```python
>>> f = open("test.dat", "w")
>>> f.write("I love Python!\nHello, world\nGood Bye!\n")
>>> f.close()
```

readline方法每次从文本文件中读取一行的内容，包括换行符：

```python
>>> f = open("test.dat", "r")
>>> print f.readline()
I love Python!

>>>
```

readlines方法以列表的方法返回文件内其余的内容：

```python
>>> print f.readlines()
['Hello, world\n', 'Good Bye!\n']
```

这时已到达文件的末尾，如果在调用上述两个方法，readline 方法返回空字符，readlines方法返回空列表：

```python
>>> print f.readline()

>>> print f.readlines()
[]
```

接下来的例子是行处理程序，函数filterFile拷贝一个文件，同时将旧文件中不是以"＃"开头的行写入新文件中：

```python
def filterFile(old, new):
  sfile = open(old, "r")
  dfile = open(new, "w")
  while 1:
    text = sfile.readline()
    if text == "":
      break
    elif text[0] == "#":
      continue
    else:
      dfile.write(text)
  sfile.close()
  dfile.close()
```

在这个函数里有两个关键字：break和continue。break 表示如果读取的行内容为空，则完全终止 while 的循环；continue 表示若行的首字符为"＃"，则终止这一次的循环，也就是 continue 以下的循环内的语句不执
行了，返回到循环的顶部继续下一次循环。

### 写入变量

write的参数只能是字符串，如果想把其它类型的变量写入文件，就必须将其转换成字符串。一个简单的方法是利用str函数：

```python
>>> f = open("test.dat", "w")
>>> f.write(str(1234.56) + '\n')
>>> f.write(str(1000))
>>> f.close()
```

另一种方法是利用格式化操作符"%"。当操作符"%"的两边是整数时，它是求余数的运算。如果第一个操作符是字符串，它就是格式化操作符。第一个参数是需要格式化的字符串，第二个参数是数组表达式。结果是包含表达式值的字符串。请看下面的例子：

```python
>>> age = 31
>>> "%d" % age
'31'
```

格式化序列"%d"表示数组中的第一个表达式的值应该是整数类型，字母d代表"decimal"。

格式化序列可以出现在字符串的任何位置，所以我们能够在句子中嵌入值：

```python
>>> age = 31
>>> "My age is : %d." % age
'My age is : 31.'
```

格式化序列"%f"对应是浮点数，默认的小数点后面有六位小数。"%s"对应是字符串。表达式要与字符串中的格式化序列相匹配，匹配包含两个方面，一个是有几个表达式，就有几个格式化序列；另一个是格式化序列与表达式值的类型相对应。

```python
>>> "In %d days we make %f million %s." % \
(31, 31*12.59, 'dollars')
'In 31 days we make 390.290000 million dollars.'
>>> "d% d% d%" % (3, 4 ,5 ,6)
ValueError: incomplete format #错误信息
>>> "d%" % 8.0
ValueError: incomplete format #错误信息
```

对于要格式化的数字，我们还能够指定它所占的位数。"%"后面的数字表明数字的位数，如果位数多于数字的实际位数，且该数为正，则在要格式化的数字的前面添加空格；如果该数为负，空格添加在数字的后面：

```python
>>> "%5d" % 1
'     1'
>>> "%-5d" % 1
'1     '
>>> "%4f" % 9.1
'9.100000'
>>> "%3f" % 1234
'1234.000000'
>>> "%3d" % 1234
'1234'
```

对于浮点数，我们还可以指定小数的位数：

```python
>>> "%4.3f" % 1137.98
'1137.980'
```

下面的例子是按照一定的格式打印姓名和工资。姓名是字典的键，工资是字典的值。姓名左对齐，工资右对齐,同时对姓名进行了排序：

```python
>>> def printSalary(salary):
    name = salary.keys()
    name.sort()
    for n in name:
      print "%-12s : %12.2f" % (n,salary[n])
>>> salary = {'pidaqing':1137.9, 'zhangming':737.3, 'pitianjian':5.0}
>>> printSalary(salary)
pidaqing    : 1137.90
pitianjian  : 5.00
zhangming   : 737.30
```

从上述的内容可以看到，为了将不同类型的数据保存到文件，必须将其转换成字符串。结果导致从文件中读的一切内容都是字符串，数据的原始类型信息丢失了。解决的办法是输入pickle模块，用它提供的方法把各种类型的数据存入文件，数据结构的信息也同样被保存了。也就是说，你保存了什么，将来读出的还是什么。例如：

```python
>>> import pickle
>>> f = open("test.dat", "w")
>>> pickle.dump(100, f)
>>> pickle.dump(123.98, f)
>>> pickle.dump((1, 3, "abc"), f)
>>> pickle.dump([4, 5, 7], f)
>>> f.close()
```

在这个例子中，我们用dump方法分别向文件中写入了整数、浮点数、列表和数组。如果你用write方法写入，那是会出错的。

接下来就看能不能把这些数据“原封不动”的读出来：

```python
>>> f = open("test.dat", "r")
>>> a = pickle.load(f)
>>> print a
100
>>> type(a)
<type 'int'>
>>> b = pickle.load(f)
>>> print b
123.98
>>> type(b)
<type 'float'>
>>> c = pickle.load(f)
>>> print c
(1, 3, 'abc')
>>> type(c)
<type 'tuple'>
>>> d = pickle.load(f)
>>> print d
[4, 5, 7]
>>> type(d)
<type 'list'>
```

每调用一次load方法，就得到先前存入的一个变量，而且这个变量还保存着原始类型的信息。

## 异常

## 错误信息

程序出错了，就会产生异常。异常是不可避免的，关键是怎样处理。当然不能任其放任自流，不管不问。起码的要求是解释器终止程序的运行，指出错误类型，以及对错误进行简单描述。

例如，除数为零时，IDE产生一个异常：

```python
>>> print 2/0
ZeroDivisionError: integer division or modulo by zero #异常信息
```

异常信息分为两个部分，冒号前面的是异常类型，之后是对此的简单说明。其它的信息则指出在程序的什么地方出错了。当异常产生时，如果没有代码来处理它，Python对其进行缺省处理，输出一些异常信息并终止程序。

程序在执行的过程中产生异常，但不希望程序终止执行，这时就需要用 try 和 except 语句对异常进行处理。比如，提示用户输入文件名，然后打开文件。若文件不存在，我们也不想程序就此崩溃，处理异常处理就成了关键的部分。

```python
filename = ''
while 1:
  filename = raw_input("Input a file name: ")
  if filename == 'q':
    break
  try:
    f = open(filename, "r")
    print 'Opened a file.'
  except:
    print 'There is no file named', filename
```

try块的语句要求打开一个文件，如果没有异常发生，就忽略except块的内容；如果产生异常，就执行except块内的语句，之后是再一次的循环。

### 自定义异常信息

如果程序检测到错误，我们也可以用raise定义异常。

```python
def inputAge():
  age = input("Input your age:")
  if (age>100 or age<18):
    raise 'BadNumberError', 'out of range'
  return age
```

raise有两个参数，第一个是由我们自己定义的异常类型，第二个是关于此异常的少量说明信息。如果调用inputAge的函数有处理异常的程序，即使inputAge出错，整个程序也能正常运行；否则，程序退出，显示错误信息。

```python
>>> inputAge()
Input your age:31
31
>>> inputAge()
Input your age:109
BadNumberError: out of range #异常信息
```

***一个复杂的例子***

让我们看下面的脚本文件：

```python
while 1:
  try:
    x = int(raw_input("Input a number:"))
    y = int(raw_input("Input a number:"))
    z = x / y
  except ValueError, ev:
    print "That is no valid number.", ev
  except ZeroDivisionError, ez:
    print "divisor is zero:", ez
  except:
    print "Unexpected error."
    raise
  else:
    print "There is no error."
print x , "/" , y , "=" , x/y
```

在这个例子中有三个except语句。一个try语句可以和多个except配合使用，但只可能是其中的一个被执行。

前两个except语句，接受两个参数。第一个参数是异常的类型，第二个参数用于接收异常发生时生成的值，异常是否有这个参数及参数的类型如何，由异常的类型决定。

异常"ValueError"在这里表示：如果你输入的字符串包含非数字类型的字符，这个异常将被引发。

异常"ZeroDivisionError"表示除数为0引发的异常。

最后一个except语句表示当有异常发生，但不是前面定义的两种类型，就执行这条语句。用这样的 except 语句要小心，理由是你很可能把一个应该注意的的程序错误隐藏了。为了防止这种情况的发生，我们用了 raise 语句，将异常抛出。

当没有任何异常发生时，else语句的内容被执行。else语句一定放在所有except语句的后面。

## 类和对象

### 用户定义数据类型

以前学过的数据类型都是Python内置的，从现在开始我们要自己定义数据类型：点（point）。

在数学上，点的位置由两个坐标决定。例如，（0,0）代表坐标原点，（x,y）代表行轴为x、纵轴为y的点。在Python中，一个自然的方法是用两个浮点数表示点的横坐标和纵坐标。而问题的关键是如何把这两个浮点数
组合起来，形成一个新的数据对象，用列表，或是数组，对于某些方面的
应用来说，这也许是上佳之选。

另外一个选择是将点定义成类（Class），即用户为自己的应用定义的数据类型。类的好处会随着学习的深入，逐渐被我们体会到。

类的定义方式如下：

```python
class Point:
  pass
```

关键字class表示Point是我们定义的类，也就是向程序声明了一种新的数据类型。类Point的实质内容暂时没有，但又不能为空，所以用pass替代，以便将来添加。类的定义可以放在程序的任何地方，通常是放在程序开始部分，import语句之后。

类只是对实体的一种抽象和概括。打个比方，自然界包括动物和植物，动物这个概念是对千千万万个体的共有特征的一种描述，你不可能找到一只叫“动物”的动物，但我们能够找到你养的一只狗，动物园里的一只猴子，这些都是实实在在存在的个体。类的概念与之非常相似。点类只是无数个实际点的抽象，这些无数个实际点是点类的实例。点类需要实例化才能生成一个实际的点。如果创建一个点的对象，需调用名为Point的函数：

```python
blank = Point()
```

变量blank指向一个实际的点对象。函数Point创造点对象的过程叫做构造。

### 属性

上节创造了一个点对象，但这个对象除了名字，没有任何内容。现在利用点操作符给这个点对象添加了两个数据项：横坐标和纵坐标。这两个数据项叫做点的属性。

```python
>>> class Point:
pass

>>> blank = Point()
>>> blank.x = 3.0
>>> blank.y = 4.0
```

利用点操作符我们也可以打印点的属性：

```python
>>> print blank.x
3.0
>>> print blank.y
4.0
```

blank.x表示的是对象blank的x属性，即点blank的横坐标，blank和x通过点操作符组成一个不可分割的整体，代表blank的属性。它们可以作为表达式的一部分，参加运算。

```python
>>> import math
>>> distance = math.sqrt(blank.x * blank.x + blank.y * blank.y)
>>> print distance
5.0
```

也可以打印blank对象本身：

```python
>>> print blank
<__main__.Point instance at 0x00C76980>
```

结果显示blank是点类Point的一个实例，它被定义在main 中。0x00C76980是这个对象的唯一标识符，用十六进制表示。

我们也可以用type函数测试一下Piont和blank。

```python
>>> type(blank)
<type 'instance'>
>>> type(Point)
<type 'class'>
```

可以看出，blank是一个实例，Point是类。

blank是一个实例，也是一个变量，所以对象可作为函数的参数：

```python
>>> def printPoint(p):
  print '(' + str(p.x) + ',' + str(p.y) + ')'

>>> printPoint(blank)
(3.0,4.0)
```

这个函数以点的一个实例为参数，打印该点的行、纵坐标。

### 同一性

英文单词"same"的意思是同一的、相同的，这似乎没有异议，如果我们再深入探讨一下，可能期望与所想并不一致。

例如，你说，"Chris and I have the same car"，你的意思是Chris和我的车为同一个厂家，同一个型号，但却是两辆不同车。如果你说，"Chris and I have the same mother"，这里意思是Chris和我的妈妈是同
一个人，可不是两个不同的妈妈。由此可见，"Sameness"的真正意思要根据上下文来判断。

当我们讨论对象时，也同样存在这样的模糊性。例如，我们说两个相同的点，可能这两个点的数据（横、纵坐标）相同，也可能他们就是同一个对象。我们可以利用"=="操作符判断两个点是否为同一对象：

```python
>>> p1 = Point()
>>> p1.x = 1.0
>>> p1.x = 9.0
>>> p2 = Point()
>>> p2.x = 1.0
>>> p2.y = 9.0
>>> p1 == p2
0
```

从这个例子可以看到，点p1和p2虽然有相同的数据，但却是两个不相同的对象。若是把p2赋值给p1，那么p1和p2就是同一对象的两个别名。

```python
>>> p1 = p2
>>> p1 == p2
1
```

## 拷贝

别名增加了程序阅读的困难，因为在一个地方改变了对象的值，但在另一个地方可能是不希望的。并且追踪对象所有的别名，又是很困难的。

解决的方法是拷贝对象，生成一个新的对象实例。copy模块的方法copy能够复制任何对象。

```python
>>> p1 = Point()
>>> p1.x = 2.0
>>> p1.y = 4.0
>>> p2 = p1
>>> print p1,p2
<__main__.Point instance at 0x00D76878>
<__main__.Point instance at 0x00D76878>
>>> p2 = copy.copy(p1)
>>> print p1, p2
<__main__.Point instance at 0x00D76878>
<__main__.Point instance at 0x00D009A0>
>>> print p1.x,p1.y
2.0 4.0
>>> print p2.x,p2.y
2.0 4.0
```

输入copy模块之后，我们用copy方法复制了一个新的点对象，但他们数据项的值相同。

一些简单的对象，如点，没有包含任何嵌入的对象，copy方法已经足够了。这种复制叫做浅拷贝。

对于象长方形类的对象，它的属性中包含点对象，再用copy方法进行复制，虽然生成了新的长方形对象，但这两个对象的点对象是同一个对象：

```python
>>> r1 = Rectangle()
>>> r1.width = 1.0
>>> r1.height = 2.0
>>> r1.corner = Point()
>>> r1.corner.x = 0
>>> r1.corner.y = 0
>>> r2 = copy.copy(r1)
>>> print r1.corner, r2.corner
<__main__.Point instance at 0x00D44BA8>
<__main__.Point instance at 0x00D44BA8>
```

显然这也不是我们希望的结果。

幸运的是，copy模块包含了一个名为deepcopy的方法，它可以拷贝任何嵌入的对象。这种拷贝我们称之为深拷贝。

```python
>>> r2 = copy.deepcopy(r1)
>>> id(r1)
13831952
>>> id(r2)
14043608
>>> id(r1.corner)
13913000
>>> id(r2.corner)
14003528
```

b1和b2已经是完全不同的对象了。

## 类与方法

### 面向对象的技术

Python是面向对象的编程语言，自然提供了面向对象的编程方法。但要给面向对象的编程方法下一个定义，是很困难的。问题关键是理解对象的含义。对象的含义是广泛的，它是对现实世界和概念世界的抽象、模拟和提炼。

世界本来就是对象的世界，一台电脑、一座大楼、一座大山、2003年6月10日、数学中的一条线，大到宇宙，小到原子，从无形到有形，都可以看作对象。我们自打出生的那一天起，就要面对对象。比如你看新闻联播，了解国内外大事，我们最终的结果是得到信息，但信息不会凭空传递而来，它是靠电视向你传播的。电视机正是你要面对的对象。

对象可以嵌套。比如把我的电脑看作是一个对象，那么它就由以下对象组成：显示器、键盘、鼠标、主机、音箱等。计算机对象是所有这些对象组合而成的。当然其中的每一个对象，还可以细分，例如主机还可以分为机箱、CPU等等。究竟要不要细分，要根据情况来定。如果你给初学计算机的人讲解有关硬件的知识，刚开始，只要把上述几部分介绍就可以了。随着学习的深入，你就必须更详细的介绍每一部分。所以说，对象要不要细分，完全依据需要而定。

对象不是一个空壳，而是有血有肉的实体。它有特点，或曰属性。例如，人的高矮胖瘦就是属性。光有属性还不够，我们还会跑步、听歌和愤怒等等，这些是我们的方法。属性是动，方法是静。方法分为两类，一种是与外界无关的，如跑步；一种是和其他对象交互，如愤怒。

世界是物质运动的结果。对象之间的相互作用，就是对象的运动，即事件。与世隔绝的对象是没有任何价值的。当然你可以在程序中创建一个“老死不相往来”的对象，但它是一种资源浪费，没有实用价值。现实中一项工作的完成，是很多人和物相互协调、相互作用的结果。一个程序要达到的目的，也是很多对象相互作用的结果。

对象的方法与函数类似，但还有两方面的区别：

1. 方法定义在类的内部，是类的一部分，他们之间的关系是很明显的；
2. 调用的语法不一样。

现在，我们定义一个时间类和打印时间的函数：

```python
class Time:
  pass
def printTime(time):
  print str(time.hours) + ":" +
    str(time.minutes) + ":" +
    str(time.seconds)
```

时间类有三个属性：hours、minutes和seconds。函数printTime则是显示这三个属性值。调用这个函数时，我们以一个时间对象为参数：

```python
>>> now = Time()
>>> now.hours = 10
>>> now.minutes = 30
>>> now.seconds = 10
>>> printTime(now)
```

为了把函数变成类Time的方法，我们只需要将其移到类定义的内部。注意缩进的改变。

```python
class Time:
  def printTime(self):
    print str(time.hours) + ":" + \
      str(time.minutes) + ":" + \
      str(time.seconds)
```

这时在调用方法时，就用点操作符：

```python
>>> now.printTime()
```

通常，方法的第一个参数是调用它自己：self。在用函数打印时间时，相当于说，“嘿，printTime！打印now对象。”当调用自己的方法时，等于说，“嘿，now！打印你自己。”

再看另一个方法：

```python
def increment(self, seconds):
  self.seconds = seconds + self.seconds
  
  while self.seconds>=60:
    self.seconds = self.seconds - 60
    self.minutes = self.minutes + 1

  while self.minutes>=60:
    self.minutes = self.minutes - 60
    self.hours = self.hours + 1
```

这个函数有两个参数，一个它自己，一个seconds。函数的意思是，在当前的时间上加上一定的秒数，就得到一个新的时间。例如：

```python
now.nicrement(100)
```

函数调用时，第一参数是默认的，不必写出来。

接下来我们在看一个稍微复杂的after方法。after方法判定两个时间哪一个在前。他有两个参数，一个是它自己，另一个是他的同类。

```python
def after(self, time):
  if self.hour>time.hour:
    return 1
  if self.hour<time.hour:
    return 0

  if self.minute > time.minute:
    return 1
  if self.minute < time.minute:
    return 0

  if self.second > time.second:
    return 1
return 0
```

### 可选择的参数

我们曾见到一些内置的函数，能够接受的参数个数是可变的。同样，你也能够定义可变参数的函数。下面这个函数求从数head开始，到tail为尾，步长为step的所有数之和。

```python
def total(head, tail, step):
  temp = 0
  while head<=tail:
    temp = temp + head
    head = head + step
  return temp
```

它有三个参数，调用函数时，三个参数都不能省略。

有的参数之所以可以省略，是因为函数中已经给出了缺省的参数。我们把上面的函数作一下改造，定义step的缺省参数为1：

```python
total(head, tail, step=1)
```

现在调用total函数时，step参数就可以省略，但不表示step不存在，它的值是默认的1。当然你也可以根据需要取其他值。如下：

```python
>>> print total(1, 100)
5050
>>> print total(1, 100, 2)
2500
```

缺省参数的定义要符合以下规则：缺省参数全部位于参数表的后部，而且缺省参数之间不能在有非缺省参数。下面定义是不合法的：

```python
total(head=1, tail, step) #错误的定义
total(head=1, tail, step=1) #错误的定义
total(head, tail=100, step) #错误的定义
```

### 构造函数

构造函数是任何类都有的特殊方法。当要创建一个类时，就调用构造函数。它的名字是：`__init__`。init的前后分别是两个下划线字符。时间类Time的构造函数如下：

```python
class Time:
  def __init__(self, hours=0, minutes=0, seconds=0):
    self.hours = hours
    self.minutes = minutes
    self.seconds = seconds
```

当我们调用Time的构造函数时，参数依次传递给__init__：

```python
>>> now = Time(12, 10, 30)
>>> now.printTime()
12:10:30
```

因为Time的构造函数都有缺省值，所以在创建类时，可以全部忽略他们：

```python
>>> now = Time()
>>> now.printTime()
>>> 0:0:0
```

还可以传递一个或两个参数：

```python
>>> now = Time(23)
>>> now.printTime()
23:0:0
>>> now = Time(12, 10)
>>> now.printTime()
12:10:0
```

最后，我们还可以传递参数子集：

```python
>>> now = Time(seconds = 35, hours = 19)
>>> now.printTime()
>>> 19:0:35
```

这种情况下，并不强调参数一定要符合定义时的顺序。

## 操作符重定义

### 加减法重定义

Python的基本数据类型如整数、浮点数，能够进行数学运算。类可以吗？看下例：

```python
>>> class RMB:
  def __init__(self, sum = 0.0):
    self.sum = sum
  def __str__(self):
    return str(self.sum)
>>> a = RMB()
>>> b = RMB()
>>> a + b
TypeError: unsupported operand types for
+: 'instance' and 'instance' #异常信息
```

我们定义了一个人民币类，然后生成两个实例，这两个实例相加之后，显示了一条错误信息，表明实例不能进行相加操作。错误信息的意思是，加法操作暂时不支持两个实例操作数。

为了使类的实例也可以进行数学操作，我们需要在类的内部重新定义数学操作符，使之支持用户定义的数据类型。有些朋友可能马上意识到，这不是C++中的操作符重载吗？在这里我没有用“重载”这个词，

我认为C++中重载要比Python中的重载概念广泛得多，例如C++函数重载，在Python中并不存在这个概念（也许我不知道）。因此，我用了重定义一词。

下面的例子中，修改了RMB类，添加了RMB类的加法和减法操作，也就是RMB类的两个方法：`__add__` 和 `__sub__`。

```python
>>> class RMB:
  def __init__(self, sum = 0.0):
    self.sum = sum
  def __str__(self):
    return str(self.sum)
  def __add__(self, other): #重定义加法操作
    return RMB(self.sum + other.sum)
  def __sub__(self, other): #重定义减法操作
    return RMB(self.sum - other.sum)
```

通常情况下，第一个参数是调用__add__或__sub__方法的对象。第二个参数是other，以区别于第一个参数self。两个实例的相加或相减，也就是各自属性sum的加减，所得的值作为新RMB实例的参数，因此返回值仍是人民币类。请看执行结果：

```python
>>> a = RMB(20000)
>>> b = RMB(234.987)
>>> print a + b
20234.987
>>>print a - b
19765.013
```

其实表达式 a + b 和 `p1.__add__(p2)` 是等同的，我们可以试一试：

```python
>>> a = RMB(34.5)
>>> b = RMB(345.98)
>>> print a.__add__(b), a + b
380.48 380.48
>>> print a.__sub__(b), a - b
-311.48 -311.48
```

### 乘法重定义

与乘法重定义相关的方法有两个，一个是__mul__，另一个是__rmul__。你可以在类中定义其中的一个，也可以两个都定义。

如果乘法操作符"*"的左右操作数都是用户定义的数据类型，那么调用__mul__。若左边的操作数是原始数据类型，而右边是用户定义数据类型，则调用__rmul__。

请看例子：

```python
class Line:
  def __init__(self, length = 0.0):
    self.length = length

  def __str__(self):
    return str(self.length)

  def __mul__(self, other): #乘法重定义
    return Rect(self.length, other.length)

  def __rmul__(self, other): #乘法重定义
    return Line(self.length * other)

class Rect:
  def __init__(self, width = 0.0, length = 0.0):
    self.width = width
    self.length = length

  def __str__(self):
    return '(' + str(self.length) + ',' + str(self.width) + ')'

  def area(self): #计算长方形的面积
    return self.width * self.length
```

在这个例子中，定义了Line（线类）和Rect（长方形类）。重定义了Line类的乘法操作符。第一个重定义表示两个线实例相乘，得到并返回长方形实例。第二个重定义表示一个线实例乘以一个原始数据类型，得到并返回一个线实例。执行结果如下：

```python
>>> aline = Line(5.87)
>>> bline = 2.9 * Line(8.34)
>>> print 'aline = ' , aline, 'bline = ',bline
aline = 5.87 bline = 24.186
>>> rect = aline * bline
>>> print rect
(24.186,5.87)
>>> print rect.area()
141.97182
```

乘法重定义的第二种形式，必须严格按照"2.9 * Line(8.34)"的书写顺序，要是调换一下顺序，解释器将给出错误信息。

```python
>>> bline = Line(8.34) * 2.9
AttributeError: 'float' object has no attribute 'length'
```

## 继承

面向对象程序语言的一个重要特点是继承。继承提供了在已存在类的基础上创建新类的方法。继承的子类拥有被继承的父类的所有方法，在此基础上，子类还可以添加自己的专有方法。

继承是类的强有力的特点。一些程序不用继承将会非常复杂，用了继承，写起来就会简单扼要，通俗易懂。另外，通过继承，还可以重新利用以前编写的代码，因为你可以对父类的方法进行定制，而并非一定要修改它们。有时，继承反映了问题的自然结构，这样使程序更容易理解。

任何事情都有双重性。继承也有可能使程序变得难以阅读。调用一个方法时，有时很难判断它是在哪定义的。相关的代码可能分散在几个模块中。所以，有些事情利用继承的特点能够做好，不利用继承，也可能做的不错。如果问题的自然结构不倾向于用继承解决，那么就不要用，用了反而不好。

假设已经定义了一个父类BaseClass，那么子类的定义方式如下：

```python
class DerivedClass(BaseClass):
  ......
```

子类别的实例化方式没有特别之处。如果要引用子类的某个属性，首先在子类中寻找，没有就去到父类中寻找它的定义，在没有的话，就一直向上找下去，知道找到为止。

方法的寻找方式与属性相同。子类的方法可以重定义父类的方法，要是你觉得父类的方法不能满足要求的话。有时候，子类的方法中可以直接调用父类中的方法，方式如下：

```python
BaseClass.method(self, arguments)
```

示例：

```python
class Person:
  def __init__(self,
               name = None,
               age = 1,
               sex = "men"):
    self.name = name
    self.age = age
    self.sex = sex
  def displayInfo(self):
    print "name : %-20s" % self.name
    print "age : %-20d" % self.age
    print "sex : %-20s" % self.sex
```

这个Person类有三个属性，方法displayInfo用于打印这三个属性。

接着定义了继承Person的student类：

```python
class Student(Person):
  def __init__(self,
               name = None,
               age = 1,
               sex = "men",
               grade = 0:
    Person.__init__(self, name, age, sex)
    self.grade = grade
  def displayInfo(self):
    Person.displayInfo(self)
    print "grade : %-20d" % self.grade
```

Student类中的__init__方法中调用了父类的__init__方法，同时加了一条打印给grade属性赋值的语句。Student类中重定义了父类displayInfo方法，它的内部也调用了父类的displayInfo方法。

在C++语言中有私有方法的概念，私有方法只能被类的内部方法调用。在Python中，类的私有方法和私有属性，不能够从类的外面调用。类的方法和属性是公有，还是私有，可以从它的名字判断。如果名字是以两个下划线开始，但并不是以两个下划线结束，则是私有的。其余的都是公有的。请看下面的例子：

```python
import math

class Point:
  def __init__(self, x = 0, y = 0):
    self.x = x
    self.y = y
  def __str__(self):
    return '(' + str(self.x) + ',' + str(self.y) + ')'
class Line:
  def __init__(self, p1 = Point(), p2 = Point()):
    self.__p1 = p1 #私有属性
    self.__p2 = p2
  def __str__(self):
    return str(self.__p1) + str(self.__p2)
  def __distance(self): #私有方法
    tx = math.pow(self.__p1.x, 2) + math.pow(self.__p2.x, 2)
    ty = math.pow(self.__p1.y, 2) + math.pow(self.__p2.y, 2)
    return math.sqrt(tx + ty)
  def length(self):
    print self.__distance()
```

在这个例子中，Line类的两个属性p1和p2是私有的属性，而方法distance是私有方法。如果试图用如下的语句调用他们，将显示错误信息：

```python
>>> Line().__p1
AttributeError: Line instance has no attribute '__p1'
>>> Line().__distance
AttributeError: Line instance has no attribute '__distance'
```

错误信息显示在类Line中没有与之对应的属性。这表明私有的方法和属性不能在类的的外部调用。
